Copyright 1984 Digitalk Inc.  All rights reserved

! Object class methods !
 initDependents
         "Initialize the Dependents dictionary to empty."
     Dependents := IdentityDictionary new!
 initialize
         "Initialize the class variables for detecting recursive
          data structures."
     RecursiveSet := Set new.
     RecursionInError := false!
 initializeDosErrors
         "Initialize the global dictionary DosErrors.  The keys
          are the DOS integer error codes, values are the strings
          which describe the errors."
 "   DosErrors := Array new: 44.
     1 to: 31 do: [ :index | DosErrors at: index put: ''].
     DosErrors
         at: 2  put: 'file not found';
         at: 3  put: 'path not found';
         at: 5  put: 'access denied';
         at: 15 put: 'invalid drive was specified';
         at: 16 put: 'attempt to remove the current directory';
         at: 17 put: 'not same device';
         at: 19 put: 'directory not empty';
         at: 20 put: 'inconsistent directory entry';
         at: 21 put: 'no empty directory entry found';
         at: 32 put: 'attempt to write on write protected diskette';
         at: 33 put: 'unknown unit';
         at: 34 put: 'drive not ready';
         at: 35 put: 'unknown command';
         at: 36 put: 'data error (CRC)';
         at: 37 put: 'bad request structure length';
         at: 38 put: 'seek error';
         at: 39 put: 'unknown media type';
         at: 40 put: 'sector not found';
         at: 41 put: 'printer fault';
         at: 42 put: 'write fault';
         at: 43 put: 'read fault';
         at: 44 put: 'general failure'"! !

! Object methods !
 = anObject
         "This is the default equality test.  Answer true
          if the receiver and anObject are the same object,
          else answer false."
     <primitive: 110>!
 == anObject
         "Answer true if the receiver and anObject
          are the same object, else answer false."
     <primitive: 110>!
 addDependent: anObject
         "Add anObject to the class Object
          class variable Dependents."
     (Dependents at: self ifAbsent: [
         Dependents at: self put: OrderedCollection new])
             add: anObject!
 allDependents
         "Answer a Set containing all the objects that appear
          in the directed graph of receiver dependents."
     | answer toProcessNow toProcessNext |
     answer := Set new.
     toProcessNow := self dependents.
     [toProcessNow isEmpty]
         whileFalse: [
             toProcessNext := Set new.
             toProcessNow do: [ :dependent |
                 (answer includes: dependent)
                     ifFalse: [
                         answer add: dependent.
                         toProcessNext addAll: dependent dependents]].
             toProcessNow := toProcessNext].
     ^answer!
 asOop
         "Answer the receiver object pointer as an Integer."
     <primitive: 75>
     ^self primitiveFailed!
 at: anInteger
         "Answer the object in the receiver at index position
          anInteger.  If the receiver does not have indexed
          instance variables, or if anInteger is greater
          than the number of indexed instance variables,
          report an error."
     <primitive: 60>
     ^self primitiveFailed!
 at: anInteger put: anObject
         "Answer anObject.  Replace the object in the receiver
          at index position anInteger with anObject.  If the
          receiver does not have indexed instance variables, or
          if anInteger is greater than the number of indexed
          instance variables, report an error."
     <primitive: 61>
     ^self primitiveFailed!
 basicAt: anInteger
         "Answer the object in the receiver at index position
          anInteger.  If the receiver does not have indexed
          instance variables, or if anInteger is greater
          than the number of indexed instance variables,
          report an error."
     <primitive: 60>
     ^self primitiveFailed!
 basicAt: anInteger put: anObject
         "Answer anObject.  Replace the object in the receiver
          at index position anInteger with anObject.  If the receiver
          does not have indexed instance variables, or if anInteger
          is greater than the number of indexed instance variables,
          report an error."
     <primitive: 61>
     ^self primitiveFailed!
 basicHash
         "Answer the integer hash value of the receiver
          based on its object pointer value."
     ^self asOop bitAnd: 16r3FFF!
 basicSize
         "Answer the number of indexed instance variables in
          the receiver."
     <primitive: 62>!
 become: anObject
         "The receiver and anObject exchange identities.  All
          the objects of the system that pointed to the receiver
          will now point to anObject and all the objects in
          the system that pointed to anObject, will no point to
          the receiver."
     <primitive: 72>
     ^self primitiveFailed!
 broadcast: aSymbol
         "Send the argument aSymbol as a unary
          message to all of the receiver's dependents."
     self dependents do: [ :dependent | dependent perform: aSymbol]!
 broadcast: aSymbol with: anObject
         "Send the argument aSymbol as a keyword message with
          argument anObject to all of the receiver's dependents."
     self dependents do: [ :dependent |
         dependent perform: aSymbol with: anObject]!
 cantReturn
         "Initiate a walkback for trying to exit method more than once."
     self error: 'attempt to exit from same method more than once'!
 changed "The receiver changed in some general way.  Inform all
         dependents by sending each dependent an update message."
     self changed: self!
 changed: aParameter
         "Something has changed releated to the dependents
          of the receiver.  Send the 'update: aParameter'
          message to all the dependents."
     (Dependents at: self ifAbsent: [#()]) do: [ :dependent |
         dependent update: aParameter]!
 changed: firstParameter with: secondParameter
         "Something has changed releated to the dependents
          of the receiver.  Send the 'update: firstParameter
          with: secondParameter' message to all the dependents."
     (Dependents at: self ifAbsent: [#()]) do: [ :dependent |
         dependent update: firstParameter with: secondParameter]!
 class
         "Answer the class of the receiver."
     <primitive: 111>
     ^self primitiveFailed!
 copy
         "Answer a shallow copy of the receiver."
     ^self shallowCopy!
 deepCopy
         "Answer a copy of the receiver with shallow
          copies of each instance variable."
     | copy class instanceVars |
     class := self class.
     class isVariable
         ifTrue: [
             instanceVars := self basicSize.
             copy := class new: instanceVars]
         ifFalse: [
             instanceVars := 0.
             copy := class new].
     class isPointers
         ifTrue: [
             1 to: instanceVars + class instSize do: [ :index |
                 copy instVarAt: index
                     put: (self instVarAt: index) copy]]
         ifFalse: [
             1 to: instanceVars do: [ :index |
                 copy basicAt: index
                     put: (self basicAt: index)]].
     ^copy!
 dependents
         "Answer a collection of all dependents of the receiver."
     ^Dependents at: self ifAbsent: [^OrderedCollection new]!
 dependsOn: anObject
         "Add the receiver to anObject's collection
          of dependents."
     anObject addDependent: self!
 doesNotUnderstand: aMessage
         "Initiate a walkback because a message was sent which is
          not understood, i.e., there is no matching method."
     ^self error: 'Message not understood: ', aMessage selector!
 dosError: anInteger
         "Initiate a walkback for a DOS error described by anInteger.
          Print a description of the error in the walkback label."
     | index |
     (anInteger isKindOf: Integer)
         ifFalse: [^anInteger].
     anInteger >= 0
         ifTrue: [^anInteger].
     index := anInteger negated.
     (index > 44 or: [(DosErrors at: index) = ''])
         ifTrue: [
             ^self error:
                 'undefined error: ', anInteger printString].
     ^self error: (DosErrors at: index)!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to aStream
          for aCloner."
     aCloner dump: self on: aStream!
 error: aString
         "Create a walkback window describing an error condition
          with the error message aString in the window label."
     Process copyStack walkBackFor: aString!
 halt
         "Initiate a walkback with 'Halt encountered' message
          for debugging."
     ^self error: 'Halt encountered'!
 hash    "Answer the integer hash value of the receiver.  This
          is the default implementation which uses the object
          pointer as hash value."
     ^self asOop bitAnd: 16r3FFF!
 implementedBySubclass
         "Initiate a walkback because a subclass doesn't
          implement a message that it should."
     ^self error:
         'My subclass should have implemented this message'!
 inspect "Open an inspector window on the receiver."
     Inspector new openOn: self!
 instVarAt: anInteger
         "Private - Answer the instance variable in
          the receiver at index position anInteger.
          Both named and indexed instance variables
          are indexed."
     <primitive: 73>
     ^self primitiveFailed!
 instVarAt: anInteger put: anObject
         "Private - Answer anObject.  Replace the instance
          variable in the receiver at index position
          anInteger with anObject.  Both named and indexed
          instance variables are indexed."
     <primitive: 74>
     ^self primitiveFailed!
 invalidMessage
         "Private - Initiate walkback because inappropriate
          message was sent to the receiver."
     ^self error:
         'Inappropriate message for this object'!
 isKindOf: aClass
         "Answer true if receiver is an instance of aClass
          or one of its subclasses, else answer false."
     ^self class inheritsFrom: aClass!
 isMemberOf: aClass
         "Answer true if receiver is an instance
          of aClass, else answer false."
     ^self class == aClass!
 isNil
         "Answer true if the receiver is
          the object nil, else answer false."
     ^false!
 mustBeBoolean
         "Initiate a walkback describing that the receiver
          is not a Boolean."
     ^self error: 'receiver is not a Boolean'!
 notNil
         "Answer true if the receiver is not
          the object nil, else answer false."
     ^true!
 perform: aSymbol
         "Answer the result of sending a unary message to
          the receiver with selector aSymbol.  Report an
          error if the number of arguments expected by the
          selector is not zero."
     ^self perform: aSymbol withArguments: #()!
 perform: aSymbol with: anObject
         "Answer the result of sending a binary message to
          the receiver with selector aSymbol and argument
          anObject.  Report an error if the number of arguments
          expected by the selector is not one."
     ^self perform: aSymbol withArguments:
         (Array with: anObject)!
 perform: aSymbol with: firstObject with: secondObject
         "Answer the result of sending a keyword message to
          the receiver with selector aSymbol and arguments
          firstObject and secondObject.  Report an error if
          the number of arguments expected by the selector
          is not two."
     ^self perform: aSymbol withArguments:
         (Array
             with: firstObject
             with: secondObject)!
 perform: aSymbol with: firstObject with: secondObject with: thirdObject
         "Answer the result of sending a keyword message to
          the receiver with selector aSymbol and arguments
          firstObject, secondObject and thirdObject.  Report
          an error if the number of arguments expected by the
          selector is not three."
     ^self perform: aSymbol withArguments:
         (Array
             with: firstObject
             with: secondObject
             with: thirdObject)!
 perform: aSymbol withArguments: anArray
         "Answer the result of sending a message to the receiver
          with selector aSymbol and arguments the elements of
          anArray.  Report an error if the number of arguments
          expected by the selector is not equal to anArray size."
     | name |
     <primitive: 84>
     aSymbol class == Symbol
         ifFalse: [
             name := aSymbol class name.
             ^self error: 'perform: expects a Symbol, not ',
                 ((name at: 1) isVowel
                     ifTrue: ['an ' , name]
                     ifFalse: ['a ' , name])].
     ^self error:
         'perform: ' , self class name , ' ' , aSymbol ,
         ' did not expect ' , anArray size printString ,
         ' arguments'!
 primitiveFailed
         "Private - Initiate a walkback with label containing
          primitive failed message."
     ^self error: 'System primitive failed'!
 printOn: aStream
         "Append the ASCII representation of the receiver
          to aStream.  This is the default implementation which
          prints 'a' ('an') followed by the receiver class name."
     | classString |
     classString := self class name.
     (classString at: 1) isVowel
         ifTrue: [aStream nextPutAll: 'an ']
         ifFalse: [aStream nextPutAll: 'a '].
     aStream nextPutAll: classString!
 printRecursionOn: aStream
         "This is used while printing recursive data structures
          to print the first object detected in the cyclic
          structure."
     aStream
         nextPutAll: ' ...recursive reference to ';
         nextPutAll: self class name;
         nextPutAll: '... '!
 printString
         "Answer a String that is an ASCII representation
          of the receiver, using printOn:."
     | aStream aString |
     RecursiveSet := Set new.
     aString := String new: 20.
     self printOn: (aStream := WriteStream on: aString).
     ^aString copyFrom: 1 to: aStream position!
 release
         "Discard all dependents of the receiver, if any."
     Dependents removeKey: self ifAbsent: []!
 removeDependent: anObject
         "Remove anObject as a dependent of the receiver."
     | dependents |
     (dependents := Dependents at: self ifAbsent: [^self])
         remove: anObject.
     dependents isEmpty
         ifTrue: [Dependents removeKey: self]!
 respondsTo: aSymbol
         "Answer true if the receiver class or one of its
          superclasses implements a method with selector
          equal to aSymbol."
     ^self class canUnderstand: aSymbol!
 shallowCopy
         "Answer a copy of the receiver which shares
          the receiver instance variables."
     | copy class instanceVars |
     class := self class.
     class isVariable
         ifTrue: [
             instanceVars := self basicSize.
             copy := class new: instanceVars]
         ifFalse: [
             instanceVars := 0.
             copy := class new].
     class isPointers
         ifTrue: [
             1 to: instanceVars + class instSize do: [ :index |
                 copy instVarAt: index
                     put: (self instVarAt: index)]]
         ifFalse: [
             1 to: instanceVars do: [ :index |
                 copy basicAt: index
                     put: (self basicAt: index)]].
     ^copy!
 size
         "Answer the number of indexed instance variables
          in the receiver."
     <primitive: 62>
     ^self primitiveFailed!
 species
         "Answer a class which is similar to (or the same
          as) the receiver class which can be used for
          containing derived copies of the receiver."
     ^self class!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reinstantiated."
     | class noneYet |
     (RecursiveSet includes: self)
         ifTrue: [
             RecursiveSet := Set new.
             ^self error:
                 'recursive storeOn: not allowed in Object'].
     RecursiveSet add: self.
     class := self class.
     aStream
         nextPutAll: '((';
         nextPutAll: class name;
         nextPutAll: ' basicNew'.
     class isVariable
         ifTrue: [
             aStream nextPut: $:.
             self size printOn: aStream].
     aStream nextPut: $).
     noneYet := true.
     1 to: class instSize + self size do: [ :index |
         noneYet
             ifTrue: [noneYet := false].
         aStream nextPutAll: 'instVarAt:'.
         index printOn: aStream.
         aStream nextPutAll: ' put:'.
         (self instVarAt: index) storeOn: aStream.
         aStream nextPut: $;].
     noneYet
         ifFalse: [aStream nextPutAll: 'yourself'].
     aStream nextPut: $).
     RecursiveSet remove: self ifAbsent: []!
 storeString
         "Answer the receiver represented as a String
          from which it can be reconstructed."
     | aStream |
     aStream := WriteStream on: (String new: 16).
     self storeOn: aStream.
     ^aStream contents!
 update: aParameter
         "An object on whom the receiver is dependent
          has changed.  The receiver updates its status
          accordingly (the default behavior is to do nothing).
          The argument aParameter usually identifies the
          kind of update."!
 update: firstParameter with: secondParameter
         "An object on whom the receiver is dependent
          has changed.  The receiver updates its status
          accordingly (the default behavior is to do nothing).
          The argument firstParameter usually identifies the
          kind of update and the secondParameter is a unary
          message defined in the receiver protocol."!
 yourself
         "Answer the receiver."
     ^self!
 ~= anObject
         "Answer true if the receiver and anObject do
          not compare equal (using =), else answer false."
     ^(self = anObject) not!
 ~~ anObject
         "Answer true if the receiver and anObject are
          not the same object, else answer false."
     ^(self == anObject) not! !

! Behavior class methods !
 initialize
         "Private - Initialize the class variables
          that describe the structure masks and bits."
    "InstPointerBit := 16384 .
     InstWordBit    := 8192 .
     InstIndexedBit := 4096 .
     InstNumberMask  := 127"! !

! Behavior methods !
 addSelector: aSymbol withMethod: aCompiledMethod
         "Add aCompiledMethod to the receiver messageDictionary
          using aSymbol as the key.  If aSymbol is not
          a Symbol report an error."
     Symbol mustBeSymbol: aSymbol.
     messageDictionary at: aSymbol put: aCompiledMethod!
 addSubclass: aClass
         "Add aClass to the subclasses of the receiver.
          Make the the receiver the superclass of aClass."
     (self subclasses includes: aClass)
         ifTrue: [^self].
     self subclasses: (self subclasses copyWith: aClass).
     aClass superclass: self!
 allClasses
         "Answer a Set of all of the classes
          contained in Methods."
     | answer |
     answer := Set new.
     Methods associationsDo: [ :each |
         (each value isKindOf: Behavior)
             ifTrue: [
                 (each value name trimBlanks isEmpty)
                     ifFalse: [answer add: each value]]].
     ^answer!
 allClassVarNames
         "Answer a Set of strings of all of the class
          variable names defined in the receiver and
          its superclasses."
     | answer |
     answer := self classVarNames.
     self allSuperclasses do: [:each |
         answer addAll: each classVarNames].
     ^answer!
 allInstances
         "Answer an Array of all of
          the instances of the receiver."
     <primitive: 38>!
 allInstVarNames
         "Answer an Array of strings of all of the instance
          variable names defined in the receiver and
          its superclasses."
     | answer |
     answer := self instVarNames.
     self allSuperclasses do: [ :each |
         answer := each instVarNames , answer].
     ^answer!
 allSelectors
         "Answer a Set of all of the method selectors defined
          in the receiver and all of the receiver superclasses."
     | answer |
     answer := self selectors.
     self allSuperclasses do: [:each |
         answer addAll: each selectors].
     ^answer!
 allSharedPools
         "Answer a Set of names of all of the pool dictionaries
          referred to by the receiver and its superclasses."
     | answer |
     answer := self sharedPools.
     self allSuperclasses do: [ :each |
         answer addAll: each sharedPools].
     ^answer!
 allSubclasses
         "Answer an OrderedCollection of all the subclasses
          of the receiver in hierarchical
          order.  Classes at the same hierarchical level are sorted
          alphabetically."
     | answer sortedSubclasses |
     answer := OrderedCollection new.
     sortedSubclasses := SortedCollection
         sortBlock: Class sortBlock.
     sortedSubclasses addAll: self subclasses.
     sortedSubclasses do: [ :each |
         answer
             add: each;
             addAll: each allSubclasses].
     ^answer!
 allSuperclasses
         "Answer an OrderedCollection of all the superclasses
          of the receiver.  The superclasses are in inverse
          hierarchical order, i.e class Object is last."
     | answer aSuperclass|
     answer := OrderedCollection new.
     aSuperclass := superClass.
     [aSuperclass isNil] whileFalse: [
         answer addLast: aSuperclass.
         aSuperclass := aSuperclass superclass].
     ^answer!
 basicNew
         "Answer an instance of the receiver.  If the receiver is
          indexable, then allocate zero indexed instance
          variables.  This method should never be reimplemented
          in any subclass of Behavior since it is the primitive
          object allocation message."
     <primitive: 70>
     self isVariable
         ifTrue: [^self basicNew: 0].
     ^self primitiveFailed!
 basicNew: anInteger
         "Answer an instance of the receiver.  Allocate anInteger
          number of indexed instance variables.  If the receiver
          does not have indexed instance variables an error is
          reported.  This method should never be reimplemented
          in any subclass of Behavior since it is the primitive
          object allocation message."
     <primitive: 71>
     self isFixed
         ifTrue: [^self errorNotIndexable].
     ^self primitiveFailed!
 canUnderstand: aSymbol
         "Answer true if the receiver or any of the receiver
          superclasses implement the method named aSymbol, else
          answer false."
     (messageDictionary includesKey: aSymbol)
         ifTrue: [^true].
     self allSuperclasses
         detect: [ :each | each includesSelector: aSymbol]
         ifNone: [^false].
     ^true!
 classVariableString
         "Answer a String of all the class variable names
          defined by the receiver.  The names are separated
          with blanks."
      | answer |
      answer := String new.
      self classVarNames do: [ :each |
          answer := answer , each , (String with: $ )].
      ^answer!
 compile: codeString
         "Compile the Smalltalk method contained in codeString.
          The class to use for resolving variables is the receiver.
          If there are no errors, add the method to the receiver
          messageDictionary and answer the Association with the
          message selector as the key and the compiled method
          as the value.  If there is an error, answer nil."
     | answer |
     answer := Compiler
         compile: codeString
         in: self.
     answer notNil
         ifTrue: [
             self
                 addSelector: answer key
                 withMethod: answer value].
     ^answer!
 compile: codeString notifying: requestor
         "Compile the Smalltalk method contained in codeString.
          The class to use for resolving variables is the receiver.
          If there are no errors, add the method to the recevier
          messageDictionary and answer the Association with the
          message selector as the key and the compiled method
          as the value.  If there is an error the requestor is sent
          a message by the compiler identitfying the error and
          this method answers nil."
     | answer |
     answer := Compiler
         compile: codeString
         in: self
         notifying: requestor
         ifFail: [^nil].
     self addSelector: answer key withMethod: answer value.
     ^answer!
 compileAll
         "Recompile all the methods defined in the receiver.
          If any methods are recompiled, display a message
          on the Transcript."
     messageDictionary isEmpty
         ifTrue: [^self].
     Transcript
         cr;
         show: 'recompile ', self name.
     self selectors do: [ :each |
         self recompile: each]!
 compileAllSubclasses
         "Recompile all the methods defined in the receiver
          or in any subclass of the receiver."
     | className |
     self allSubclasses do: [:each |
         className := each name trimBlanks.
         (className isEmpty or: [className = 'class'])
             ifFalse: [each compileAll]]!
 compiledMethodAt: aSymbol
         "Answer the compiled code of the method
          named aSymbol defined in the receiver."
     ^messageDictionary at: aSymbol ifAbsent: [^nil]!
 computeInstSize
         "Private - Compute the number of named instance variables
          for instances of the receiver and adjust the receiver
          structure instance variable accordingly.  The number is
          based on the instances array and the instance variables
          defined by the receiver superclass."
     | superSize |
     superClass == nil
         ifTrue: [superSize := 0]
         ifFalse:[superSize := superClass instSize].
     self structure:
         self structure - self instSize
         + superSize + instances size!
 copy: aSymbol from: aClass
         "Retrieve the source code for the method named
          aSymbol in aClass and compile it in the receiver."
     | answer source |
     source := aClass sourceCodeAt: aSymbol.
     answer := self compile: source.
     answer == nil
         ifFalse: [
             Methods
                 logSource: source
                 forSelector: aSymbol
                 inClass: self]!
 copyAll: arrayOfSymbols from: aClass
         "Retrieve the source for each method name contained
          in arrayOfSymbols from aClass and compile them
          in the receiver."
     arrayOfSymbols do: [:each |
         self copy: each from: aClass]!
 deepCopy
         "Answer a copy of the receiver with shallow
          copies of each instance variable.  Because
          classes are unique (cannot be copied),
          answer the receiver."
     ^self!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner."
     messageDictionary do: [ :method |
         aCloner cloneOopFor: method].
     super dumpOn: aStream for: aCloner!
 errorNotIndexable
         "Somebody is trying to make an instance of the
          receiver with indexed instance variables and the
          receiver is not indexable.  Produce a walkback
          window explaining the problem."
     self error:
         name, 's do not have indexed instance variables'!
 includesSelector: aSymbol
         "Answer true if the message dictionary of the
          receiver includes a method of name aSymbol,
          else answer false."
     ^messageDictionary includesKey: aSymbol!
 inheritsFrom: aClass
         "Answer true if receiver can inherit methods
          from aClass, else answer false."
     | class |
     class := self.
     [class == nil] whileFalse: [
         (class == aClass)
             ifTrue: [^true].
         class := class superclass].
     ^false!
 instanceVariableString
         "Answer a String containing all the instance variable
          names defined by the receiver.  The names are separated
          with spaces."
     | aStream |
     aStream := WriteStream on: (String new: 16).
     self instVarNames do: [ :each |
         aStream
             nextPutAll: each;
             space].
     ^aStream contents!
 instSize
         "Answer the number of named instance variables
          contained in instances of the receiver."
     ^self isPointers
         ifFalse: [0]
         ifTrue: [
             structure + 16r10000 bitAnd: InstNumberMask]!
 instVarNames
         "Answer the array of instance variable
          names defined by the receiver."
     instances isNil
         ifTrue: [instances := Array new: 0].
     ^instances!
 instVarNames: instNameString
         "Private - The string instNameString contains a new list
          of instance variable names separated with blanks.  Use
          this list to replace the instances array with the new
          names.  Recompute the number of named instance variables
          for instances of the receiver and instances of all the
          subclasses of the receiver."
     | array |
     array := instNameString asArrayOfSubstrings.
     instances := array.
     self computeInstSize.
     self allSubclasses do: [ :c | c computeInstSize]!
 isBits
         "Answer true if instances of the receiver contain
          8 or 16 bit values instead of object pointers,
          else answer false."
     ^self isPointers not!
 isBytes
         "Answer true if instances of the receiver contain
          8 bit byte values, else answer false."
     ^self isWords not!
 isFixed
         "Answer true if instances of the receiver do not
          contain indexed instance variables, else
          answer false."
     ^(self structure bitAnd: InstIndexedBit) = 0!
 isPointers
         "Answer true if instances of the receiver contain object
          pointers instead of 8 or 16 bit values, else
          answer false."
     ^structure < 0!
 isVariable
         "Answer true if instances of the receiver contain
          indexed instance variables, else answer false."
     ^self isFixed not!
 isWords
         "Answer true if instances of the receiver contain
          16 bit word values, else answer false."
     ^(self structure bitAnd: InstWordBit) > 0!
 kindOfSubclass
         "Answer a string describing the receiver type.
          The choices are: 'subclass:', 'variableSubclass:',
          'variableByteSubclass:', and 'variableWordSubclass:'."
     self isFixed    ifTrue:[^'subclass:'].
     self isBytes    ifTrue:[^'variableByteSubclass:'].
     self isPointers ifTrue:[^'variableSubclass:'].
     self isWords    ifTrue:[^'variableWordSubclass:'].
     self error: 'unknown kind of class'!
 methodDictionary
         "Answer the dictionary of methods
          defined in the receiver."
     ^messageDictionary!
 methodDictionary: aMethodDictionary
         "Private - Change the receiver dictionary
          of methods to be aMethodDictionary."
     (aMethodDictionary isKindOf: MethodDictionary)
         ifFalse: [^self error: 'must be a Method Dictionary'].
     messageDictionary := aMethodDictionary!
 methods
         "Answer an instance of ClassReader
          initialized for the receiver."
     ^ClassReader forClass: self!
 new
         "Answer an instance of the receiver.  If the receiver is
          indexable, then allocate zero indexed instance
          variables.  This method is frequently reimplemented
          as a class message in classes that need special
          initialization of their instances."
     <primitive: 70>
     self isVariable
         ifTrue: [^self new: 0].
     ^self primitiveFailed!
 new: anInteger
         "Answer an instance of the receiver.  Allocate anInteger
          number of indexed instance variables.  If the receiver
          does not have indexed instance variables an error is
          reported.  This method is frequently reimplemented
          as a class message in classes that need special
          initialization of their instances."
     <primitive: 71>
     self isFixed
         ifTrue: [^self errorNotIndexable].
     ^self primitiveFailed!
 newNameSymbol: aSymbol
         "Private - Change the name of the receiver to be aSymbol."
     Symbol mustBeSymbol: aSymbol.
     name := aSymbol!
 printOn: aStream
         "Print the name of the receiver on aStream."
     aStream nextPutAll: self name.!
 recompile: aSymbol
         "Recompile the method named aSymbol
          defined in the receiver."
     | result method index position |
     method := self compiledMethodAt: aSymbol.
     index := method sourceIndex.
     position := method sourcePosition.
     result := Compiler
         compile: (self sourceCodeAt: aSymbol)
         in: self.
     result == nil
         ifTrue: [^self]
         ifFalse: [
             result key == aSymbol
                 ifFalse: [
                     self error:
                         'Lost Source code for ', aSymbol].
             self
                 addSelector: aSymbol
                 withMethod: result value].
     method := result value.
     index notNil
         ifTrue: [
             method
                 sourceIndex: index
                 sourcePosition: position]!
 removeSelector: aSymbol
         "Remove the method named aSymbol from
          the methods defined in the receiver."
     messageDictionary
         removeKey: aSymbol
         ifAbsent: []!
 removeSubclass: aClass
         "Private - Remove aClass as a subclass of the receiver."
     self subclasses:
         (self subclasses asSet
             remove: aClass;
             yourself)!
 selectorFor: aCompiledMethod
         "Answer an Association containing the name of
          aCompiledMethod and the class in which it is
          implemented that will be used by instances of
          the receiver.  The association key is the name
          of the method and the association value is the
          class in which it is defined.  Answer nil if
          implementation of aCompiledMethod is not found."
     | aClass aSymbol |
     aClass := self.
     [aClass == nil]
         whileFalse: [
             aSymbol := aClass methodDictionary
                 keyAtValue: aCompiledMethod.
             aSymbol == nil
                 ifFalse: [
                     ^Association key: aSymbol value: aClass].
             aClass := aClass superclass].
     ^nil!
 selectors
         "Answer a Set of symbols of the names
          of the methods defined by the receiver."
     ^messageDictionary keys!
 shallowCopy
         "Answer a copy of the receiver which shares
          the receiver instance variables.  Because
          classes are unique (cannot be copied),
          answer the receiver."
     ^self!
 sharedVariableString
         "Answer a String containing all of the pool dictionary
          names referred to by the receiver.  The names are
          spearated with blanks."
     | aStream |
     aStream := WriteStream on: (String new: 16).
     self sharedPools do: [ :each |
         aStream
             nextPutAll: each;
             space].
     ^aStream contents!
 sourceCodeAt: aSymbol
         "Answer a String of the source code for the method
          named sSymbol in the receiver."
     | method source |
     method := self compiledMethodAt: aSymbol.
     method isNil
         ifTrue: [^aSymbol]
         ifFalse:[
             (method isKindOf: CompiledMethod)
                 ifTrue: [
                     source := method sourceString.
                     source == nil
                         ifTrue: [^aSymbol, ' can''t access source code']
                         ifFalse:[^source]]
                 ifFalse:[^aSymbol, ' can''t access source code']].!
 structure
         "Answer the integer that describes the structure
          of instances of the receiver.  Refer to the
          class variables of Behavior for a definition
          of this integer."
     ^structure + 16r10000 bitAnd: 16r7FFF!
 structure: anInteger
         "Private - Change the structure that new instances
          of the receiver will have.  The new structure is
          defined by anInteger.  Refer to the class variables
          of Behavior for a description of this integer."
     structure :=
         (anInteger < 16r4000
             ifTrue: [anInteger]
             ifFalse: [anInteger - 16r8000])!
 subclasses
         "Answer the array of subclasses of the receiver."
     subclasses == nil
         ifTrue: [^Array new]
         ifFalse: [^subclasses]!
 subclasses: aCollection
         "Private - Change the subclasses of the receiver
          to be the classes in aCollection."
     aCollection isEmpty
         ifTrue: [subclasses := nil]
         ifFalse:[subclasses := aCollection asArray]!
 subclassInstVarNames
         "Answer a Set of all of the named instance variables
          defined by the subclasses of the receiver."
     |aSet|
     aSet := Set new.
     self allSubclasses do: [:each |
         aSet addAll: each instVarNames].
     ^aSet!
 superclass
         "Answer the superclass of the receiver."
     ^superClass!
 superclass: aClass
         "Private - Change the superclass of the receiver
          to aClass."
     superClass := aClass!
 symbol
         "Private - Answer the symbol for
          the class name of the receiver."
     ^name!
 whichClassIncludesSelector: aSymbol
         "Answer the receiver or its superclass
          which defines the method named aSymbol.
          If no such class is found answer nil."
     (messageDictionary includesKey: aSymbol)
         ifTrue: [^self].
     ^self allSuperclasses
         detect: [ :each | each includesSelector: aSymbol]
         ifNone: [nil]!
 withAllSubclasses
         "Answer an OrderedCollection of the recevier and
          all of its subclasses in hierarchical
          order."
     | classes |
     classes := OrderedCollection with: self.
     self allSubclasses do: [ :each |
         each name trimBlanks isEmpty
             ifFalse: [classes add: each]].
     ^classes! !

! Class class methods !
 sortBlock
         "Answer a sort block for sorting
          classes alphabetically."
     ^[ :a :b | a symbol <= b symbol ]! !

! Class methods !
 addClassVarName: aString
         "Add a new class variable named aString to the receiver."
     (aString at: 1) isUpperCase
         ifFalse: [self error: 'class variable names must begin with uppercase'].
     (self allClassVarNames includes: aString)
         ifTrue: [self error: 'class variable already exists'].
     self classPool at: aString put: nil!
 addSharedPool: aSymbol
         "Add the shared pool named aSymbol to
          the receiver shared pool references."
     (self sharedPools includes: aSymbol)
         ifTrue: [
             self error:
                 'class already contains pool: ',
                 aSymbol].
     (Methods includesKey: aSymbol)
         ifFalse: [
             self error:
                 'Pool Dictionary ',
                 aSymbol, ' not defined'].
     sharedPools := sharedPools,
         (Array with: aSymbol)!
 classPool
         "Answer the pool dictionary of the class
          variables defined in the receiver."
     classPool isNil
         ifTrue: [classPool := Dictionary new].
     ^classPool!
 classVarNames
         "Answer a Set of class variable
          names defined in the receiver."
     ^self classPool keys!
 classVarNames: classVarString
         "Change the class variables defined in the receiver
          to be the names contained in classVarString."
     | aSet |
     aSet := classVarString asArrayOfSubstrings asSet.
     (self classPool keys reject: [ :n | aSet includes: n])
         do: [:classVar| self removeClassVarName: classVar].
     (aSet reject: [ :n | self classPool includesKey: n])
         do: [:classVar| self addClassVarName: classVar]!
 edit
         "Open a ClassBrowser window on the receiver."
     ClassBrowser new openOn: self!
 fileOutOn: aStream
         "Append the class definition message
          for the receiver to aStream."
     | string |
     aStream cr;
         nextPutAll: superClass printString; space;
         nextPutAll: self kindOfSubclass; space;
         nextPutAll: name storeString; cr; space; space.
     self isBits
         ifFalse: [
             aStream nextPutAll: 'instanceVariableNames: '.
             (string := self instanceVariableString) isEmpty
                 ifFalse:[aStream cr; nextPutAll: '    '].
             aStream
                 nextPutAll: string storeString;
                 cr; space; space].
     aStream
         nextPutAll: 'classVariableNames: '.
     (string := self classVariableString) isEmpty
         ifFalse:[aStream cr; nextPutAll: '    '].
     aStream
         nextPutAll: string storeString; cr; space; space;
         nextPutAll: 'poolDictionaries: '.
     (string := self sharedVariableString) isEmpty
         ifFalse:[aStream cr; nextPutAll: '    '].
     aStream
         nextPutAll: string storeString!
 initialize
         "Initialize the class variables defined in the receiver.
          Subclasses usually override this message.  The default
          is to set all class variables to nil."
     classPool associationsDo: [:each | each value: nil]!
 initializeClass
         "Private - Initialize the instance
          variables of the receiver to describe
          a default class with no methods or instance
          variables."
     messageDictionary := MethodDictionary newSize:2.
     self structure: (superClass == nil
         ifTrue: [Object structure]
         ifFalse:[superClass structure]).
     instances := Array new: 0.
     classPool := Dictionary new: 0.
     sharedPools := Array new:0!
 name
         "Answer a String containing the receiver name."
     ^name asString!
 pointer: pointerBoolean
     word: wordBoolean
     variable: variableBoolean
 
         "Private - Construct the instance structure specification
          integer as defined by the arguments.  Adjust the subclasses
          of the receiver as required."
     | spec |
     pointerBoolean
         ifFalse: [
             self allSubclasses do: [ :c |
                c isPointers
                     ifTrue: [^self error: 'Has pointer subclasses']]].
     spec := 0.
     variableBoolean
         ifTrue: [spec := spec + InstIndexedBit].
     wordBoolean
         ifTrue: [spec := spec + InstWordBit].
     pointerBoolean
         ifTrue: [spec := spec + InstPointerBit].
     self structure: spec + self instSize.
     variableBoolean ifTrue:
         [self allSubclasses do: [ :c |
             c structure:
                 (c structure bitOr: InstIndexedBit)]]!
 removeClassVarName: aString
         "Private - Remove the class variable
          named aString from the receiver."
     (self classPool includesKey: aString)
         ifFalse: [
             self error: aString, ' not a class variable'].
     self classPool removeKey: aString!
 removeFromSystem
         "Remove the receiver from Methods.  Report
          an error if there are any subclasses or
          instances of the receiver."
     self allInstances notEmpty ifTrue:
         [^self error: 'Has instances'].
     self allSubclasses notEmpty ifTrue:
         [^self error: 'Has subclasses'].
     superClass == nil ifFalse:
         [superClass removeSubclass: self].
     self class superclass == nil ifFalse:
         [self class superclass
              removeSubclass: self class].
     Methods removeKey: name ifAbsent: []!
 removeSharedPool: aSymbol
         "Private - Remove the reference in the receiver to
          the shared pool dictionary named aSymbol."
     (self sharedPools includes: aSymbol)
         ifFalse: [
             self error:
                 'shared pool: ', aSymbol, ' not defined'].
     sharedPools := sharedPools copyWithout: aSymbol!
 rename: aString
         "Rename the receiver to aString."
     self rename: aString in: Methods!
 rename: aString in: aSystemDictionary
         "Private - Rename the receiver to
          aString in the environment aSystemDictionary."
     | newName association |
     newName := aString asSymbol.
     (aSystemDictionary includesKey: newName)
         ifTrue: [
             ^self error: 'can''t rename to existing name'].
     name == nil
         ifTrue: [
             association := Association
                 key: newName
                 value: self]
         ifFalse: [
             association := aSystemDictionary
                 associationAt: name.
             aSystemDictionary removeKey: name ifAbsent: [].
             association key: newName].
     aSystemDictionary add: association.
     self newNameSymbol: newName.
     self class newNameSymbol: newName!
 sharedPools
         "Answer an Array of symbols of pool dictionary names
          referred to by the recevier."
     sharedPools isNil
         ifTrue: [sharedPools := Array new].
     ^sharedPools asSet!
 sharedPools: poolNameString
         "Private - Change the shared pool dictionaries referred to by the
          receiver to the ones named in poolNameString."
     | aSet |
     aSet := poolNameString asArrayOfSubstrings asSet.
     aSet := aSet collect: [ :n | n asSymbol].
     (self sharedPools reject: [ :n | aSet includes: n])
         do: [ :pool | self removeSharedPool: pool].
     (aSet reject: [ :n | self sharedPools includes: n])
         do: [ :pool | self addSharedPool: pool]!
 subclass: classSymbol
     instanceVariableNames: instanceVariables
     classVariableNames: classVariables
     poolDictionaries: poolDictNames
 
         "Create or modify the class classSymbol to be
          a subclass of the receiver with the specifed
          instance variables, class variables, and pool
          dictionaries."
     | meta variableBoolean |
     self isBits
         ifTrue: [^self error: 'Superclass is non-pointers'].
     meta := MetaClass subclassOf: self.
     ^meta
         name: classSymbol
         environment: Methods
         subclassOf: self
         instanceVariableNames: instanceVariables
         variable: self isVariable
         words: true
         pointers: true
         classVariableNames: classVariables
         poolDictionaries: poolDictNames
         comment: String new
         changed: nil!
 variableByteSubclass: classSymbol
     classVariableNames: classVariables
     poolDictionaries: poolDictNames
 
         "Create or modify the class classSymbol to be
          a variableByteSubclass of the receiver with the
          specified class variables and pool dictionaries."
     | meta |
     self instSize == 0
         ifFalse: [^self error: 'Superclass has pointers'].
     (self isBits and: [self isWords])
         ifTrue: [self error: 'Superclass is words'].
     meta := MetaClass subclassOf: self.
     ^meta
         name: classSymbol
         environment: Methods
         subclassOf: self
         instanceVariableNames: String new
         variable: true
         words: false
         pointers: false
         classVariableNames: classVariables
         poolDictionaries: poolDictNames
         comment: String new
         changed: nil!
 variableSubclass: classSymbol
     instanceVariableNames: instanceVariables
     classVariableNames: classVariables
     poolDictionaries: poolDictNames
 
         "Create or modify the class classSymbol to be a
          variableSubclass of the receiver with the specifed
          instance variables, class variables, and pool dictionaries."
     | meta |
     self isBits
         ifTrue: [^self error: 'Superclass is non-pointers'].
     meta := MetaClass subclassOf: self.
     ^meta
         name: classSymbol
         environment: Methods
         subclassOf: self
         instanceVariableNames: instanceVariables
         variable: true
         words: true
         pointers: true
         classVariableNames: classVariables
         poolDictionaries: poolDictNames
         comment: String new
         changed: nil!
 variableWordSubclass: classSymbol
     classVariableNames: classVariables
     poolDictionaries: poolDictNames
 
         "Create or modify the class classSymbol to be
          a variableWordSubclass of the receiver with
          the specified class variables and pool dictionaries."
     | meta |
     self instSize == 0
         ifFalse: [^self error: 'Superclass has pointers'].
     (self isBits and: [self isBytes])
         ifTrue: [self error: 'Superclass is bytes'].
     meta := MetaClass subclassOf: self.
     ^meta
         name: classSymbol
         environment: Methods
         subclassOf: self
         instanceVariableNames: String new
         variable: true
         words: true
         pointers: false
         classVariableNames: classVariables
         poolDictionaries: poolDictNames
         comment: String new
         changed: nil! !

! MetaClass class methods !
 new
         "Private - Answer a new metaclass that is partially
          initialized with an empty message dictionary and
          a default structure."
     ^super new
         structure: Class structure;
         methodDictionary: (MethodDictionary newSize: 2);
         yourself!
 subclassOf: aClass
         "Private - Answer a new metaclass that is
          a subclass of the metaclass for aClass."
     | newMeta |
     newMeta := self new.
     newMeta superclass:
         (aClass == Class
             ifTrue: [Class]
             ifFalse: [aClass class]).
     ^newMeta! !

! MetaClass methods !
 classPool
         "Answer the pool dictionary of
          the only instance (a class) of the
          receiver (a metaclass)."
     ^self instanceClass classPool!
 classVarNames
         "Answer a Set of the class variable
          names defined in the only instance
          of the receiver."
     ^self instanceClass classVarNames!
 instanceClass
         "Answer the instance of the receiver."
     name == nil
         ifTrue: [
             ^self error: 'metaclass does not have instance']
         ifFalse:[^Methods at: name]!
 name
         "Answer a String containing the receiver name."
     | aString |
     aString := String new: name size + 6.
     aString
         replaceFrom: 1
         to: name size
         with: name.
     ^aString
         replaceFrom: name size + 1
         to: name size + 6
         with: ' class'!
 name: newName
     environment: aSystemDictionary
     subclassOf: superclass
     instanceVariableNames: stringOfInstVarNames
     variable: variableBoolean
     words: wordBoolean
     pointers: pointerBoolean
     classVariableNames: stringOfClassVarNames
     poolDictionaries: stringOfPoolNames
     comment: commentString
     changed: changed
 
         "Private - Create or modify the class and the metaclass
          of name newName to be as defined by the arguments."
     | newClass stream newSymbol |
     (newName at: 1) isUpperCase
         ifTrue: [newSymbol := newName]
         ifFalse: [
             newSymbol := ((String with: (newName at: 1) asUpperCase),
                 (newName copyFrom: 2 to: newName size)) asSymbol].
     (aSystemDictionary includesKey: newSymbol)
     ifTrue: [
         newClass := aSystemDictionary at: newSymbol.
         (newClass isKindOf: Class)
             ifFalse: [
                 ^self error: newSymbol, ' is not a Class'].
         newClass superclass == superclass
             ifFalse: [
                 ^self error: 'Cannot change superclass'].
         newClass instVarNames size >
             stringOfInstVarNames asArrayOfSubstrings size
                 ifTrue: [
                     newClass allInstances notEmpty
                         ifTrue: [^self error: 'Has instances']]]
     ifFalse: [
         newClass := self new.
         superclass addSubclass: newClass.
         self superclass addSubclass: self.
         newClass
             initializeClass;
             rename: newSymbol in: aSystemDictionary].
     newClass
         pointer: pointerBoolean word: wordBoolean
             variable: variableBoolean;
         instVarNames: stringOfInstVarNames;
         classVarNames: stringOfClassVarNames;
         sharedPools: stringOfPoolNames.
     stream := WriteStream on: (String new: 64).
     newClass fileOutOn: stream.
     Methods
         logSource: stream contents forClass: newClass.
     newClass compileAll.
     newClass class compileAll.
     newClass allSubclasses do: [ :c |
         c compileAll.
         c class compileAll].
     ^newClass!
 newNameSymbol: aSymbol
         "Private - Change the name of
          the receiver to be aSymbol."
     name := aSymbol!
 sharedPools
         "Answer an Array of shared pool name symbols
          referred to by the only instance of the receiver."
     ^self instanceClass sharedPools! !

! Boolean class methods !
 new
         "Disallow the instantiation of booleans because
          there is only one true and one false."
     ^self invalidMessage!
 new: anInteger
         "Disallow the instantiation of booleans
          because there is only one true and one false."
     ^self invalidMessage! !

! Boolean methods !
 deepCopy
         "Answer a copy of the receiver with shallow
          copies of each instance variable.  Because
          there is only one true and  one false,
          answer the receiver."
     ^self!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     aStream nextPutAll:
         (self
             ifTrue: ['true']
             ifFalse:['false'])!
 shallowCopy
         "Answer a copy of the receiver which shares
          the receiver instance variables.  Because
          there is only one true and one false, answer
          the receiver."
     ^self!
 storeOn: aStream
         "Answer the receiver.  Append the character
          sequence of the receiver to aStream from
          which the receiver can be reconstructed."
     self printOn: aStream! !

! False class methods ! !

! False methods !
 & aBoolean
         "Answer true if both the receiver and
          aBoolean are true, else answer false."
     ^false!
 and: aBlock
         "If the receiver is true, answer the result of
          evaluating aBlock (with no aruguments), else
          answer false."
     ^false!
 eqv: aBoolean
         "Answer true if the receiver is equivalent
          to aBoolean, else answer false."
     ^aBoolean not!
 ifFalse: falseBlock
         "If the receiver is true, answer the result of
          evaluating falseBlock (with no arguments), else
          answer nil."
     ^falseBlock value!
 ifFalse: falseBlock ifTrue: trueBlock
         "If the receiver is true, answer the result of
          evaluating trueBlock, else answer the result
          of evaluating falseBlock.  Both blocks are
          evaluated with no arguments."
     ^falseBlock value!
 ifTrue: trueBlock
         "If the receiver is true, answer the result of
          evaluating trueBlock (with no arguments), else
          answer nil."
     ^nil!
 ifTrue: trueBlock ifFalse: falseBlock
         "If the receiver is true, answer the result of
          evaluating trueBlock, else answer the result
          of evaluating falseBlock.  Both block are
          evaluated with no arguments."
     ^falseBlock value!
 not
         "Answer true if the receiver is false,
          else answer false."
     ^true!
 or: aBlock
         "If the receiver is false, answer the result of
          evaluating aBlock (with no arguments), else
          answer true."
     ^aBlock value!
 xor: aBoolean
         "Answer true if the receiver is not equivalent
          to aBoolean, else answer false."
     ^aBoolean!
 | aBoolean
         "Answer true if either the receiver or aBoolean
          are true, else answer false."
     ^aBoolean! !

! True class methods ! !

! True methods !
 & aBoolean
         "Answer true if both the receiver and
          aBoolean are true, else answer false."
     ^aBoolean!
 and: aBlock
         "If the receiver is true, answer the result of
          evaluating aBlock (with no arguments), else
          answer false."
     ^aBlock value!
 eqv: aBoolean
         "Answer true if the receiver is equivalent
          to aBoolean, else answer false."
     ^aBoolean!
 ifFalse: falseBlock
         "If the receiver is false, answer the result of
          evaluating falseBlock (with no arguments), else
          answer nil."
     ^nil!
 ifFalse: falseBlock ifTrue: trueBlock
         "If the receiver is true, answer the result of
          evaluating trueBlock, else answer the result
          of evaluating falseBlock.  Both blocks are
          evaluated with no arguments."
     ^trueBlock value!
 ifTrue: trueBlock
         "If the receiver is true, answer the result of
          evaluating trueBlock (with no arguments), else
          answer nil."
     ^trueBlock value!
 ifTrue: trueBlock ifFalse: falseBlock
         "If the receiver is true, answer the result of
          evaluating trueBlock, else answer the result
          of evaluating falseBlock.  Both block are
          evaluated with no arguments."
     ^trueBlock value!
 not
         "Answer true if the receiver is false,
          else answer false."
     ^false!
 or: aBlock
         "If the receiver is false, answer the result of
          evaluating aBlock, else answer true."
     ^true!
 xor: aBoolean
         "Answer true if the receiver is not equivalent
          to aBoolean, else false."
     ^aBoolean not!
 | aBoolean
         "Answer true if either the receiver or aBoolean
          are true, else answer false."
     ^true! !

! ByteBlt class methods !
 destForm: destination
     sourceForm: source
     halftone: halftone
     combinationRule: rule
     destOrigin: destOrigin
     sourceOrigin: sourceOrigin
     extent: extent
     clipRect: clipRect
         "Answer a new instance of ByteBlt with
          instance variables initialized to the
          input arguments. Refer to the instance
          method with the same selector as this one
          for more detailed description of arguments."
     ^self new
         destForm: destination
         sourceForm: source
         halftone: halftone
         combinationRule: rule
         destOrigin: destOrigin
         sourceOrigin: sourceOrigin
         extent: extent
         clipRect: clipRect!
 displayByteBlt
         "Answer an initialized ByteBlt for writing
          to the display screen."
     ^self new
         destForm: Display
         sourceForm: nil
         halftone: nil
         combinationRule: Form over
         destOrigin: 0 @ 0
         sourceOrigin: 0 @ 0
         extent: Display extent
         clipRect: Display boundingBox! !

! ByteBlt methods !
 clipHeight: anInteger
         "Change the clipping rectangle height
          clipHeight to anInteger."
     clipHeight := anInteger!
 clipRect
         "Answer the clipping rectangle."
     ^clipX @ clipY extent:
         clipWidth @ clipHeight!
 clipRect: aRectangle
         "Set the clipping rectangle to aRectangle."
     clipX := aRectangle left.
     clipY := aRectangle top.
     clipWidth := aRectangle width.
     clipHeight := aRectangle height!
 clipWidth: anInteger
         "Change the clipping rectangle
          width to anInteger."
     clipWidth := anInteger!
 clipX: anInteger
         "Change the x-coordinate of the clipping
          rectangle origin to anInteger."
     clipX := anInteger!
 clipY: anInteger
         "Change the y-coordinate of the clipping
          rectangle origin to anInteger."
     clipY := anInteger!
 combinationRule: anInteger
         "Change the combination rule to anInteger."
     rule := anInteger!
 copyBytes
         "Transfer bytes from the source DisplayObject
          to the destination Form as described by the
          receiver ByteBlt."
     <primitive: 115>
     ^self primitiveFailed!
 destForm: aForm
         "Change the destination form to aForm."
     destForm := aForm!
 destForm: destination
     sourceForm: source
     halftone: maskInteger
     combinationRule: ruleInteger
     destOrigin: destPoint
     sourceOrigin: sourcePoint
     extent: extentPoint
     clipRect: clipRect
         "Copy the arguments to the receiver ByteBlt
          instance variables in preparation for a
          copyBytes message."
     destForm := destination.
     sourceForm := source.
     halftone := maskInteger isNil
         ifTrue:[0] ifFalse:[maskInteger].
     rule := ruleInteger.
     destX := destPoint x.
     destY :=destPoint y.
     sourceX := sourcePoint x.
     sourceY := sourcePoint y.
     width := extentPoint x.
     height := extentPoint y.
     clipX := clipRect left.
     clipY := clipRect top.
     clipWidth := clipRect width.
     clipHeight := clipRect height!
 destOrigin: aPoint
         "Set the origin of the destination
          rectangle to aPoint."
     destX := aPoint x.
     destY := aPoint y!
 destRect: aRectangle
         "Change the destination rectangle to
          aRectangle."
     destX := aRectangle left.
     destY := aRectangle top.
     width := aRectangle width.
     height := aRectangle height!
 destX
         "Answer the x-coordinate of the
          destination rectangle origin."
     ^destX!
 destX: anInteger
         "Change the x-coordinate of the
          destination rectangle origin
          to anInteger."
     destX := anInteger!
 destY
         "Answer the y-coordinate of the
          destination rectangle origin."
     ^destY!
 destY: anInteger
         "Change the y-coordinate of the
          destination rectangle origin
          to anInteger."
     destY := anInteger!
 height: anInteger
         "Change the height of the rectangular
          area to be transferred to anInteger."
     height := anInteger!
 mask: anInteger
         "Change the halftone mask to anInteger."
     halftone := anInteger!
 sourceForm: aDisplayObject
         "Change the source DisplayObject
          to aDisplayObject."
     sourceForm := aDisplayObject!
 sourceOrigin: aPoint
         "Change the origin of the source
          rectangle to aPoint."
     sourceX := aPoint x.
     sourceY := aPoint y!
 sourceRect: aRectangle
         "Change the source rectangle to
          aRectangle."
     sourceX := aRectangle left.
     sourceY := aRectangle top.
     width := aRectangle width.
     height := aRectangle height!
 sourceX: anInteger
         "Change the x-coordinate of the source
          rectangle origin to anInteger."
     sourceX := anInteger!
 sourceY: anInteger
         "Change the y-coordinate of the source
          rectangle origin to anInteger."
     sourceY := anInteger!
 width: anInteger
         "Change the width of the rectangular
          area to be transferred to anInteger."
     width := anInteger! !

! StringBlt class methods !
 initialize
         "Private - Initialize the class variable
          StringSource to be an empty DisplayString."
     StringSource := DisplayString new! !

! StringBlt methods !
 blank: aRectangle
        "Blank aRectangle of the intermediate form."
     sourceForm := InfiniteForm blank.
     width := aRectangle width.
     height := aRectangle height.
     destX := aRectangle origin x + clipOrigin x.
     destY := aRectangle origin y + clipOrigin y.
     halftone := paneColor.
     self copyBytes!
 bold: aRectangle
         "Bold the text in aRectangle of the intermediate form."
     sourceForm := nil.
     width := aRectangle width.
     height := aRectangle height.
     destX := aRectangle origin x + clipOrigin x.
     destY := aRectangle origin y + clipOrigin y.
     halftone := boldMask.
     self copyBytes!
 deactivate: aRectangle
         "Highlight aRectangle as it should be
          when window is deactivated."
     aRectangle isNil
         ifFalse: [
             (paneColor bitAnd: 16r70) = (White * 16)
                 ifTrue: [self reverse: aRectangle]
                 ifFalse: [self bold: aRectangle]]!
 display: aRectangle
         "Transfer aRectangle area from the
          intermediate form to the display screen."
     | originX originY |
     originX := aRectangle origin x + clipOrigin x.
     originY := aRectangle origin y + clipOrigin y.
     tempByteBlt
         width: aRectangle width;
         height: aRectangle height;
         sourceX: originX;
         sourceY: originY;
         destX: originX + destForm offset x;
         destY: originY + destForm offset y;
         copyBytes!
 initialize: aRectangle on: aForm color: aColor
         "Initialize the instance variables of
          the receiver. The argument aForm is the
          intermediate form, aRectangle serves as a clipping
          rectangle so that no change can go beyond it,
          and aColor is the attribute byte used for all
          changes made to the intermediate form."
     | backColor textColor |
     clipOrigin := (aRectangle origin - aForm offset).
     paneColor := aColor.
     backColor := paneColor bitAnd: 16r70.
     textColor := paneColor bitAnd: 7.
 
     "init color masks"
     boldMask := (backColor = (White * 16))
         ifTrue: [Black * 16 + Bold + White]
         ifFalse: [backColor + Bold + White].
     reverseMask := (textColor = Black)
         ifTrue: [Black * 16 + White]
         ifFalse: [Black * 16 + textColor].
     gapMask := backColor + White + Form blink + Form bold.
 
     "setup the byteBlt that moves from aForm to Display"
     tempByteBlt := ByteBlt new
          destForm: Display
          sourceForm: aForm
          halftone: Form nothing
          combinationRule: Form over
          destOrigin: 0@0
          sourceOrigin: 0@0
          extent: 0@0
          clipRect: aRectangle.
 
     "return the ByteBlt that moves any source form
      to 'aForm' "
     ^self destForm: aForm
          sourceForm: nil
          halftone: Form nothing
          combinationRule: Form over
          destOrigin: 0@0
          sourceOrigin: 0@0
          extent: 0@1
          clipRect: (aRectangle translateBy: 0@0 - aForm offset)!
 moveString: aString toX: x andY: y
         "Transfer aString to the intermediate form at
          coordinates x and y relative to the clipping
          rectangle.  Note that sourceX (the starting
          index position in aString) must be previously set."
     sourceForm := StringSource string: aString.
     sourceY := 0.
     destX := x + clipX.
     destY := y + clipY.
     width := 0 max: aString size - sourceX.
     height := 1.
     self copyBytes!
 paint: aRectangle
         "Repaint aRectangle area of the intermediate
          form with the paneColor."
     sourceForm := nil.
     width := aRectangle width.
     height := aRectangle height.
     destX := aRectangle origin x + clipOrigin x.
     destY := aRectangle origin y + clipOrigin y.
     halftone := paneColor.
     self copyBytes!
 reverse: aRectangle
         "Reverse the color of aRectangle
          area on the intermediate form."
     sourceForm := nil.
     width := aRectangle width.
     height := aRectangle height.
     destX := aRectangle origin x + clipOrigin x.
     destY := aRectangle origin y + clipOrigin y.
     halftone := reverseMask.
     self copyBytes!
 reverseBold: aRectangle
         "Reverse and bold aRectangle
          area on the intermediate form."
     sourceForm := nil.
     width := aRectangle width.
     height := aRectangle height.
     destX := aRectangle origin x + clipOrigin x.
     destY := aRectangle origin y + clipOrigin y.
     halftone :=Black + Bold + White.
     self copyBytes!
 setGap: aForm at: aPoint
        "Transfer the gap selector, aForm, to
         the intermediate form at aPoint."
     sourceForm := aForm.
     destX := aPoint x + clipOrigin x.
     destY := aPoint y + clipOrigin y.
     width := height := 1.
     sourceX := sourceY := 0.
     halftone := gapMask.
     self copyBytes! !

! ClassBrowser class methods ! !

! ClassBrowser methods !
 accept: codeString from: aDispatcher
         "Private - Accept codeString as an updated
          method and compile it.  Notify aDispatcher if
          the compiler detects errors."
     | result |
     result := selectedDictionary
         compile: codeString
         notifying: aDispatcher.
     result isNil
         ifTrue: [^false]
         ifFalse: [
             Methods
                 logSource: codeString
                 forSelector: result key
                 inClass: selectedDictionary.
             result key == selectedMethod
                 ifFalse: [
                     selectedMethod := nil.
                     self changed: #selectors].
             ^true]!
 dictionaries
         "Private - Answer an Array of dictionary types
          (class and instance)."
     ^#( class instance )!
 dictionary: typeSymbol
         "Private - Change to the selected dictionary type."
     typeSymbol == #class
         ifTrue: [selectedDictionary := browsedClass class]
         ifFalse:[selectedDictionary := browsedClass].
     selectedMethod := nil.
     self
         changed: #selectors;
         changed: #text!
 implementors
         "Private - Pop-up a window with the implementors
          of the selectedMethod."
     selectedMethod == nil
         ifFalse: [
             Methods implementorsOf: selectedMethod]!
 openOn: aClass
         "Create a class browser window on aClass.  Define
          the type, behavior and relative size of each
          pane and schedule the window."
     | topPane |
     (aClass isKindOf: Class)
         ifFalse: [^nil].
     browsedClass := aClass.
     topPane := TopPane new
         label: aClass name, ' | Class Browser';
         minimumSize: 20 @ 8;
         yourself.
     topPane addSubpane:
         (ListPane new
             model: self;
             name: #dictionaries;
             change: #dictionary:;
             selection: 2;
             framingBlock: [:box|
                 box origin extent:
                   (8 max: box width // 5) @ 2]).
     selectedDictionary := browsedClass.
     topPane addSubpane:
         (ListPane new
             model: self;
             name: #selectors;
             change: #selector:;
             menu: #selectorMenu;
             framingBlock: [:box|
                 box origin + (0@3) extent:
                   (8 max: box width // 5) @ (box height - 3)]).
     topPane addSubpane:
         (TextPane new
             model: self;
             name: #text;
             change: #accept:from:;
             framingBlock: [:box|
                 box origin + ((8 max: box width // 5) + 1 @ 0)
                   corner: box corner]).
     topPane dispatcher open scheduleWindow!
 removeSelector
         "Private - Remove the selected method."
     selectedMethod == nil
         ifFalse: [
             selectedDictionary
                 removeSelector: selectedMethod.
             Methods logEvaluate:
                 selectedDictionary name,
                 'removeSelector: #',
                 selectedMethod.
             selectedMethod := nil.
             self changed: #selectors]!
 selector: aSymbol
         "Private - Display the method with selector
          aSymbol in the text pane."
     selectedMethod := aSymbol.
     self changed: #text!
 selectorMenu
         "Private - Answer the selector pane menu."
     ^Menu
         labels: 'remove\senders\implementors' withCrs
         lines: Array new
         selectors: #(removeSelector senders implementors)!
 selectors
         "Private - Answer a sorted list of selectors for
          the selected dictionary type (class or instance)."
     ^selectedDictionary selectors asSortedCollection!
 senders
         "Private - Pop-up a window with the senders of
          the selected method."
     selectedMethod == nil
         ifFalse: [Methods sendersOf: selectedMethod]!
 text
         "Private - Answer the source text for the
          selected method."
     ^selectedDictionary sourceCodeAt: selectedMethod! !

! ClassHierarchyBrowser class methods ! !

! ClassHierarchyBrowser methods !
 accept: codeString from: aDispatcher
         "Private - Accept codeString as an updated
          method or class specification and compile it.
          Notify aDispatcher if the compiler detects errors."
     | result class |
     methodSelectedLast
         ifFalse: [
             ^self acceptClass: codeString from: aDispatcher].
     class := instanceSelectedLast
         ifTrue: [selectedClass]
         ifFalse: [selectedClass class].
     result := class compile: codeString
         notifying: aDispatcher.
     result isNil
         ifTrue: [^false]
         ifFalse: [
             Methods
                 logSource: codeString
                 forSelector: result key
                 inClass: class.
             result key == selectedMethod
                 ifFalse: [
                     selectedMethod := result key.
                     self changed: #selectors].
             ^true]!
 acceptClass: codeString from: aDispatcher
         "Private - Accept codeString as an updated
          class specification and compile it.  Notify
          aDispatcher if the compiler detects errors."
     | result |
     result := Compiler
         evaluate: codeString
         in: nil class
         to: nil
         notifying: aDispatcher
         ifFail: [^false].
     Methods logEvaluate: codeString.
     ^(result isKindOf: Class)!
 addSubClass
         "Private - Add a subclass to the selected class.  If
          a class is selected, prompt the user for a new
          class name and add it as a subclass to the selected class."
     | newName subclassType answer |
     selectedClass isNil
         ifTrue: [^self].
     newName := Prompter
         prompt: selectedClass name , ' subclass?'
         default: ''.
     (newName == nil or: [newName isEmpty])
         ifTrue: [^nil].
     (newName at: 1) isUpperCase
         ifFalse: [
             newName at: 1
             put: (newName at: 1) asUpperCase].
     newName := newName asSymbol.
     (Methods includesKey: newName)
         ifTrue: [^self error: newName, ' already exists'].
     subclassType := (Menu
         labels: 'subclass\variableSubclass\variableByteSubclass\variableWordSubclass' withCrs
         lines: Array new
         selectors: #(pointer indexed byte word))
             popUpAt: Cursor offset.
     (subclassType == #pointer and: [selectedClass isVariable])
         ifTrue: [
             (Prompter
                 prompt: 'Indexed pointer subclass assumed. Confirm (y/n)'
                 default: (String with: $y)) asLowerCase
                     = (String with: $y)
             ifFalse: [^self]].
     subclassType == #pointer
         ifTrue: [
             ^((selectedClass subclass: newName
                 instanceVariableNames: ''
                 classVariableNames: ''
                 poolDictionaries: '')
                     isKindOf: Class)
                         ifTrue: [self update]].
     subclassType == #indexed
         ifTrue: [
             ^((selectedClass variableSubclass: newName
                 instanceVariableNames: ''
                 classVariableNames: ''
                 poolDictionaries: '')
                     isKindOf: Class)
                         ifTrue: [self update]].
     subclassType == #word
         ifTrue: [
             ^((selectedClass variableWordSubclass: newName
                 classVariableNames: ''
                 poolDictionaries: '')
                     isKindOf: Class)
                         ifTrue: [self update]].
     subclassType == #byte
         ifTrue: [
             ^((selectedClass variableByteSubclass: newName
                 classVariableNames: ''
                 poolDictionaries: '')
                     isKindOf: Class)
                         ifTrue: [self update]]!
 browse
         "Private - Open a ClassBrowser on the selected class."
     selectedClass isNil
         ifFalse: [selectedClass edit]!
 class: symbol
         "Private - Change the state of the browser so that
          class messages are selected."
     instanceSelectedLast := methodSelectedLast := false.
     self
         changed: #instances;
         changed: #selectors;
         changed: #text!
 classes  "Private - Answer the contents of the class pane."
     ^#(class)!
 fileOut
         "Private - Write the source for the selected class
          in chunk file format to a file named with the class
          name reduced to 8 characters, extension 'cls'."
     | file |
     selectedClass isNil
         ifTrue: [^self].
     file := Disk newFile:
         (File
             fileName: selectedClass name
             extension: (String with: $c with: $l with: $s)).
     file lineDelimiter: 10 asCharacter.
     selectedClass fileOutOn: file.
     file nextChunkPut: String new.
     (ClassReader forClass: selectedClass class) fileOutOn: file.
     (ClassReader forClass: selectedClass) fileOutOn: file.
     file close!
 hideShow
         "Private - Change the hide/show status of the
          selected class."
     selectedClass isNil
         ifFalse: [
             (hiddenClasses includes: selectedClass)
                 ifTrue: [
                     hiddenClasses remove: selectedClass]
                 ifFalse: [
                     selectedClass subclasses isEmpty
                         ifFalse: [
                             hiddenClasses add:
                                 selectedClass]].
             self update]!
 hierarchy
         "Private - Answer the indented list of classes,
          an OrderedCollection of strings."
     ^browsedClasses!
 hierarchy: aString
         "Private - Display the selected class' selectors
          in the selector list pane."
     | string |
     string := aString.
     string last == $.
         ifTrue: [
             string := string copyFrom: 1
                 to: string size - 3].
     methodSelectedLast := false.
     selectedMethod := nil.
     selectedClass := Methods
         at: string trimBlanks asSymbol
         ifAbsent: [UndefinedObject].
     self
         changed: #selectors;
         changed: #text!
 implementors
         "Private - Pop-up a window with the implementors
          of the selectedMethod."
     selectedMethod == nil
         ifFalse: [Methods implementorsOf: selectedMethod]!
 instance: symbol
         "Private - Change the state of the browser so that
          instance messages are selected."
     instanceSelectedLast := true.
     methodSelectedLast := false.
     self
         changed: #classes;
         changed: #selectors;
         changed: #text!
 instances
         "Private - Answer the contents of the instance pane."
     ^#(instance)!
 menu    "Private - Answer the hierarchy pane menu."
     ^Menu
         labels: 'file out\update\hide/show\browse\add subclass' withCrs
         lines: Array new
         selectors: #(fileOut update hideShow browse addSubClass)!
 newMethod
         "Private - Display the text for a new method
          template in the text pane."
     self
         changed: #selectors;
         selector: nil;
         changed: #text with: #homeCursor!
 openOn: classCollection
         "Create a class hierarchy browser window giving access
          to classes in classCollection and their subclasses.
          Define the type, behavior and relative size of each
          pane and schedule the window."
     | topPane |
     hiddenClasses := classCollection inject: Set new into:
         [ :hidden :class |
             class subclasses do: [:each|
                 each subclasses isEmpty
                     ifFalse: [hidden add: each]].
             hidden].
     self update: classCollection.
     ratio == nil
         ifTrue: [ratio := 2 / 5].
     instanceSelectedLast := true.
     topPane := TopPane new
         label: 'Class Hierarchy Browser';
         minimumSize: 20 @ 10;
         yourself.
     topPane addSubpane:
         (ListPane new
             model: self;
             name: #hierarchy;
             change: #hierarchy:;
             menu: #menu;
             framingBlock: [:box|
                 box origin extent:
                 box width //2 - 1 @
                     (self topPaneHeight: box)]).
     topPane addSubpane:
         (ListPane new
             model: self;
             name: #selectors;
             change: #selector:;
             menu: #selectorMenu;
             framingBlock: [:box|
                 box origin+(box width//2 @ 0) extent:
                 box width-(box width//2) @
                     ((self topPaneHeight: box) - 2)]).
     topPane addSubpane:
         (ListPane new
             model: self;
             name: #classes;
             change: #class:;
             framingBlock: [:box|
                 box origin+
                     (box width//2+(box width//4) @
                         ((self topPaneHeight: box) - 1)) extent:
                     (box width - (box width//2) -
                         (box width//4)) @ 1]).
     topPane addSubpane:
         (ListPane new
             model: self;
             name: #instances;
             change: #instance:;
             selection: 1;
             framingBlock: [:box|
                 box origin+
                     (box width//2 @
                         ((self topPaneHeight: box) - 1))
                     extent: box width//4 - 1 @ 1]).
     topPane addSubpane:
         (TextPane new
             model: self;
             name: #text;
             change: #accept:from:;
             framingBlock: [:box|
                 box origin+(0 @ (1 + (self topPaneHeight: box)))
                         corner: box corner]).
     topPane dispatcher open scheduleWindow!
 removeSelector
         "Private - Remove the selected method."
     methodSelectedLast
         ifTrue: [
                 selectedMethod == nil
                     ifTrue: [^nil].
                 instanceSelectedLast
                 ifTrue: [
                     selectedClass removeSelector:
                         selectedMethod.
                     Methods logEvaluate:
                         selectedClass name,
                         ' removeSelector: #',
                         selectedMethod.
                     self hierarchy: selectedClass name]
                 ifFalse: [
                     selectedClass class removeSelector:
                         selectedMethod.
                     Methods logEvaluate:
                         selectedClass class name,
                         ' removeSelector: #',
                         selectedMethod.
                     self hierarchy: selectedClass name]]!
 selector: symbol
         "Private - Display the selected method in the text pane."
     selectedMethod := symbol.
     methodSelectedLast := true.
     self changed: #text!
 selectorMenu
         "Private - Answer the selector pane menu."
     ^Menu
         labels: 'remove\new method\senders\implementors' withCrs
         lines: Array new
         selectors: #(removeSelector newMethod senders implementors)!
 selectors
         "Private - Answer a sorted list of method
          selectors for the selected class and
          dictionary type (class or instance)."
     selectedClass == nil
         ifTrue: [^Array new].
     instanceSelectedLast
         ifTrue: [
             ^selectedClass selectors asSortedCollection]
         ifFalse: [
             ^selectedClass class selectors
                 asSortedCollection]!
 senders
         "Private - Pop-up a window with the senders of
          the selectedMethod."
     selectedMethod == nil
         ifFalse: [Methods sendersOf: selectedMethod]!
 text    "Private - Answer the source text for the selected
          method or class definition."
     | stream class |
     selectedClass == nil
         ifTrue: [^String new].
     methodSelectedLast
         ifTrue: [
             class := instanceSelectedLast
                 ifTrue: [selectedClass]
                 ifFalse: [selectedClass class].
             selectedMethod == nil
                 ifTrue: [^'messagePattern
         "comment"
     | temporaries |
     statements']
                 ifFalse: [^class sourceCodeAt: selectedMethod]].
     stream := WriteStream on: (String new: 100).
     selectedClass fileOutOn: stream.
     ^stream contents!
 topPaneHeight: aRectangle
         "Private - Answer the top pane height
          using ratio applied to aRectangle."
     ^(aRectangle height - 1 min: (2 max: (
         aRectangle height * ratio) truncated))!
 update
         "Private - Recompute the browsed classes
          and display them."
     Scheduler topDispatcher flashLabel.
     self
         update: originalClasses;
         changed: #hierarchy;
         changed: #selectors.
     selectedClass := selectedMethod := nil.
     methodSelectedLast := false.
     self changed: #text.
     Scheduler topDispatcher highlightLabel!
 update: classCollection
        "Private - Recompute the list of browsed classes
         from classCollection."
     | classStack class |
     originalClasses := classCollection.
     classStack := OrderedCollection new: 100.
     browsedClasses := OrderedCollection new: 120.
     classStack addAllFirst:
         (classCollection asSortedCollection:
             Class sortBlock).
     [classStack isEmpty]
         whileFalse: [
             class := classStack removeFirst.
             class symbol trimBlanks isEmpty
                 ifFalse: [
                     browsedClasses add:
                         ((String new:
                             class allSuperclasses size)
                                 atAllPut: $ )
                             , class symbol.
                     (hiddenClasses includes: class)
                         ifTrue: [
                             browsedClasses add:
                                 browsedClasses
                                     removeLast, '...']
                         ifFalse: [
                             classStack addAllFirst:
                                 (class subclasses
                                     asSortedCollection:
                                         Class sortBlock)]]]! !

! ClassReader class methods !
 forClass: aClass
         "Answer an instance of the receiver for aClass."
     ^self new setClass: aClass.! !

! ClassReader methods !
 classHeaderOn: aStream
         "Write a header to aStream which identifies
          the metaclass of the class described
          by the receiver.  The header precedes
          the source code for the class methods
          (as opposed to instance methods)."
     aStream
         cr;
         nextPut: $!!;
         nextPutAll: class class name;
         space;
         nextPutAll: 'methods !!'!
 fileInFrom: aStream
         "Read chunks from aStream until an empty chunk
          (a single '!!') is found.  Compile each chunk
          as a method for the class described by the
          receiver.  Log the source code of
          the method to the change log."
     | source result changeLog |
     changeLog := Sources at: 2.
     changeLog setToEnd.
     self instanceHeaderOn: changeLog.
     [(source := aStream nextChunk) isEmpty]
         whileFalse:[
             result := class compile: source.
             result notNil
                 ifTrue: [result value sourceString: source]].
     changeLog
         nextChunkPut: '';
         flush!
 fileOutOn: aStream
         "File out all the methods for the class described
          by the receiver to aStream, in chunk format."
     aStream cr.
     self instanceHeaderOn: aStream.
     class selectors asSortedCollection do: [:selector|
         aStream cr;
             nextChunkPut: (class sourceCodeAt: selector)].
     aStream nextChunkPut: ''; cr!
 instanceHeaderOn: aStream
         "Write a header to aStream which identifies
          the class described by the receiver.  The header
          precedes the source code for the methods (as
          opposed to class methods)."
     aStream
         cr;
         nextPut: $!!;
         nextPutAll: class name;
         space;
         nextPutAll: 'methods !!'!
 setClass: aClass
         "Private - Set the class described by the receiver
          ClassReader to aClass."
     class := aClass! !

! Collection class methods !
 with: anObject
         "Answer a new object with only
          one element, anObject."
     ^self new
         add: anObject;
         yourself!
 with: firstObject with: secondObject
         "Answer a new object of two elements,
          firstObject and secondObject."
     ^self new
         add: firstObject;
         add: secondObject;
         yourself!
 with: firstObject with: secondObject with: thirdObject
         "Answer a new object of three elements,
          firstObject, secondObject, and thirdObject."
     ^self new
         add: firstObject;
         add: secondObject;
         add: thirdObject;
         yourself!
 with: firstObject
     with: secondObject
     with: thirdObject
     with: fourthObject
 
         "Answer a new object of four elements, firstObject,
          secondObject, thirdObject, and fourthObject."
     ^self new
         add: firstObject;
         add: secondObject;
         add: thirdObject;
         add: fourthObject;
         yourself! !

! Collection methods !
 add: anObject
         "Answer anObject.  Add anObject
          to the receiver collection."
     ^self implementedBySubclass!
 addAll: aCollection
         "Answer aCollection.  Add each element of
          aCollection to the elements of the receiver."
     aCollection do: [ :element | self add: element].
     ^aCollection!
 asArray
         "Answer a new Array containing all
          the elements of the receiver."
     | answer index |
     answer := Array new: self size.
     index := 1.
     self do: [ :element |
         answer at: index put: element.
         index := index + 1].
     ^answer!
 asBag
         "Answer the elements of the
          receiver in a Bag object."
     ^(Bag new)
         addAll: self;
         yourself!
 asOrderedCollection
         "Answer a new OrderedCollection containing all
          the elements of the receiver."
     ^(OrderedCollection new: self size)
         addAll: self;
         yourself!
 asSet
         "Answer a new Set containing all
          the elements of the receiver."
     ^(Set new: self size)
         addAll: self;
         yourself!
 asSortedCollection
         "Answer a new SortedCollection containing all
          the elements of the receiver where the
          sort is in ascending order."
     ^(SortedCollection new: self size)
         addAll: self;
         yourself!
 asSortedCollection: aBlock
         "Answer a new SortedCollection containing all
          the elements of the receiver where the
          sort order is dictated by aBlock of code."
     ^(SortedCollection new: self size)
         sortBlock: aBlock;
         addAll: self;
         yourself!
 collect: aBlock
         "For each element in the receiver, evaluate aBlock with
          that element as the argument.  Answer a new Collection
          containing the results as its elements from the aBlock
          evaluations."
     | answer |
     answer := self species new.
     self do: [ :element |
         answer add: (aBlock value: element)].
     ^answer!
 detect: aBlock
         "Answer the first element of the receiver that
          causes aBlock to evaluate to true (with that
          element as the argument).  If no such element is
          found, report an error."
     ^self
         detect: aBlock
         ifNone: [self errorAbsentObject]!
 detect: aBlock ifNone: exceptionBlock
         "Answer the first element of the receiver that
          causes aBlock to evaluate to true (with that
          element as the argument).  If no such element is
          found, evaluate exceptionBlock (with no arguments)."
     self do: [ :element |
         (aBlock value: element)
             ifTrue: [^element]].
     ^exceptionBlock value!
 do: aBlock
         "For each element in the receiver, evaluate aBlock with
          that element as the argument.  This method should
          be implemented in the class of the receiver."
     ^self implementedBySubclass!
 errorAbsentObject
         "Private - Report an error to the effect that the element
          desidered was not found in the receiver collection."
     ^self error: 'Object is not in the collection'!
 errorNotIndexable
         "Private - Report an error to the effect that
          the receiver collection is not indexable."
     ^self error: self class name,
         's do not respond to indexing messages'!
 includes: anObject
         "Answer true if the receiver contains an
          element equal to anObject, else answer false."
     self do: [ :element |
         anObject = element
             ifTrue: [^true]].
     ^false!
 inject: initialValue into: aBinaryBlock
         "For each element in the receiver collection, evaluate
          aBinaryBlock with that element as the argument.  Starting
          with initialValue, the block is also provided with its own
          value from the previous evaluation.  Answer this value
          at the end of the block evaluations."
     | answer |
     answer := initialValue.
     self do: [ :element |
         answer := aBinaryBlock
             value: answer
             value: element].
     ^answer!
 isEmpty
         "Answer true if the receiver collection
          contains no elements, else answer false."
     ^self size = 0!
 notEmpty
         "Answer true if the receiver collection contains
          one or more elements, else answer false."
     ^self size > 0!
 occurrencesOf: anObject
         "Answer the number of elements
          contained in the receiver collection
          that are equal to anObject."
     ^self inject: 0 into: [ :occurrences :element |
         occurrences
             + (element = anObject
                 ifTrue: [1]
                 ifFalse: [0])]!
 printLimit
         "Private - Answer 2000, the maximum number of characters
          output to the display screen per each menu show it."
     ^2000!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     | maxLength |
     (RecursiveSet includes: self)
         ifTrue: [^self printRecursionOn: aStream].
     RecursiveSet add: self.
     maxLength := aStream position + self printLimit.
     self class printOn: aStream.
     aStream nextPut: $(.
     self do: [ :element |
         (aStream position > maxLength)
             ifTrue: [
                 '...etc...)' printOn: aStream.
                 ^self].
         element printOn: aStream.
         aStream space].
     aStream nextPut: $).
     RecursiveSet remove: self ifAbsent: []!
 reject: aBlock
         "For each element in the receiver, evaluate
          aBlock with that element as the argument.
          Answer a new collection containing those elements
          of the receiver for which aBlock evaluates to false."
     ^self select: [ :element |
         (aBlock value: element) not]!
 remove: anObject
         "Answer anObject.  Remove an element equal to anObject from
          the receiver collection.  If such an element is not found
          in the receiver, report an error."
     ^self
         remove: anObject
         ifAbsent: [self errorAbsentObject]!
 remove: anObject ifAbsent: aBlock
         "Answer anObject.  Remove an element equal to anObject from
          the receiver collection.  If such an element is not found
          in the receiver, evaluate aBlock (with no arguments)."
     ^self implementedBySubclass!
 removeAll: aCollection
         "Answer aCollection.  Remove all the elements
          contained in aCollection from the receiver collection."
     aCollection do: [ :element | self remove: element].
     ^aCollection!
 select: aBlock
         "For each element in the receiver, evaluate
          aBlock with that element as the argument.
          Answer a new collection containing those elements
          of the receiver for which aBlock evaluates to true."
     | answer |
     answer := self species new.
     self do: [ :element |
         (aBlock value: element)
             ifTrue: [answer add: element]].
     ^answer!
 species
         "Private - Answer the class
          of the receiver collection."
     ^self class!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reinstantiated."
     (RecursiveSet includes: self)
         ifTrue: [
             RecursiveSet := Set new.
             ^self error: 'recursive storeOn: not allowed'].
     RecursiveSet add: self.
     aStream
         nextPutAll: '((';
         nextPutAll: self class name;
         nextPutAll: ' new)'.
     (self inject: true into: [ :firstTime :element |
         firstTime
             ifFalse: [aStream nextPut: $;].
         aStream nextPutAll: 'add: '.
         element storeOn: aStream.
         false])
             ifFalse: [aStream nextPutAll: ';yourself'].
     aStream nextPut: $).
     RecursiveSet remove: self ifAbsent: []! !

! Bag class methods !
 new
     "Answer an instance of an empty Bag."
     ^self basicNew init! !

! Bag methods !
 add: anObject
         "Answer anObject.  Add anObject to the
          elements of the receiver."
     elements
         at: anObject
         put: (self occurrencesOf: anObject) + 1.
     ^anObject!
 add: anObject withOccurrences: anInteger
         "Answer anObject.  Add anObject to the elements
          of the receiver anInteger number of times."
     elements
         at: anObject
         put: (elements at: anObject ifAbsent: [0])
             + anInteger.
     ^anObject!
 at: anInteger
         "Answer the element of the receiver at index
          position anInteger.  Report an error since
          bags are not indexable."
     self errorNotIndexable!
 at: anInteger put: anObject
         "Replace the element of the receiver at index
          position anInteger with anObject.  Report an
          error, since bags are not indexable."
     self errorNotIndexable!
 do: aBlock
         "For each element in the receiver, evaluate
          aBlock with that element as the argument."
     | i |
     elements associationsDo: [ :association |
         i := association value.
         [i > 0]
             whileTrue: [
                 aBlock value: association key.
                 i := i - 1]]!
 includes: anObject
         "Answer true if the receiver contains an
          element equal to anObject, else answer false."
     elements at: anObject ifAbsent: [^false].
     ^true!
 init
         "Private - initialize the receiver to be empty."
     elements := Dictionary new!
 occurrencesOf: anObject
         "Answer the number of elements of the
          receiver equal to anObject."
     ^elements at: anObject ifAbsent: [^0]!
 remove: anObject ifAbsent: aBlock
         "Answer anObject.  Remove one occurrence of
          anObject from the receiver collection.  If
          anObject is not an element of the receiver,
          evaluate aBlock (with no arguments)."
     | occurrences |
     (occurrences := elements
         at: anObject
         ifAbsent: [^aBlock value]) = 1
             ifTrue: [elements removeKey: anObject]
             ifFalse: [
                 elements at: anObject
                 put: occurrences - 1].
     ^anObject!
 size
         "Answer the number of elements in the
          receiver collection."
     | count |
     count := 0.
     elements associationsDo: [ :element |
         count := count + element value].
     ^count! !

! IndexedCollection class methods ! !

! IndexedCollection methods !
 , aCollection
         "Answer a new collection containing the elements
          of the receiver followed by the the elements of
          aCollection."
     | answer oldSize newSize |
     oldSize := self size.
     newSize := oldSize + aCollection size.
     answer := self species new: newSize.
     answer
         replaceFrom: 1
         to: oldSize
         with: self
         startingAt: 1.
     answer
         replaceFrom: oldSize + 1
         to: newSize
         with: aCollection
         startingAt: 1.
     ^answer!
 = aCollection
         "Answer true if the elements contained by
          the receiver are equal to the elements
          contained by the argument aCollection."
     | index |
     self == aCollection
         ifTrue: [^true].
     (self class == aCollection class)
         ifFalse: [^false].
     index := self size.
     index ~= aCollection size
         ifTrue: [^false].
     [index <= 0]
         whileFalse: [
             (self at: index) = (aCollection at: index)
                 ifFalse: [^false].
             index := index - 1].
     ^true!
 accessEmptyCollection
         "Private - Report an error to the effect
          that the accessed collection was empty."
     ^self error: 'the collection is empty'!
 atAll: aCollection put: anObject
         "Answer the receiver after replacing those
          elements, indexed by the indices contained
          in aCollection, with anObject."
     aCollection do: [ :index |
         self at: index put: anObject]!
 atAllPut: anObject
         "Answer the receiver after each element
          has been replaced with anObject."
     self
         replaceFrom: 1
         to: self size
         withObject: anObject!
 checkIndex: anInteger
         "Private - Check that the argument anInteger
          is a valid index for the receiver collection.
          If it is found to be invalid, report the error."
     (anInteger isKindOf: Integer)
         ifFalse: [
             ^self error:
                 'Indexed collections are indexed by integers'].
     (anInteger between: 1 and: self size)
         ifFalse: [
             ^self errorInBounds: anInteger]!
 copy
         "Answer a new collection containing
          the same elements as the receiver."
     ^self copyFrom: 1 to: self size!
 copyFrom: start to: stop
         "Answer a new collection containing the elements
          of the receiver indexed from start through stop."
     | newSize |
     newSize := stop - start + 1.
     ^(self species new: newSize)
         replaceFrom: 1
         to: newSize
         with: self
         startingAt: start!
 copyReplaceFrom: start to: stop with: aCollection
         "Answer a new collection containing a copy of the
          receiver with the elements at index positions from
          start through stop replaced with the elements of
          aCollection."
     ^(self copyFrom: 1 to: start - 1)
         , aCollection
         , (self copyFrom: stop + 1 to: self size)!
 copyWith: anObject
         "Answer a copy of the receiver with
          anObject added to it as an element."
     ^ self , (self species with: anObject)!
 copyWithout: anObject
         "Answer a copy of the receiver excluding
          an element that equals anObject."
     | match |
     match := self
         indexOf: anObject
         ifAbsent: [^self copy].
     ^(self copyFrom: 1 to: match - 1),
         ((self copyFrom: match + 1 to: self size)
             copyWithout: anObject)!
 do: aBlock
         "Answer the receiver.  For each element in the receiver,
          evaluate aBlock with that element as the argument."
     | index size |
     index := 1.
     size := self size.
     [index > size]
         whileFalse: [
             aBlock value: (self at: index).
             index := index + 1]!
 elementNotFound
         "private method"
     ^self error: 'element not found'!
 errorInBounds: anInteger
         "Private - Produce a walkback to the effect that
          anInteger is an invalid index for the receiver."
     ^self
         error: 'index: '
             , anInteger printString
             , ' is outside of collection bounds'!
 findFirst: aBlock
         "Answer the index of the first element of the
          receiver that causes aBlock to evaluate to true
          (with that element as the argument).  If no such
          element is found, report an error."
     | index length |
     length := self size.
     index := 1.
     [index <= length]
         whileTrue: [
             (aBlock value: (self at: index) )
                 ifTrue: [^index].
             index := index + 1].
     ^self errorAbsentObject!
 findLast: aBlock
         "Answer the index of the last element of the
          receiver that causes aBlock to evaluate to true
          (with that element as the argument).  If no such
          element is found, report an error."
     | index length found |
     length := self size.
     index := 1.
     [index <= length]
         whileTrue: [
             (aBlock value: (self at: index) )
                 ifTrue: [found := index].
             index := index + 1].
     found isNil
         ifTrue: [^self errorAbsentObject]
         ifFalse: [^found]!
 first
         "Answer the first element of the receiver.
          Report an error if the receiver has no elements."
     self isEmpty
         ifTrue: [^self accessEmptyCollection].
     ^self at: 1!
 grow
         "Answer the receiver expanded in
          size to accomodate more elements."
     | size |
     size := self size.
     (self species new: size + self growSize)
         replaceFrom: 1 to: self size with: self;
         become: self!
 growSize
         "Private - Answer the number of elements
          that the receiver is to expand by."
     ^self size // 3 + 10!
 hash
         "Answer the integer hash value for the receiver."
     ^(self size = 0 or: [(self at: 1) == self])
         ifTrue: [7]
         ifFalse: [(self at: 1) hash]!
 includes: anObject
         "Answer true if the receiver contains an
          element equal to anObject, else answer false."
     | index |
     index := self size + 1.
     [(index := index - 1) > 0]
         whileTrue: [
             anObject = (self at: index)
                 ifTrue: [^true]].
     ^false!
 indexOf: anObject
         "Answer the index position of the element equal
          to anObject in the receiver.  If no such element
          is found, answer zero."
     ^self
         indexOf: anObject
         ifAbsent: [^0]!
 indexOf: anObject ifAbsent: aBlock
         "Answer the index position of the element equal
          to anObject in the receiver.  If no such element
          is found, evaluate aBlock (without any arguments)."
     | index length |
     length := self size.
     index := 1.
     [index <= length]
         whileTrue: [
             (self at: index) = anObject
                 ifTrue: [^index].
             index := index + 1].
     ^aBlock value!
 last
         "Answer the last element of the receiver.
          A walkback is produced if the receiver has
          no elements."
     self isEmpty
         ifTrue: [ ^self accessEmptyCollection].
     ^self at: self size!
 replaceFrom: start to: stop with: aCollection
         "Answer the receiver.  Replace the elements of the
          receiver at index positions start through stop,
          with the elements of aCollection.  The number of
          elements being replaced must be the same as the
          number of elements in aCollection, else report
          an error."
     stop - start + 1 = aCollection size
         ifFalse: [
             ^self error: 'The replacement collection has wrong size'].
     self
         replaceFrom: start
         to: stop
         with: aCollection
         startingAt: 1!
 replaceFrom: start
     to: stop
     with: aCollection
     startingAt: repStart
 
         "Replace the elements of the receiver at index
          positions start through stop with consecutive
          elements of aCollection beginning at index
          position repStart.  Answer the receiver."
     | index replaceIndex |
     (self == aCollection and: [repStart < start])
         ifTrue: [ "do backward move for same object"
             replaceIndex := repStart + stop - start.
             index := stop.
             [start <= index]
                 whileTrue: [
                 self
                     at: index
                     put: (aCollection at: replaceIndex).
                 index := index - 1.
                 replaceIndex := replaceIndex - 1].
             ^self].
     "do forward move"
     replaceIndex := repStart.
     index := start.
     [index <= stop]
         whileTrue: [
             self
                 at: index
                 put: (aCollection at: replaceIndex).
             index := index + 1.
             replaceIndex := replaceIndex + 1]!
 replaceFrom: start to: stop withObject: anObject
         "Replace each of the elements of the receiver
          at index positions start through stop
          with anObject.  Answer anObject."
     | index |
     index := start.
     [index <= stop]
         whileTrue: [
             self at: index put: anObject.
             index := index + 1].
     ^anObject!
 reversed
         "Answer a new object containing the
          elements of the receiver in reverse order."
     ^(ReadStream on: self) reverseContents!
 reverseDo: aBlock
         "For each element in the receiver, starting
          with the last element, evaluate aBlock with
          that element as the argument."
     | index |
     index := self size.
     [index > 0]
         whileTrue: [
             aBlock value: (self at: index).
             index := index - 1]!
 size
         "Answer the number of elements of the receiver."
     ^self implementedBySubclass!
 with: aCollection do: aBlock
         "For each pair of elements (the first from the
          receiver and the second from aCollection),
          evaluate aBlock with those elements as the arguments.
          The receiver and aCollection must contain
          the same number of elements, else report an error."
     | stream1 stream2 |
     self size = aCollection size
         ifFalse: [^self error: 'Collections are of differing length'].
     stream1 := ReadStream on: self.
     stream2 := ReadStream on: aCollection.
     [stream1 atEnd]
         whileFalse: [
             aBlock
                 value: stream1 next
                 value: stream2 next]! !

! FixedSizeCollection class methods !
 with: anObject
         "Answer a new object with only
          one element, anObject."
     | newCollection |
     newCollection := self new: 1.
     newCollection at: 1 put: anObject.
     ^newCollection!
 with: firstObject with: secondObject
         "Answer a new object of two elements,
          firstObject and secondObject."
     | newCollection |
     newCollection := self new: 2.
     newCollection at: 1 put: firstObject.
     newCollection at: 2 put: secondObject.
     ^newCollection!
 with: firstObject with: secondObject with: thirdObject
         "Answer a new object of three elements,
          firstObject, secondObject, and thirdObject."
     | newCollection |
     newCollection := self new: 3.
     newCollection at: 1 put: firstObject.
     newCollection at: 2 put: secondObject.
     newCollection at: 3 put: thirdObject.
     ^newCollection!
 with: firstObject
     with: secondObject
     with: thirdObject
     with: fourthObject
 
         "Answer a new object of four elements, firstObject,
          secondObject, thirdObject, and fourthObject."
     | newCollection |
     newCollection := self new: 4.
     newCollection at: 1 put: firstObject.
     newCollection at: 2 put: secondObject.
     newCollection at: 3 put: thirdObject.
     newCollection at: 4 put: fourthObject.
     ^newCollection! !

! FixedSizeCollection methods !
 add: anObject
         "Add anObject to the receiver.  This method reports
          an error since fixed size collections cannot grow."
     ^self invalidMessage!
 collect: aBlock
         "For each element in the receiver, evaluate
          aBlock with that element as the argument.
          Answer a new collection containing the results
          from the aBlock evaluations as its elements."
     | answer index size |
     size := self size.
     answer := OrderedCollection new: size.
     index := 1.
     [index > size]
         whileFalse: [
             answer add: (aBlock value: (self at: index)).
             index := index + 1].
     ^(self species new: size)
         replaceFrom: 1
         to: size
         with: answer!
 copyReplaceFrom: start to: stop with: aCollection
         "Answer a new object containing the receiver whose
          elements indexed from start through stop have
          been replaced by the elements of the aCollection."
     | answer replSize size |
     replSize := aCollection size.
     size := self size + replSize - (stop - start + 1).
     answer := self species new: size.
     answer
         replaceFrom: 1
         to: start - 1
         with: self
         startingAt: 1.
     answer
         replaceFrom: start
         to: start + replSize - 1
         with: aCollection.
     ^answer
         replaceFrom: start + replSize
         to: size
         with: self
         startingAt: stop + 1!
 remove: anObject ifAbsent: aBlock
         "Remove anObject from the receiver.  This method
          reports an error since elements cannot be removed
          from fixed size collections, they can only be changed."
     ^self invalidMessage!
 select: aBlock
         "For each element in the receiver, evaluate
          aBlock with that element as the argument.
          Answer a new collection containing those elements
          of the receiver for which aBlock evaluates to true."
     | answer index size object |
     size := self size.
     answer := OrderedCollection new: size.
     index := 1.
     [index > size]
         whileFalse: [
             object := self at: index.
             (aBlock value: object)
                 ifTrue: [answer add: object].
             index := index + 1].
     size := answer size.
     ^(self species new: size)
         replaceFrom: 1
         to: size
         with: answer!
 size
         "Answer the number of indexed instance
          variables of the receiver."
     <primitive: 62>
     ^self primitiveFailed!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reinstantiated."
     | size index firstTime |
     size := self size.
     aStream
         nextPutAll: '((';
         nextPutAll: self class name;
         nextPutAll: ' new: '.
     size printOn: aStream.
     aStream nextPut: $).
     index := 1.
     firstTime := true.
     [index <= size]
         whileTrue: [
             firstTime
                 ifFalse: [aStream nextPut: $;].
             firstTime := false.
             aStream nextPutAll: 'at: '.
             index printOn: aStream.
             aStream nextPutAll: ' put: '.
             (self at: index) storeOn: aStream.
             index := index + 1].
     firstTime
         ifFalse: [aStream nextPutAll: ';yourself'].
     aStream nextPut: $)! !

! Array class methods ! !

! Array methods !
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     (RecursiveSet includes: self)
         ifTrue: [^self printRecursionOn: aStream].
     RecursiveSet add: self.
     aStream nextPut: $(.
     self do: [ :element |
         element printOn: aStream.
         aStream space].
     aStream nextPut: $).
     RecursiveSet remove: self ifAbsent: []!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reinstantiated."
     | size index firstTime |
     (RecursiveSet includes: self)
         ifTrue: [
             RecursiveSet := Set new.
             ^self error: 'recursive storeOn: not allowed'].
     RecursiveSet add: self.
     size := self size.
     aStream
         nextPutAll: '((';
         nextPutAll: self class name;
         nextPutAll: ' new: '.
     size printOn: aStream.
     aStream nextPut: $).
     index := 1.
     firstTime := true.
     [index <= size]
         whileTrue: [
             firstTime
                 ifFalse: [aStream nextPut: $;].
             firstTime := false.
             aStream nextPutAll: 'at: '.
             index printOn: aStream.
             aStream nextPutAll: ' put: '.
             (self at: index) storeOn: aStream.
             index := index + 1].
     firstTime
         ifFalse: [aStream nextPutAll: ';yourself'].
     aStream nextPut: $).
     RecursiveSet remove: self ifAbsent: []! !

! ByteArray class methods ! !

! ByteArray methods !
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner."
     | size index |
     size := self basicSize.
     aStream nextTwoBytesPut: (aCloner cloneOopFor: self class).
     aStream nextTwoBytesPut: size + 2.
     index := 1.
     [ index <= size ]
         whileTrue: [
             aStream nextBytePut: (self at: index).
             index := index + 1]!
 replaceFrom: start
     to: stop
     with: aCollection
     startingAt: repStart
 
         "Replace the elements of the receiver at index
          positions start through stop with consecutive
          elements of aCollection beginning at index
          position repStart.  Answer the receiver."
     <primitive: 105>
     super
         replaceFrom: start
         to: stop
         with: aCollection
         startingAt: repStart! !

! CompiledMethod class methods !
 compress: codeString
         "Answer a String which is the compressed
          form of codeString.  Compression
          replaces frequently occurring sequences
          of characters with a single character > 127.
          Characters > 127 are preceded by the escape
          character 128."
     | readStream writeStream nextPiece lf
       compressionDictionary |
     compressionDictionary :=
         Methods at: #CompressionDictionary.
     lf := nextPiece := (String with: 10 asCharacter).
     readStream := ReadStream on: codeString.
     writeStream := WriteStream on: (String new: codeString size).
     [nextPiece = lf
         ifTrue: [
             writeStream nextPut:
                 (readStream countBlanks + 129) asCharacter].
      (nextPiece := readStream nextPiece) == nil]
         whileFalse: [
             (compressionDictionary includesKey: nextPiece)
                 ifTrue: [
                     writeStream nextPut:
                         (compressionDictionary at: nextPiece) asCharacter]
                 ifFalse: [writeStream nextPutAll: nextPiece]].
     ^writeStream contents!
 decompress: codeString
         "Answer a String which is the decompressed
          form of codeString.  Decompression
          replaces character values > 128 with the
          string that the character represents."
     | char index lf readStream writeStream |
     lf := true.
     readStream := ReadStream on: codeString.
     writeStream := WriteStream on: (String new: 200).
     [readStream atEnd]
         whileFalse: [
             char := readStream next.
             (index := char asciiValue) > 128
                 ifTrue: [
                     lf
                         ifTrue: [
                             writeStream next: index - 129 put: $ .
                             lf := false]
                         ifFalse: [
                             writeStream nextPutAll:
                                 (DecompressionArray at: index - 128)]]
                 ifFalse: [
                     index = 128
                         ifTrue: [char := readStream next].
                     writeStream nextPut: char.
                     lf := (index = 10)]]. "10 = Lf"
     ^writeStream contents! !

! CompiledMethod methods !
 includes: anObject
         "Answer true if the method includes a
          reference to anObject, else answer false."
     | impliedCode |
     impliedCode := anObject codeFor.
     ^self includes: anObject with: impliedCode!
 includes: anObject with: impliedCode
         "Answer true if the method includes a
          reference to anObject or contains
          impliedCode, else answer false."
     <primitive: 39>!
 oopAt: anInteger
         "Answer the 2 bytes beginning at index position
          anInteger as an object pointer."
     | firstByte secondByte pointer |
     (firstByte := self at: anInteger + 1) > 127
         ifTrue: [firstByte := firstByte - 256].
     secondByte := self at: anInteger.
     pointer := firstByte*128 + (secondByte bitShift: -1).
     secondByte odd
         ifTrue:  [^pointer asObject]
         ifFalse: [^pointer]!
 source
         "Answer a String containing the source
          code for the receiver.  If source is
          from the source file it is compressed,
          if from the change log, uncompressed."
     | sourceFile index |
     index := self sourceIndex.
     (index between: 1 and: Sources size)
         ifFalse: [^nil].
     sourceFile := Sources at: index.
     sourceFile position: self sourcePosition.
     ^sourceFile nextChunk trimBlanks!
 sourceIndex
         "Answer the index into the Sources (a global
          variable) array of the file containing the
          receiver source code: 1 for source file,
          2 for change log."
     ^((self at: self size - 2)
         bitShift: -6) bitAnd: 3!
 sourceIndex: index sourcePosition: position
         "Record the source code file index and
          position in the end of the receiver."
     | size |
     size := self size.
     self at: size - 2 put:
         position // 256 // 256 + (index * 64).
     self at: size - 1 put:
         (position // 256 bitAnd: 255).
     self at: size put: (position bitAnd: 255)!
 sourcePosition
         "Answer the file position of the source
          code for the receiver."
     | size |
     size := self size.
     ^(((self at: size - 2) bitAnd: 63) * 256
         + (self at: size - 1)) * 256
             + (self at: size)!
 sourceString
         "Answer the uncompressed source code for
          the receiver."
     | source |
     source := self source.
     source == nil
         ifTrue: [^nil].
     self sourceIndex = 2
         ifFalse: [^self class decompress: source].
     ^source!
 sourceString: aString
         "Write aString to the change log and record
          it as the current source code for the receiver."
     | sourceFile |
     sourceFile := Sources at: 2.
     sourceFile setToEnd.
     self
         sourceIndex: 2
         sourcePosition: sourceFile position.
     sourceFile
         nextChunkPut: aString trimBlanks! !

! FileControlBlock class methods !
 open: aString in: aDirectory
         "Answer a file control block for an opened
          file named aString in aDirectory."
     ^self dosError:
         (self
             openIn: aDirectory
             name: aString fileName
             extension: aString fileExtension)!
 openIn: aDirectory name: string8 extension: string3
         "Answer an opened FileControlBlock for the file
          named: (string8, string3) in aDirectory; or a
          DOS integer error code."
     <primitive: 124>
     ^self primitiveFailed!
 unopened
         "Answer an unopened file control block."
     | tempFCB |
     tempFCB := self new: 44.
     tempFCB
         at: 1 put: 255;
         at: 7 put: 16r3F;
         at: 8 put: 0.
     tempFCB replaceFrom: 2 to: 6 withObject: 0.
     tempFCB replaceFrom: 9 to: 19 withObject: $? asciiValue.
     tempFCB replaceFrom: 20 to: 44 withObject: 0.
     ^tempFCB! !

! FileControlBlock methods !
 close
         "Close the file identified by the receiver."
     self dosError: self primitiveClose!
 endByte
         "Answer the size in bytes of the file
          identified by the receiver."
     ^(self at: 26) * 256
         + (self at: 25) * 256
             + (self at: 24)!
 primitiveClose
         "Private - Close the file."
     <primitive: 127>!
 readInto: aString atPage: anInteger
         "Private - Read a page (512 bytes) or less
          (if at end of file) at page number anInteger from
          the receiver file into aString.  Answer the number
          of bytes read.  aString size must be >= 512."
     <primitive: 125>
     ^self primitiveFailed!
 readInto: aString atPosition: anInteger
         "Read a page (512 bytes) or less (if at
          end of file) at position anInteger
          modulo 512 from the receiver file into
          aString.  Answer the number bytes read.
          aString size must be >= 512."
     ^self dosError:
         (self
             readInto: aString
             atPage: anInteger // File pageSize)!
 writeFrom: aString toPage: anInteger for: length
         "Private - Write length bytes of aString to
          the receiver file at page number anInteger."
     <primitive: 126>
     ^self primitiveFailed!
 writeFrom: aString toPosition: anInteger for: length
         "Write length bytes of aString to the receiver
          file at position anInteger modulo 512."
     self dosError:
         (self
             writeFrom: aString
             toPage: anInteger // File pageSize
             for: length)! !

! Interval class methods !
 from: beginningInteger to: endInteger
         "Answer an Interval from beginningInteger to
          endInteger incrementing by one."
     ^self basicNew
         initBegin: beginningInteger
         end: endInteger
         incr: 1!
 from: beginningInteger to: endInteger by: incrementInteger
         "Answer an Interval from beginningInteger to
          endInteger incrementing by incrementInteger."
     ^self basicNew
         initBegin: beginningInteger
         end: endInteger
         incr: incrementInteger! !

! Interval methods !
 at: anInteger
         "Answer the number at index position
          anInteger in the receiver interval."
     | answer |
     anInteger > 0
         ifTrue: [
             answer := beginning + (increment * (anInteger - 1)).
             (increment < 0
                 and: [answer between: end and: beginning])
                     ifTrue: [^answer].
             (increment > 0
                 and: [answer between: beginning and: end])
                     ifTrue: [^answer]].
     ^self errorInBounds: anInteger!
 at: anInteger put: aNumber
         "Replace the number in the receiver indexed by
          anInteger with the argument aNumber.  This message is
          not valid for intervals since interval collections
          are implicitely defined (the elements are computed)."
     ^self invalidMessage!
 increment
         "Answer the increment of the receiver Interval."
     ^increment!
 initBegin: beginningInteger
     end: endInteger
     incr: incrementInteger
 
         "Private - Answer the receiver after initializing
          the beginning, end and increment instance variables."
     beginning := beginningInteger.
     end := endInteger.
     increment := incrementInteger.
     increment = 0
         ifTrue: [^self error: 'interval increment is 0']!
 size
         "Answer the number of elements of the receiver."
     ^0 max: end - beginning // increment + 1!
 species
         "Answer Array, a class which is similar to the
          receiver class and can be used to contain
          derived copies of the receiver."
     ^Array! !

! String class methods ! !

! String methods !
 < aString
         "Answer true if the receiver is before
          aString, else answer false.  The comparison
          is not case sensitive."
     ^(aString asString <= self) not!
 <= aString
         "Answer true if the receiver is before
          or equal to aString, else answer false.
          The comparison is not case sensitive."
     <primitive: 56>
     ^self primitiveFailed!
 = aString
         "Answer true if the receiver is equal to
          aString, else answer false.  The comparison
          is case sensitive."
     <primitive: 55>
     ^false!
 > aString
         "Answer true if the receiver is after
          aString, else answer false.  The comparison
          is not case sensitive."
     ^(self <= aString) not!
 >= aString
         "Answer true if the receiver is after
          or equal to aString, else answer false.
          The comparison is not case sensitive."
     ^aString <= self!
 asArrayOfSubstrings
         "Answer an array of substrings from the
          receiver.  The receiver is divided into
          substrings at the occurrences of one or
          more space characters."
     | stream substrings first |
     substrings := OrderedCollection new.
     stream := ReadStream on: self.
     [stream atEnd] whileFalse:
         [[stream atEnd ifTrue: [^substrings asArray].
           stream peek > Space]
               whileFalse: [stream next].
          first := stream position + 1.
          [stream atEnd or: [stream peek <= Space]]
               whileFalse: [stream next].
          substrings add:
             (self copyFrom: first to: stream position)].
     ^substrings asArray!
 asAsciiZ
         "Answer a new String containing all the
          characters of the receiver followed by
          the character of ASCII value zero."
     ^self, (String with: 0 asCharacter)!
 asDate
         "Answer an instance of class Date representing
          the date described by the receiver.  The
          receiver must contain first the day number
          then the month name and then the year
          separated by blanks."
     ^Date fromString: self!
 asInteger
         "Answer the integer corresponding to the receiver;
          the receiver is expected to be a pure sequence of
          digits without any other non digit character."
     | answer |
     answer := 0.
     self do: [:digit |
         (digit isDigit)
             ifFalse: [^answer].
         answer := answer * 10 + digit digitValue].
     ^answer!
 asLowerCase
         "Answer a string containing the
          receiver characters in lower case."
     | newString length index aCharacter |
     length := self size.
     newString := String new: length.
     index := 1.
     [index <= length]
         whileTrue: [
             (aCharacter := self at: index) isUpperCase
                 ifTrue: [
                     aCharacter :=
                         (aCharacter asciiValue + UpperToLower) asCharacter].
             newString at: index put: aCharacter.
             index := index + 1].
     ^newString!
 asString
         "Answer the string representing the
          receiver (the receiver itself)."
     ^self!
 asSymbol
         "Answer a symbol whose name is
          the receiver string."
     ^Symbol intern: self!
 asUpperCase
         "Answer a String containing the
          receiver characters in upper case."
     | newString length index aCharacter |
     length := self size.
     newString := String new: length.
     index := 1.
     [index <= length]
         whileTrue: [
             (aCharacter := self at: index) isLowerCase
                 ifTrue: [
                     aCharacter :=
                         (aCharacter asciiValue - UpperToLower) asCharacter].
             newString at: index put: aCharacter.
             index := index + 1].
     ^newString!
 at: anInteger
         "Answer the character at position
          anInteger in the receiver string."
     <primitive: 63>
     self checkIndex: anInteger.
     ^self primitiveFailed!
 at: anInteger put: aCharacter
         "Answer the argument aCharacter.  At
          position anInteger in the receiver
          string put the character aCharacter."
     <primitive: 64>
     self checkIndex: anInteger.
     self checkCharacter: aCharacter.
     ^self primitiveFailed!
 basicAt: anInteger
         "Answer the character at position
          anInteger in the receiver string."
     <primitive: 63>
     self checkIndex: anInteger.
     ^self primitiveFailed!
 basicAt: anInteger put: aCharacter
         "Answer the argument aCharacter.  At
          position anInteger in the receiver
          string put the character aCharacter."
     <primitive: 64>
     self checkIndex: anInteger.
     self checkCharacter: aCharacter.
     ^self primitiveFailed!
 checkCharacter: aCharacter
         "Private - Report an error if the argument
          aCharacter is not an instance of class Character."
     (aCharacter isKindOf: Character)
         ifFalse: [
             ^self error: 'can''t hold '
                 , aCharacter class name,'''s']!
 displayAt: aPoint
         "Output the receiver directly onto the display screen
          at aPoint.  Note that the string is being output to the
          screen not to a window so when the area of the screen
          at aPoint is redrawn, the string will disappear."
     (DisplayString for: self)
         displayAt: aPoint!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner."
     aStream nextTwoBytesPut: (aCloner cloneOopFor: self class).
     aStream nextTwoBytesPut: self basicSize + 2.
     aStream nextPutAll: self!
 edit
         "Open a workspace window with the
          receiver string as the contents."
     | topPane |
     topPane := TopPane new.
     topPane
         label: 'Workspace';
         model: topPane dispatcher;
         menu: #workSpaceMenu;
         minimumSize: 3@3;
         addSubpane:
             (TextPane new
                 model: self;
                 framingBlock: [ :box | box]).
     topPane dispatcher open scheduleWindow!
 equals: aString
         "Answer true if the receiver is equal to
          the argument aString, else answer false.
          If aString is not a kind of String, a
          walkback is produced.  Note that the
          comparison is case sensitive."
     <primitive: 55>
     ^self primitiveFailed!
 fileExtension
         "Answer a three character String that
          follows the receiver's first period
          character (for DOS file names)."
     | answer |
     answer := (ReadStream on: self trimBlanks)
         skipTo: $.; upTo: $..
     answer size > 3
         ifTrue: [self error: 'file extension too long'].
     ^(answer , '   ') copyFrom: 1 to: 3!
 fileName
         "Answer the characters of the receiver string up
          to the first period character.  Report an error
          if the resulting string is greater than eight or
          less than one character (for DOS file names)."
     | answer |
     answer := self trimBlanks.
     (answer = '.' or: [answer = '..'])
         ifFalse: [
             answer := (ReadStream on: answer)
                 upTo: $..
             answer size = 0
                 ifTrue: [self error: 'file name missing'].
             answer size > 8
                 ifTrue: [self error: 'file name too long']].
     ^(answer , '        ') copyFrom: 1 to: 8!
 hash
         "Answer the integer hash value
          for the receiver."
     <primitive: 107>!
 isAnInteger
         "Answer true if the receiver is a pure
          sequence of digits without any other
          non-digit character, else answer false."
     self do: [:digit |
         (digit isDigit)
             ifFalse: [^false]].
     ^true!
 outputToPrinter
         "Answer the receiver.  Output the receiver string to
          the printer.  Report an error if unsuccessful."
     self dosError: self primitiveForPrinterOutput!
 primitiveForPrinterOutput
         "Private - Output the receiver string
          to the printer."
     <primitive: 116>!
 printOn: aStream
         "Append the receiver as a quoted string
          to aStream doubling all internal single
          quote characters."
     aStream nextPut: $'.
     self do: [ :character |
         aStream nextPut: character.
         character = $'
             ifTrue: [aStream nextPut: character]].
     aStream nextPut: $'!
 replaceFrom: start
     to: stop
     with: aString
     startingAt: repStart
 
         "Replace the characters of the receiver at index
          positions start through stop with consecutive
          characters of aString beginning at index
          position repStart.  Answer the receiver."
     <primitive: 105>
     super
         replaceFrom: start
         to: stop
         with: aString
         startingAt: repStart!
 replaceFrom: start to: stop withObject: aCharacter
         "Replace the characters of the receiver
          at index positions start through stop
          with aCharacter.  Answer aCharacter."
     <primitive: 106>
     ^super
         replaceFrom: start
         to: stop
         withObject: aCharacter!
 size
         "Answer the size of the receiver string."
     <primitive: 62>!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reinstantiated."
     self printOn: aStream!
 stringHash
         "Answer the integer hash value
          for the receiver."
     <primitive: 107>!
 trimBlanks
         "Answer a String containing the receiver
          string with leading and trailing blanks
          removed"
     | nonBlank first aStream |
     nonBlank := false.
     aStream := ReadStream on: self.
     [aStream atEnd or: [nonBlank := aStream next > Space]]
         whileFalse:[].
     nonBlank
         ifTrue: [first := aStream position]
         ifFalse: [^String new: 0].
     aStream position: self size - 1.
     [aStream next > Space]
         whileFalse: [aStream skip: -2].
     ^self copyFrom: first to: aStream position!
 withCrs
         "Answer the receiver string where each
          occurrence of the character \ has been
          replaced with a line-feed character."
     1 to: self size do: [ :i |
         (self at: i) = $\
             ifTrue: [self at: i put: Lf]]! !

! Symbol class methods !
 intern: aString
         "Answer a Symbol whose character sequence
          is the same as that of aString."
     | index length symbol symbolTable |
     symbolTable := self symbolTable.
     length := aString size.
     symbol := (super new: length)
         replaceFrom: 1 to: length with: aString.
     index := symbolTable find: symbol
         ifAbsent: [
             symbolTable add: symbol.
             ^symbol].
     ^symbolTable basicAt: index!
 mustBeSymbol: aSymbol
         "Report an error if aSymbol is not a Symbol."
     (aSymbol class == self)
         ifFalse: [^self error: 'Must be a Symbol']!
 symbolTable
         "Answer the fixed pointer for the symbol table."
     ^5 asObject! !

! Symbol methods !
 = aSymbol
         "Answer true if the receiver object is the
          the argument aSymbol, else answer false."
     <primitive: 110>!
 asString
         "Answer a String of the characters
          contained by the receiver."
     ^(String new: self size)
         replaceFrom: 1
         to: self size
         with: self!
 asSymbol
         "Answer a Symbol for the receiver.  The receiver
          itself is answered since it is a Symbol."
     ^self!
 at: anInteger put: aCharacter
         "Replace the character in the receiver indexed by
          anInteger with the argument aCharacter.  This
          message is not valid for symbols, since they
          are not allowed to change."
     self invalidMessage!
 copy
         "Answer a shallow copy of the receiver.
          Because symbols are unique (cannot be
          copied), answer the receiver."
     ^self!
 deepCopy
         "Answer a copy of the receiver with shallow
          copies of each instance variable.  Because
          symbols are unique (cannot be copied),
          answer the receiver."
      ^self!
 hash
         "Answer the integer hash value for the receiver."
     ^self asOop bitAnd: 16r3FFF!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     aStream nextPutAll: self!
 shallowCopy
         "Answer a copy of the receiver which shares
          the receiver instance variables.  Because
          symbols are unique (cannot be copied),
          answer the receiver."
     ^self!
 species
         "Private - Answer the class String as the
          species of symbols."
     ^String!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reconstructed."
     aStream
         nextPut: $#;
         nextPutAll: self! !

! OrderedCollection class methods !
 new
         "Answer an instance of OrderedCollection
          capable of holding 12 elements initially."
     ^self new: 12!
 new: anInteger
         "Answer an initialized instance of OrderedCollection
          capable of holding anInteger number of elements."
     ^(super new: anInteger) initPositions! !

! OrderedCollection methods !
 , aCollection
         "Answer an OrderedCollection containing all
          the elements of the receiver followed by
          all the elements of aCollection."
     ^self copy
         addAll: aCollection;
         yourself!
 add: anObject
         "Answer anObject.  Add anObject after the
          last element of the receiver collection."
     ^self addLast: anObject!
 add: newObject after: oldObject
         "Answer newObject.  Insert newObject immediately after
          the element oldObject in the receiver collection.  If
          oldObject is not in the collection, report an error."
     | index |
     index := 1.
     [index <= self size]
         whileTrue: [
             oldObject = (self at: index)
                 ifTrue: [^self add: newObject afterIndex: index].
             index := index + 1].
     ^self errorAbsentElement!
 add: anObject afterIndex: anInteger
         "Answer anObject.  Insert anObject at index position
          anInteger + 1 in the receiver collection.  If anInteger
          is out of the collection bounds, report an error."
     self putSpaceAfter: anInteger.
     ^self at: anInteger + 1 put: anObject!
 add: newObject before: oldObject
         "Answer newObject.  Insert newObject immediately before
          the element oldObject in the receiver collection.  If
          oldObject is not in the collection, report an error."
     | index |
     index := 1.
     [index <= self size]
         whileTrue: [
             oldObject = (self at: index)
                 ifTrue: [^self add: newObject beforeIndex: index].
             index := index + 1].
     ^self errorAbsentElement!
 add: anObject beforeIndex: anInteger
         "Answer anObject.  Insert anObject at index position
          anInteger - 1 in the receiver collection.  If anInteger
          is out of the collection bounds, report an error."
     self putSpaceAfter: anInteger - 1.
     ^self at: anInteger put: anObject!
 addAllFirst: aCollection
         "Answer aCollection.  Add all the elements
          contained in aCollection to the receiver
          before its first element."
     | index |
     index := aCollection size.
     [index <= 0]
         whileFalse: [
             self addFirst: (aCollection at: index).
             index := index - 1].
     ^aCollection!
 addAllLast: aCollection
         "Answer aCollection.  Add all the elements
          contained in aCollection to the receiver
          after its last element."
     | index length |
     length := aCollection size.
     index := 1.
     [index <= length]
         whileTrue: [
             self addLast: (aCollection at: index).
             index := index + 1].
     ^aCollection!
 addFirst: anObject
         "Answer anObject.  Add anObject before the
          first element of the receiver."
     startPosition = 1
         ifTrue: [self putSpaceAtStart].
     startPosition := startPosition - 1.
     self basicAt: startPosition put: anObject.
     ^anObject!
 addLast: anObject
         "Answer anObject.  Add anObject after the
          last element of the receiver."
     endPosition = self basicSize
         ifTrue: [self putSpaceAtEnd].
     endPosition := endPosition + 1.
     ^self basicAt: endPosition put: anObject!
 after: anObject
         "Answer the element that immediately follows
          anObject in the receiver collection.  If anObject
          is not an element of the receiver, report an error."
     ^self
         after: anObject
         ifNone: [^self errorAbsentElement]!
 after: anObject ifNone: aBlock
         "Answer the element that immediately follows
          anObject in the receiver collection.  If anObject
          is not an element of the receiver, aBlock is
          evaluated (with no arguments)."
     | index |
     index := startPosition.
     [index < endPosition]
         whileTrue: [
             anObject = (self basicAt: index)
                 ifTrue: [^self basicAt: index + 1].
             index := index + 1].
     ^aBlock value!
 at: anInteger
         "Answer the element of the receiver at index
          position anInteger.  If anInteger is an invalid
          index for the receiver collection, report an error."
     | index |
     index := anInteger + startPosition - 1.
     (startPosition <= index and: [index <= endPosition])
         ifFalse: [
             ^self errorInBounds: anInteger].
     ^self basicAt: index!
 at: anInteger put: anObject
         "Answer anObject.  Replace the element of the
          receiver at index position anInteger with the
          anObject.  If anInteger is an invalid index
          for the receiver collection, report an error."
     | index |
     index := anInteger + startPosition - 1.
     (startPosition <= index and: [index <= endPosition])
         ifFalse: [
             ^self errorInBounds: anInteger].
     ^self basicAt: index put: anObject!
 before: anObject
         "Answer the element that immediately precedes
          anObject in the receiver collection.  If anObject
          is not an element of the receiver, report an error."
     ^self
         before: anObject
         ifNone: [^self errorAbsentElement]!
 before: anObject ifNone: aBlock
         "Answer the element that immediately precedes
          anObject in the receiver collection.  If anObject
          is not an element of the receiver, aBlock is
          evaluated (with no arguments)."
     | index |
     index := startPosition + 1.
     [index <= endPosition]
         whileTrue: [
             anObject == (self basicAt: index)
                 ifTrue: [^self basicAt: index - 1].
             index := index + 1].
     ^aBlock value!
 copyFrom: beginning to: end
         "Answer an OrderedCollection containing the
          elements of the receiver from index position
          beginning through index position end."
     | newCollection |
     (newCollection := OrderedCollection new: self size)
         startPosition: 1
         endPosition: end - beginning + 1.
     ^newCollection
         replaceFrom: 1
         to: end - beginning + 1
         with: self
         startingAt: beginning!
 do: aBlock
         "Answer the receiver.  For each element in the receiver,
          evaluate aBlock with that element as the argument."
     | index |
     index := startPosition - 1.
     [(index := index + 1) <= endPosition]
         whileTrue: [aBlock value: (self basicAt: index)]!
 errorAbsentElement
         "Private - Produce a walkback to the effect
          that the desired object was not in the collection."
     ^self error:
         'attempt to access absent element'!
 grow
         "Answer the receiver expanded in
          size to accomodate more elements."
     self growTo: self basicSize + self growSize!
 growTo: anInteger
         "Private - Answer the receiver expanded
          to accomodate anInteger number of elements."
     | newCollection length index |
     length := self size.
     newCollection := self species new: anInteger.
     index := 1.
     [ index <= length ]
         whileTrue: [
             newCollection
                 basicAt: index
                 put: (self at: index).
             index := index + 1].
     newCollection
         startPosition: 1
         endPosition: length.
     self become: newCollection!
 includes: anObject
         "Answer true if the receiver contains an element
          equal to anObject, else answer false."
     | index |
     index := startPosition - 1.
     [(index := index + 1) > endPosition]
         whileFalse: [
             anObject = (self basicAt: index)
                 ifTrue: [^true]].
     ^false!
 initPositions
         "Private - Answer the receiver after initializing
          it to be an empty OrderedCollection."
     startPosition := 1.
     endPosition := 0!
 putSpaceAfter: anInteger
         "Private - Answer the receiver with room for an
          element immediately after index position anInteger."
     | index |
     endPosition = self basicSize
         ifTrue: [self putSpaceAtEnd].
     anInteger = 0
         ifTrue: [
             startPosition = 1
                 ifTrue: [self putSpaceAtStart].
             startPosition := startPosition - 1.
             ^self].
     endPosition := endPosition + 1.
     index := self size - 1.
     [index > anInteger]
         whileTrue: [
             self
                 at: index + 1
                 put: (self at: index).
             index := index - 1]!
 putSpaceAtEnd
         "Private - Answer the receiver with room for more
          elements following the last element of the collection."
     | newCollection length index start |
     startPosition = 1
         ifTrue: [^self grow]
         ifFalse: [
             length := self size.
             start := startPosition // 2.
             index := 0.
             [index < length]
                 whileTrue: [
                     self
                         basicAt: start + index
                         put: (self basicAt: startPosition + index).
                     index := index + 1].
             startPosition := start.
             endPosition := startPosition + length - 1].
     index := self basicSize.
     [index > endPosition]
         whileTrue: [
             self basicAt: index put: nil.
             index := index - 1]!
 putSpaceAtStart
         "Private - Answer the receiver with room for more
          elements before the first element of the collection."
     | newCollection length index end |
     endPosition = self basicSize
         ifTrue: [self grow].
     length := self size.
     end := self basicSize + endPosition + 1 // 2.
     index := 0.
     [index < length]
         whileTrue: [
             self
                 basicAt: end - index
                 put: (self basicAt: endPosition - index).
             index := index + 1].
     startPosition := end - length + 1.
     endPosition := end.
     index := 1.
     [index < startPosition]
         whileTrue: [
             self basicAt: index put: nil.
             index := index + 1]!
 remove: anObject ifAbsent: aBlock
         "Answer anObject.  Remove the element anObject from
          the receiver collection.  If anObject is not an
          element of the receiver, aBlock is evaluated
          (with no arguments)."
     | index |
     index := startPosition.
     [index <= endPosition]
         whileTrue: [
             anObject = (self basicAt: index)
                 ifTrue: [
                     self removeIndex: index.
                     ^anObject].
             index := index + 1].
     ^aBlock value!
 removeFirst
         "Remove and answer the first element of the receiver.
          If the collection is empty, report an error."
     | answer |
     startPosition > endPosition
         ifTrue: [^self errorAbsentElement].
     answer := self basicAt: startPosition.
     self basicAt: startPosition put: nil.
     startPosition := startPosition + 1.
     ^answer!
 removeIndex: anInteger
         "Answer the receiver.  Remove the element of the receiver
          at index position anInteger.  If anInteger is an invalid
          index for the receiver, report an error."
     | index |
     (anInteger between: startPosition and: endPosition)
         ifFalse: [^self errorAbsentElement].
     index := anInteger.
     [index < endPosition]
         whileTrue: [
             self
                 basicAt: index
                 put: (self basicAt: index + 1).
             index := index + 1].
     self basicAt: endPosition put: nil.
     endPosition := endPosition - 1!
 removeLast
         "Remove and answer the last element of the receiver.
          If the collection is empty, report an error."
     | answer |
     startPosition > endPosition
         ifTrue: [^self errorAbsentElement].
     answer := self basicAt: endPosition.
     self basicAt: endPosition put: nil.
     endPosition := endPosition - 1.
     ^answer!
 replaceFrom: start to: stop with: aCollection
         "Answer a new OrderedCollection containing the
          receiver whose elements at index position start
          through stop have been replaced by the elements
          of aCollection."
     | finalSize length index |
     finalSize := self size + aCollection size -
         (stop - start + 1).
     length := aCollection size.
     finalSize > self basicSize
         ifTrue: [self growTo: finalSize + (finalSize // 3 + 10)].
     self
         startPosition: startPosition
         endPosition: self basicSize.
     self
         replaceFrom: start + length
         to: finalSize
         with: self
         startingAt: stop + 1.
     self
         replaceFrom: start
         to: start + length - 1
         with: aCollection
         startingAt: 1.
     self
         startPosition: startPosition
         endPosition: startPosition + finalSize - 1.
     index := endPosition + 1.
     [index <= self basicSize]
         whileTrue: [
             self basicAt: index put: nil.
             index := index + 1].
     ^self!
 size
         "Answer the number of elements contained by
          the receiver collection."
     ^endPosition - (startPosition - 1)!
 startPosition: start endPosition: end
         "Private - Answer the receiver.  Set the position
          of the first and last elements of the receiver,
          to the arguments start and stop respectively."
     startPosition := start.
     endPosition := end! !

! Process class methods !
 copyStack
         "Answer a Process object containing
          the current stack contents."
     <primitive: 108>!
 dropSenderChain
         "Discard stacked message sends (sent but not
          answered) to outermost send, the input request loop."
     <primitive: 109>! !

! Process methods !
 contextFor: framePointer
         "Private - Answer the context object
          from the stack frame at framePointer."
     ^self frameAt: framePointer + 5!
 frameAt: frameIndex
         "Private - Answer the stack entry of the receiver
          with frameIndex as original stack pointer."
     ^self at: (frameIndex + frameBias)!
 frameLinkAt: framePointer
         "Private - Answer the stack pointer of the stack
          frame which is sender of the message which created
          the stack frame identified by framePointer."
     ^self frameAt: framePointer + 1!
 homeFrameOf: framePointer
         "Private - Answer the stack pointer of the
          associated method frame for the block or
          method frame identified by framePointer."
     | context |
     context := self contextFor: framePointer.
     context == nil
         ifTrue: [^framePointer]
         ifFalse: [^context at: 2]!
 methodAt: framePointer
         "Private - Answer the compiled method for
          the stack frame at framePointer."
     ^self frameAt: framePointer + 4!
 receiverAt: framePointer
         "Private - Answer the receiver from
          the stack frame at framePointer."
     ^self frameAt: framePointer + 3!
 stackOverflow
         "Private - Pop-up a walkback window describing
          the stack overflow condition (too many
          stacked message sends).  This message is
          sent by the virtual machine."
     self walkBackFor: 'Stack Overflow'!
 walkBackFor: aString
         "Pop-up a walkback window with label equal
          to ('error: ', aString).  Display the stacked
          message sends for the receiver in the window."
     | logger recursing |
     recursing := RecursionInError.
     RecursionInError
         ifTrue: [
             logger := Terminal.
             logger cr; nextPutAll: 'error: ',aString; cr]
         ifFalse: [
             RecursionInError := true.
             logger := TextPane
                 loggerLabeled: aString
                 frame: (15@5 extent: 50@13)].
     self walkBackOn: logger.
     RecursionInError := false.
     recursing
         ifTrue: [^Methods exit: false]
         ifFalse:[
             logger
                 positionAtBeginning;
                 scheduleWindow]!
 walkBackOn: collector
         "Private - Display the stacked message sends for
          the receiver on the collector stream or TextEditor
          of a window."
     | limit assoc class frame |
     limit := 20.
     frame := topFrame.
     [frame := self frameLinkAt: frame.
      limit := limit - 1.
      limit < 0
         or: [frame = 0
             or: [assoc ~~ nil and: [assoc key == #Doit]]]]
         whileFalse: [
             (self homeFrameOf: frame) = frame
                 ifFalse: [collector nextPutAll: '[] in '].
             class := (self receiverAt: frame) class.
             class name first isUpperCase
                 ifTrue: [
                     collector nextPutAll: class name.
                     assoc := class selectorFor:
                         (self methodAt: frame).
                     assoc == nil
                         ifTrue: [
                             collector nextPutAll: '>>-unknown selector-']
                         ifFalse: [
                             assoc value = class
                                 ifFalse: [
                                     collector
                                         nextPut: $(;
                                         nextPutAll: assoc value name;
                                         nextPut: $)].
                             collector
                                 nextPutAll: '>>';
                                 nextPutAll: assoc key].
                     collector cr]]! !

! SortedCollection class methods !
 new: anInteger
         "Answer an instance of SortedCollection capable of
          holding anInteger number of elements sorted in
          ascending order"
     ^(super new: anInteger) sortBlock: [:a :b | a <= b]!
 sortBlock: aBlock
         "Answer an instance of SortedCollection capable of
          holding 10 elements sorted in the order defined by aBlock."
     ^(super new: 10) sortBlock: aBlock! !

! SortedCollection methods !
 add: anObject
         "Answer anObject.  Add anObject to the elements of the
          receiver following the sorting rules defined by the
          sortBlock instance variable."
     | index item |
     endPosition = self basicSize
         ifTrue: [self putSpaceAtEnd].
     index := endPosition.
     endPosition := endPosition + 1.
     [index < startPosition]
         whileFalse: [
             item := self basicAt: index.
             (sortBlock
                     value: anObject
                     value: item)
                 ifFalse: [
                     ^self basicAt: index + 1
                         put: anObject].
             self basicAt: index + 1 put: item.
             index := index - 1].
      ^self basicAt: index + 1 put: anObject!
 add: newObject after: oldObject
         "Add newObject after the element oldObject in the
          receiver.  This method reports an error since only
          the sortBlock can dictate the ordering of the elements."
     ^self invalidAdd!
 add: newObject before: oldObject
         "Add newObject before the element oldObject in the
          receiver.  This method reports an error since only
          the sortBlock can dictate the ordering of the elements."
     ^self invalidAdd!
 addAll: aCollection
         "Answer aCollection.  Add all the elements
          in aCollection to the receiver elements in
          the order dictated by sortBlock."
     aCollection do: [ :element |
         super addLast: element].
     self reSort.
     ^aCollection!
 addAllFirst: aCollection
         "Add all the elements of aCollection to the
          receiver before its first element.  This method
          reports an error since only the sortBlock can
          dictate the  ordering of the elements."
     ^self invalidAdd!
 addAllLast: aCollection
         "Add all the elements of aCollection to the
          receiver after its last element.  This method
          reports an error since only the sortBlock can
          dictate the  ordering of the elements."
     ^self invalidAdd!
 addFirst: anObject
         "Add anObject before the first element of the receiver.
          This method reports an error since only the sortBlock
          can dictate the ordering of the elements."
     ^self invalidAdd!
 addLast: anObject
         "Add anObject after the last element of the receiver.
          This method reports an error since only the sortBlock
          can dictate the ordering of the elements."
     ^self invalidAdd!
 at: anInteger put: anObject
         "Replace the element at index position anInteger
          in the receiver collection with anObject.  This
          method reports an error since only the sortBlock
          can dicatate the ordering of the elements."
     ^self invalidAdd!
 grow
         "Answer the receiver doubled in
          size to accomodate more elements."
     | block |
     block := sortBlock.
     super grow.
     sortBlock := block!
 invalidAdd
         "Private - Produce a walkback to the effect that an
          illegal add: was attempted on a SortedCollection."
     ^self error: 'use "add:" to extend a SortedCollection'!
 reSort
         "Answer the receiver collection of elements
          resorted according to sortBlock."
     self sort: startPosition to: endPosition!
 sort: lower to: upper
     | t terminate mid low up swapper i lastLow |
     low := lower.
     up := upper.
     [(terminate := (i := up - low) <= 1)
         ifTrue: [ "only 0, 1 or 2 elements"
             i = 1
                 ifTrue: [ "2 elements"
                     (sortBlock
                         value: (i := self basicAt: up)
                         value: (swapper := self basicAt: low))
                         ifTrue: [ "exchange"
                             self basicAt: low put: i.
                             self basicAt: up put: swapper]]]
         ifFalse: [
             mid := low + up // 2.
             t := self basicAt: mid.
             self basicAt: mid put: (self basicAt: low).
             i := lastLow := low.
             [i := i + 1.
             (sortBlock value: (self basicAt: i)
                     value: t)
                 ifTrue: [
                     (lastLow := lastLow + 1) = i
                         ifFalse: [
                             swapper := self basicAt: i.
                             self basicAt: i
                                 put: (self basicAt: lastLow).
                             self basicAt: lastLow
                                 put: swapper]].
             i < up]
                 whileTrue: [].
             self basicAt: low put: (self basicAt: lastLow).
             self basicAt: lastLow put: t.
             mid < lastLow
                 ifTrue: [
                     self sort: lastLow + 1 to: up.
                     up := lastLow - 1]
                 ifFalse: [
                     self sort: low to: lastLow - 1.
                     low := lastLow + 1]].
     terminate]
         whileFalse: []!
 sortBlock
         "Answer the sorting block of code for the receiver."
     ^sortBlock!
 sortBlock: aBlock
         "Answer the receiver.  Set the sorting block of code
          for the receiver to aBlock and resort the receiver."
     sortBlock := aBlock.
     self reSort! !

! Set class methods !
 new
         "Answer a new object capable
          of containing 4 elements."
     ^self new: 4!
 new: anInteger
         "Answer a new object capable of containing 1 or
          anInteger number of elements whichever is more."
     ^(self basicNew: ( 1 max: anInteger)) init! !

! Set methods !
 add: anObject
         "Answer anObject.  Add anObject to the receiver
          if the receiver does not already contain it."
     | index |
     anObject == nil
         ifTrue: [^anObject].
     self adjustSize.
     (self basicAt:
         (index := self findElementIndex: anObject)) == nil
             ifTrue: [
                 elementCount := elementCount + 1.
                 ^self basicAt: index put: anObject].
     ^anObject!
 adjustSize
         "Answer the receiver.  If the receiver set is
          getting full, expand it to accomodate more objects."
     (elementCount * 10) >= (self basicSize - 2 * 9)
         ifTrue: [^self grow]!
 at: anInteger
         "Access the element at index position anInteger
          in the receiver collection.  This method reports
          an error since sets cannot be indexed."
     ^self errorNotIndexable!
 at: anInteger put: anObject
         "Replace the element at index position anInteger
          in the receiver collection with anObject.  This
          method reports an error since sets are not indexable."
     ^self errorNotIndexable!
 do: aBlock
         "Answer the receiver.  For each element in the receiver,
          evaluate aBlock with that element as the argument."
     | index element |
     index := self basicSize.
     [index > 0]
         whileTrue: [
             (element := self basicAt: index) == nil
                 ifFalse: [aBlock value: element].
             index := index - 1]!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner.  The receiver is first
          rehashed to a CloneSet, a class created during
          the cloning process."
     | clone |
     clone := aCloner newCloneSet.
     self do: [ :element | clone add: element].
     aCloner dump: clone on: aStream for: self class!
 find: anObject ifAbsent: aBlock
         "Private - Answer the index position of anObject
          in the receiver.  If anObject is not in the receiver,
           evaluate aBlock (with no arguments)."
     | index |
     (self basicAt:
         (index := self findElementIndex: anObject)) == nil
             ifTrue:  [^aBlock value]
             ifFalse: [^index]!
 findElementIndex: anObject
         "Answer the index position of anObject in the
          receiver or the first empty element position."
     | index indexedObject lastIndex |
     lastIndex := self basicSize.
     index := anObject hash \\ lastIndex + 1.
     [(indexedObject := self basicAt: index) = anObject]
         whileFalse: [
             (indexedObject == nil)
                 ifTrue: [^index].
             (index := index + 1) > lastIndex
                 ifTrue: [ "index wraparound"
                     index := 1]].
     ^index!
 grow
         "Answer the receiver expanded
          to accomodate more elements."
     | newSet |
     newSet := self species new: self basicSize * 4 // 3 + 10.
     self do: [:element | newSet add: element].
     ^self become: newSet!
 includes: anObject
         "Answer true if the receiver includes anObject
          as one of its elements, else answer false."
     ^((self basicAt:
         (self findElementIndex: anObject)) == nil) not!
 init
         "Private - Initialize the instance variable
          elementCount to zero, describing an empty Set."
     elementCount := 0!
 occurrencesOf: anObject
         "Answer 1 if the receiver includes anObject as
          one of its elements, else answer zero."
     (self includes: anObject)
         ifTrue:  [^1].
     ^0!
 rehashFrom: anInteger
         "Private - Rehash the receiver from the index
          position anInteger to the last index position."
     | deleteIndex lastIndex searchIndex testObject |
     lastIndex := self basicSize.
     deleteIndex := anInteger.
     [(deleteIndex := deleteIndex + 1) > lastIndex
         ifTrue: [ "index wraparound"
             deleteIndex := 1].
     (testObject := self basicAt: deleteIndex) == nil]
         whileFalse: [ "test next object for relocation"
             searchIndex := self findElementIndex: testObject.
             (self basicAt: searchIndex) == nil
                 ifTrue: [ "found object to move"
                     self basicAt: searchIndex
                         put: testObject.
                     self basicAt: deleteIndex
                         put: nil]]!
 remove: anObject ifAbsent: aBlock
         "Answer anObject.  Remove the element anObject from
          the receiver collection.  If anObject is not an
          element of the receiver, aBlock is evaluated
          (with no arguments)."
     | index |
     index := self findElementIndex: anObject.
     (self basicAt: index) == nil
         ifTrue: [^aBlock value].
     self basicAt: index put: nil.
     elementCount := elementCount - 1.
     self rehashFrom: index.
     ^anObject!
 size
         "Answer the number of elements contained by
          the receiver collection."
     ^elementCount! !

! Dictionary class methods ! !

! Dictionary methods !
 add: anAssociation
         "Answer anAssociation.  Add anAssociation to the
          receiver dictionary (hash is by the key of
          anAssociation)."
     | index element |
     index := self findKeyIndex: anAssociation key.
     (element := self basicAt: index) == nil
         ifTrue: [
             elementCount := elementCount + 1.
             self basicAt: index put: anAssociation]
         ifFalse: [element value: anAssociation value].
     self adjustSize.
     ^anAssociation!
 associationAt: aKey
         "Answer the Association whose key equals aKey
          from the receiver dictionary.  If not found,
          report an error."
     ^self
         associationAt: aKey
         ifAbsent: [self errorAbsentKey]!
 associationAt: aKey ifAbsent: aBlock
         "Answer the Association whose key equals aKey
          from the receiver dictionary.  If not found,
          evaluate aBlock (with no arguments)."
     | index |
     index := self
         findKey: aKey
         ifAbsent: [^aBlock value].
     ^self basicAt: index!
 associationsDo: aBlock
         "Answer the receiver.  For each key/value pair
          in the receiver, evaluate aBlock with that
          pair as the argument."
     super do: aBlock!
 at: aKey
         "Answer the value of the key/value pair whose key
          equals aKey from the receiver dictionary.  If
          not found, report an error."
     ^self
         at: aKey
         ifAbsent: [self errorAbsentKey]!
 at: aKey ifAbsent: aBlock
         "Answer the value of the key/value pair whose key
          equals aKey from the receiver dictionary.  If
          not found, evaluate aBlock (with no arguments)."
     ^(self basicAt:
         (self findKey: aKey ifAbsent: [^aBlock value]))
             value!
 at: aKey put: anObject
         "Answer anObject.  If the receiver dictionary contains
          the key/value pair whose key equals aKey, replace the
          value of the pair with anObject.  Else
          add the aKey/anObject pair."
     self add: (Association key: aKey value: anObject).
     ^anObject!
 do: aBlock
         "Answer the receiver.  For each key/value pair
          in the receiver, evaluate aBlock with
          the value as the argument."
     super do: [ :association |
         aBlock value: association value]!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner.  The receiver is first
          rehashed to a CloneDictionary, a class created
          during the cloning process."
     | clone |
     clone := aCloner newCloneDictionary: self basicSize.
     self associationsDo: [ :assoc | clone add: assoc].
     aCloner dump: clone on: aStream for: self class!
 errorAbsentKey
         "Private - Report an error to the effect
          that the desired key was not found in the receiver
          dictionary."
     self error: 'Key is missing'!
 findKey: aKey ifAbsent: aBlock
         "Private - Answer the index position of the
          key/value pair whose key equals aKey.  If not
          found, evaluate aBlock (with no arguments)."
     | index |
     (self basicAt: (index := self findKeyIndex: aKey)) == nil
         ifTrue:  [^aBlock value]
         ifFalse: [^index]!
 findKeyIndex: aKey
         "Private - Answer the index position of the
          key/value pair in the receiver whose key equals
          aKey or the index of the first empty position
          where such an pair would be stored."
     | index indexedAssoc lastIndex |
     lastIndex := self basicSize.
     index := aKey hash \\ lastIndex + 1.
     [((indexedAssoc := self basicAt: index) == nil)
         or: [aKey = indexedAssoc key]]
             whileFalse: [
                 (index := index + 1) > lastIndex
                     ifTrue: [ "index wraparound"
                         index := 1]].
     ^index!
 grow
         "Answer the receiver doubled in
          size to accomodate more key/value
          pairs."
     | newDictionary |
     newDictionary := self class new: self basicSize * 2.
     self associationsDo: [ :assoc |
         newDictionary add: assoc].
     ^self become: newDictionary!
 includes: anObject
         "Answer true if the receiver contains the
          key/value pair whose value equals anObject,
          else answer false."
     self do: [ :element |
         element = anObject
             ifTrue: [^true]].
     ^false!
 includesAssociation: anAssociation
         "Answer true if the receiver contains
          anAssociation, else answer false."
     ^anAssociation value =
         (self at: anAssociation key ifAbsent: [^false])!
 includesKey: aKey
         "Answer true if the receiver contains
          the key/value pair whose key equals aKey,
          else answer false."
     self findKey: aKey ifAbsent: [^false].
     ^true!
 inspect
         "Open an inspector window on the receiver."
     DictionaryInspector new openOn: self!
 keyAtValue: anObject
         "Answer the key of the the key/value pair
          in the receiver whose value equals
          anObject.  If not found, answer nil."
     ^self keyAtValue: anObject ifAbsent: [^nil]!
 keyAtValue: anObject ifAbsent: aBlock
         "Answer the key of the key/value pair in the
          receiver whose value equals anObject.  If
          not found, evaluate aBlock (with no arguments)."
     self associationsDo: [ :assoc |
         assoc value = anObject
             ifTrue: [^assoc key]].
     ^aBlock value!
 keys
         "Answer a Set containing all the keys of the
          key/value pair in the receiver dictionary."
     | answer |
     answer := Set new: self size * 2.
     self associationsDo: [ :assoc |
         answer add: assoc key].
     ^answer!
 keysDo: aBlock
         "Answer the receiver.  For each key/value pair
          in the receiver, evaluate aBlock with
          the key as the argument."
     self associationsDo: [ :assoc |
         aBlock value: assoc key]!
 occurrencesOf: anObject
         "Answer the number of key/value pairs in the receiver,
          whose values are equal to anObject."
     | answer |
     answer := 0.
     self do: [ :element |
         element = anObject
             ifTrue:  [answer := answer + 1]].
     ^answer!
 rehashFrom: anInteger
         "Private - Rehash the key/value pairs of the receiver
          (based on the keys) from the index position anInteger
          to the last index position."
     | deleteIndex lastIndex searchIndex testAssoc |
     lastIndex := self basicSize.
     deleteIndex := anInteger.
     [(deleteIndex := deleteIndex + 1) > lastIndex
         ifTrue: [ "index wraparound"
             deleteIndex := 1].
     (testAssoc := self basicAt: deleteIndex) == nil]
         whileFalse: [ "test next assoc for relocation"
             searchIndex := self findKeyIndex: testAssoc key.
             (self basicAt: searchIndex) == nil
                 ifTrue: [ "found assoc to move"
                     self basicAt: searchIndex
                         put: testAssoc.
                     self basicAt: deleteIndex
                         put: nil]]!
 remove: anObject ifAbsent: aBlock
         "Remove the key/value pair whose value is anObject
          from the receiver dictionary.  This method
          reports an error since the values are
          not unique in a dictionary, the keys are."
     ^self invalidMessage!
 removeAssociation: anAssociation
         "Answer the receiver after anAssociation has
          been removed from it.  If anAssociation is not in the
          receiver, report an error."
     self removeKey: anAssociation key!
 removeKey: aKey
         "Answer the receiver without the key/value pair whose
          key equals aKey.  If such a pair is not found,
          report an error."
     self
         removeKey: aKey
         ifAbsent: [self errorAbsentKey]!
 removeKey: aKey ifAbsent: aBlock
         "Answer aKey.  Remove the key/value pair whose key
          equals aKey from the receiver.  If such a pair
          is not found, evaluate aBlock (with no arguments)."
     | index |
     index := self
         findKey: aKey
         ifAbsent: [^aBlock value].
     self basicAt: index put: nil.
     elementCount := elementCount - 1.
     self rehashFrom: index.
     ^aKey!
 select: aBlock
         "For each key/value pair in the receiver, evaluate
          aBlock with the value part of the pair as the argument.
          Answer a new object containing those key/value pairs
          for which aBlock evaluates to true."
     | answer |
     answer := self species new.
     self associationsDo: [ :each |
         (aBlock value: each value)
             ifTrue: [answer add: each]].
     ^answer!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reinstantiated."
     | firstTime |
     firstTime := true.
     aStream
         nextPutAll: '((';
         nextPutAll: self class name;
         nextPutAll: ' new)'.
     self associationsDo: [ :assoc |
         firstTime
             ifFalse: [aStream nextPut: $;].
         aStream
             cr;
             nextPutAll: 'add: ('.
         assoc storeOn: aStream.
         aStream nextPut: $).
         firstTime := false].
     firstTime
         ifFalse: [aStream nextPutAll: ';yourself'].
     aStream nextPut: $)!
 values
         "Answer a Bag containing all the values of the
          key/value pairs in the receiver dictionary."
     | answer |
     answer := Bag new.
     self associationsDo: [ :assoc |
         answer add: assoc value].
     ^answer! !

! IdentityDictionary class methods !
 initialSize
         "Private - Answer the initial number of elements
          (8) that a new instance of IdentityDictionary can
          contain."
     ^8!
 new
         "Answer an initialized instance of the
          receiver class."
     ^(super new: self initialSize) setValueArray!
 new: anInteger
         "Create and initialize an instance of the receiver
          class able to contain anInteger number of elements.
          This method reports an error since the size of an
          instance of IdendityDictionary must be a power of 2."
     ^self invalidMessage!
 newSize: anInteger
         "Private - Answer an initialized instance of
          IdentityDictionary capable of containing anInteger
          number of elements."
     ^(super new: anInteger) setValueArray! !

! IdentityDictionary methods !
 add: anAssociation
         "Answer anAssociation.  Add the key/value pair of
          anAssociation to the receiver."
     self
         at: anAssociation key
         put: anAssociation value.
     ^anAssociation!
 associationAt: aKey ifAbsent: aBlock
         "Answer an Association, with aKey and its
          corresponding value if aKey exists in the
          receiver, else evaluate aBlock (with no arguments)."
     | index |
     index := self
         findKey: aKey
         ifAbsent: [^aBlock value].
     ^Association
         key: (self basicAt: index)
         value: (valueArray basicAt: index)!
 associationsDo: aBlock
         "Answer the receiver.  For each key/value pair of
          objects in the receiver, create an instance of
          Association with the key/value pair, and evaluate
          aBlock with that association as the argument."
     1 to: self basicSize do: [ :index |
         (self basicAt: index) == nil
             ifFalse: [
                 aBlock value:
                     (Association
                         key: (self basicAt: index)
                         value: (valueArray basicAt: index))]]!
 at: aKey ifAbsent: aBlock
         "Answer the value corresponding to aKey in the
          receiver.  If aKey is not in the receiver, evaluate
          aBlock (with no arguments)."
     | index |
     index := self
         findKey: aKey
         ifAbsent: [^aBlock value].
     ^valueArray basicAt: index!
 at: aKey put: anObject
         "Answer anObject.  If aKey exists in the receiver,
          replace the corresponding value with anObject, else
          add the aKey/anObject pair to the receiver."
     | index |
     index := self findKeyIndex: aKey.
     (self basicAt: index) == nil
         ifTrue: [
             elementCount := elementCount + 1.
             self basicAt: index put: aKey.
             valueArray basicAt: index put: anObject.
             self adjustSize]
         ifFalse: [valueArray basicAt: index put: anObject].
     ^anObject!
 do: aBlock
         "Answer the receiver.  For each value
          in the receiver, evaluate aBlock with
          that value as the argument."
     1 to: self basicSize do: [ :index |
         (self basicAt: index) == nil
             ifFalse: [
                 aBlock value:
                     (valueArray basicAt: index)]]!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner.  The receiver is first
          rehashed to a CloneIdentityDictionary, a
          class created during the cloning process."
     | clone |
     clone := aCloner newCloneIdentityDictionary: self basicSize.
     self associationsDo: [ :assoc | clone add: assoc].
     aCloner dump: clone on: aStream for: self class!
 findKey: aKey ifAbsent: aBlock
         "Private - Answer the index position of the aKey in
          the receiver.  If not found, evaluate aBlock (with
          no arguments)."
     | index |
     (self basicAt: (index := self findKeyIndex: aKey)) == nil
         ifTrue: [^aBlock value]
         ifFalse: [^index]!
 findKeyIndex: aKey
         "Private - Answer the index position of the
          key/value pair in the receiver whose key is
          aKey or the index of the first empty position
          where such a pair would be stored."
     | index lastIndex |
     lastIndex := self basicSize.
     index := (aKey basicHash bitAnd: lastIndex - 1) + 1.
     [aKey == (self basicAt: index)]
         whileFalse: [
             (self basicAt: index) == nil
                 ifTrue: [^index].
             (index := index + 1) > lastIndex
                 ifTrue: [ "index wraparound"
                     index := 1]].
     ^index!
 grow
         "Answer the receiver doubled in size to
          accomodate more key/value pairs of objects."
     | newDictionary |
     newDictionary := self species
         newSize: self basicSize * 2.
     self associationsDo: [ :assoc |
         newDictionary add: assoc].
     ^self become: newDictionary!
 includesKey: aKey
         "Answer true if the receiver contains aKey,
          else answer false."
     self findKey: aKey ifAbsent: [^false].
     ^true!
 keyAtValue: anObject ifAbsent: aBlock
         "Answer the key (in the receiver) whose paired value
          equals anObject.  If not found, evaluate aBlock
          (with no arguments)."
     1 to: self basicSize do: [ :index |
         (valueArray basicAt: index) = anObject
             ifTrue: [
                 (self basicAt: index) == nil
                     ifFalse: [^self basicAt: index]]].
     ^aBlock value!
 keys
         "Answer a Set containing all the keys
          of the key/value pairs of the receiver."
     | answer |
     answer := Set new: self size * 2.
     1 to: self basicSize do: [ :index |
         (self basicAt: index) == nil
             ifFalse: [answer add: (self basicAt: index)]].
     ^answer!
 rehashFrom: anInteger
         "Private - Rehash the key/value pairs of the receiver
          (based on the keys) from the index position anInteger
          to the last index position."
     | deleteIndex lastIndex searchIndex object |
     lastIndex := self basicSize.
     deleteIndex := anInteger.
     [(deleteIndex := deleteIndex + 1) > lastIndex
         ifTrue: [ "index wraparound"
             deleteIndex := 1].
     (object := self basicAt: deleteIndex) == nil]
         whileFalse: [ "test next key for relocation"
             searchIndex := self findKeyIndex: object.
             (self basicAt: searchIndex) == nil
                 ifTrue: [ "found key to move"
                     self        "move key"
                         basicAt: searchIndex
                         put: (self basicAt: deleteIndex).
                     self        "delete old key"
                         basicAt: deleteIndex
                         put: nil.
                     valueArray  "move value"
                         basicAt: searchIndex
                         put: (valueArray basicAt: deleteIndex).
                     valueArray  "delete old value"
                         basicAt: deleteIndex
                         put: nil]]!
 removeKey: aKey ifAbsent: aBlock
         "Answer aKey.  Remove the key/value pair whose key
          is aKey from the receiver.  If aKey is not in the
          receiver, evaluate aBlock (with no arguments)."
     | index |
     index := self
         findKey: aKey
         ifAbsent: [^aBlock value].
     self basicAt: index put: nil.
     valueArray basicAt: index put: nil.
     elementCount := elementCount - 1.
     self rehashFrom: index.
     ^aKey!
 setValueArray
         "Private - Initialize the instance variable
          valueArray."
     valueArray := Array new: self basicSize!
 values
         "Answer all the values of the key/value pairs
          contained in the receiver as a Bag."
     ^valueArray asBag! !

! MethodDictionary class methods ! !

! MethodDictionary methods !
 add: anAssociation
         "Answer anAssociation.  Add anAssociation to
          the receiver MethodDictionary.  Flush the
          method cache in case an old method has changed."
     super add: anAssociation.
     self flushCache.
     ^anAssociation!
 at: aSymbol put: aMethod
         "Answer aMethod.  Enter aSymbol and
          aMethod as a key/value pair in the
          receiver MethodDictionary.  Flush the
          method cache in case an old method
          has changed."
     super at: aSymbol put: aMethod.
     self flushCache.
     ^aMethod!
 flushCache
         "Private - Flush the method cache so that method
          lookup uses the most current method dictionaries."
     <primitive: 113>!
 removeKey: aSymbol ifAbsent: aBlock
         "Answer aSymbol.  Remove entry with key
          aSymbol from the receiver dictionary.  If
          aSymbol is not a key of the receiver,
          evaluate aBlock (with no arguments).
          Flush the method cache."
     | newDictionary |
     (self includesKey: aSymbol)
         ifFalse: [^aBlock value].
     newDictionary := self species new.
     self keysDo: [ :key |
         key == aSymbol
             ifFalse: [
                 newDictionary
                     at: key put: (self at: key)]].
     self become: newDictionary.
     self flushCache.
     ^aSymbol! !

! SystemDictionary class methods ! !

! SystemDictionary methods !
 add: anAssociation
         "Answer anAssociation.  Add anAssociation to
          receiver dictionary.  Ensure that the key
          is a symbol."
     Symbol mustBeSymbol: anAssociation key.
     ^super add: anAssociation!
 at: aSymbol put: anObject
         "Answer anObject.  Enter anObject at key
          aSymbol in the receiver dictionary.  Ensure
          that aSymbol is a symbol."
     Symbol mustBeSymbol: aSymbol.
     ^super at: aSymbol put: anObject!
 compressChanges
         "Build a new change log file retaining
          only the latest version of changed
          methods in the current change log.
          Save the image to the image file."
     | logDirectory stream tempLogName |
     Display background.
     'Compressing the change log file...'
         displayAt: 8 @ 9.
     'CAUTION:'
         displayAt: 8 @ 12.
     'Please do not interrupt this process with Control-Break'
         displayAt: 15 @ 13.
     'because this will make the change log inconsistent with'
         displayAt: 15 @ 14.
     'the image.'
         displayAt: 15 @ 15.
     logDirectory := (Sources at: 2) file directory.
     stream := logDirectory newFile: 'ChangLog.tmp'.
     stream lineDelimiter: Lf.
     tempLogName := stream pathName.
     self getSourceClasses do: [ :class |
         self compressChangesOf: class class into: stream.
         self compressChangesOf: class into: stream].
     stream close.
     File remove: (Sources at: 2) pathName.
     File
         rename: tempLogName
         to: (Sources at: 2) pathName.
     Sources
         at: 2
         put: (logDirectory file: (Sources at: 2) file name).
     Scheduler systemDispatcher save!
 compressChangesOf: aClass into: aStream
         "Private - Write latest version of all methods
          in aClass that are in the change log to aStream."
     | method |
     aClass selectors asSortedCollection do: [ :s |
         method := aClass compiledMethodAt: s.
         method sourceIndex = 2
             ifTrue: [
                 self putHeaderOf: aClass into: aStream.
                 self
                     putMethod: method
                     withIndex: 2
                     to: aStream.
                 aStream nextPutAll: ' !!']]!
 compressSources
         "Build a new source file which contains
          the latest version of all methods.
          Build a zero length change log file.
          Save the image to the image file."
     | compressionDictionary sourceDirectory stream tempSourceName crm |
     Display background.
     'Compressing the source file...'
         displayAt: 8 @ 9.
     'CAUTION:'
         displayAt: 8 @ 12.
     'Please do not interrupt this process with Control-Break'
         displayAt: 15 @ 13.
     'because this will make the source file inconsistent with'
         displayAt: 15 @ 14.
     'the image.'
         displayAt: 15 @ 15.
     File remove: (Disk file: 'image') pathName.
     compressionDictionary := Dictionary new.
     1 to: 127 do: [ :index |
         compressionDictionary add:
             (Association
                 key: (DecompressionArray at: index)
                 value: index + 128)].
     Methods at: #CompressionDictionary put: compressionDictionary.
     crm := 'Copyright 1984 Digitalk Inc.  All rights reserved'.
     stream := Disk newFile: 'Sources.new'.
     stream lineDelimiter: Lf.
     stream nextPutAll: crm.
     self getSourceClasses do: [ :class |
         self compressSourcesOf: class class into: stream.
         self compressSourcesOf: class into: stream].
     stream nextPutAll: crm.
     stream close.
     Methods removeKey: #CompressionDictionary.
     sourceDirectory := (Sources at: 1) file directory.
     File remove: (Sources at: 1) pathName.
     Disk drive == sourceDirectory drive
         ifTrue: [
             File
                 rename: stream pathName
                 to: (Sources at: 1) pathName]
         ifFalse: [
             File
                 copy: stream pathName
                 to: (Sources at: 1) pathName.
             File remove: stream pathName].
     Sources
         at: 1
         put: (sourceDirectory file: (Sources at: 1) file name).
     File remove: (Sources at: 2) pathName.
     Sources at: 2 put:
         ((Sources at: 2) file directory
             file: (Sources at: 2) file name).
     (Sources at: 2) lineDelimiter: Lf.
     Scheduler systemDispatcher save!
 compressSourcesOf: aClass into: aStream
         "Private - Write latest version of all methods
          in aClass to aStream."
     self putHeaderOf: aClass into: aStream.
     aClass selectors asSortedCollection do: [ :s |
         self
             putMethod: (aClass compiledMethodAt: s)
             withIndex: 1
             to: aStream].
     aStream nextPutAll: ' !!'!
 controlBreak
         "Initiate a control-break walkback.
          Pressing control and break keys causes
          the virtual machine to interrupt
          processing and send this message."
     RecursionInError := false.
     self error: 'user interrupt'!
 exit: aBoolean
         "Terminate Methods and exit to DOS.
          If aBoolean is true, clear the screen
          upon exit, else leave screen as is."
     <primitive: 114>!
 getSourceClasses
         "Answer an OrderedCollection of all
          classes in hierarchical order."
     | classes |
     classes := OrderedCollection new.
     classes add: Object.
     Object allSubclasses do: [ :c |
         c name trimBlanks isEmpty
             ifFalse: [classes add: c]].
     ^classes!
 implementorsOf: symbol
         "Pop-up a window with the implementors
          of the selectedMethod."
     | logger classes |
     logger := TextPane
         loggerLabeled: 'Implementors of ', symbol
         frame: (50@15 extent: 30@10).
     logger topDispatcher
         display;
         flashLabel.
     classes := Class allClasses.
     classes addAll: (classes collect: [ :c | c class]).
     (classes select: [ :c |
          c methodDictionary includesKey: symbol])
             do: [ :c | logger nextPutAll: c name; cr].
     logger positionAtBeginning.
     logger topDispatcher
         unflashLabel;
         scheduleWindow!
 logEvaluate: aString
         "Append 'evaluate' followed by aString (in
          chunk format) to the change log."
     (Sources at: 2)
         setToEnd;
         cr;
         cr;
         nextPutAll: '"evaluate"';
         nextChunkPut: aString trimBlanks!
 logSource: aString forClass: aClass
         "Append the class definition message
          aString for aClass to the change log."
     (Sources at: 2)
         setToEnd;
         cr;
         cr;
         nextPutAll: '"define class"';
         nextChunkPut: aString;
         flush!
 logSource: aString forSelector: aSymbol inClass: aClass
         "Append the source code aString to the
          change log for method with selector
          aSymbol in aClass.  Make compiled
          method point to source in change log."
     | changeLog |
     changeLog := Sources at: 2.
     changeLog
         setToEnd;
         cr;
         cr;
         nextPut: $!!;
         nextPutAll: aClass name , ' methods !!'.
     (aClass compiledMethodAt: aSymbol) sourceString: aString.
     changeLog
         setToEnd;
         nextChunkPut: String new;
         flush!
 putHeaderOf: aClass into: aStream
         "Private - Put a header for aClass which
          identifies the class of the following
          methods to aStream."
     aStream
         cr;
         cr;
         nextPutAll: '!! '
             , aClass name
             , ' methods !!'!
 putMethod: aCompiledMethod withIndex: anInteger to: aStream
         "Private - Append the source code for
          aCompiledMethod to aStream.  anInteger
          identifies the file number: 1 = source
          file; 2 = change log."
     | methodIndex methodPosition source |
     (source := aCompiledMethod source) == nil
         ifTrue: [^nil].
     methodIndex := aCompiledMethod sourceIndex.
     aCompiledMethod
         sourceIndex: anInteger
         sourcePosition: aStream position + 1.
     (anInteger = 1 and: [methodIndex = 2])
         ifTrue: [source := CompiledMethod compress: source].
     aStream nextChunkPut: source!
 save
         "Save image on image file.  Answer an
          integer DOS error code (negative means
          an error)."
     <primitive: 17>!
 sendersOf: aSymbol
         "Pop-up a window with the senders of
          messages with selector aSymbol."
     | classes logger impliedCode |
     logger := TextPane
         loggerLabeled: 'Senders of ', aSymbol printString
         frame: (40@0 extent: 40@13).
     logger topDispatcher
         display;
         flashLabel.
     impliedCode := aSymbol codeFor.
     classes := Class allClasses.
     classes addAll:
         (classes collect: [ :c | c class]).
     classes do: [ :c |
         c methodDictionary associationsDo: [ :m |
             (m value includes: aSymbol with: impliedCode)
                 ifTrue: [
                     logger
                         nextPutAll: c name;
                         tab;
                         nextPutAll: m key;
                         cr]]].
     logger positionAtBeginning.
     logger topDispatcher
         unflashLabel;
         scheduleWindow!
 startUp
         "Initiate a Methods session by filing
          in the 'go' file.  This message is sent
          by the virtual machine."
     Disk := Directory current.
     (Disk file: 'go') fileIn;  close.
     Scheduler resume!
 unusedMemory
         "Answer an integer which is the number of
          bytes of unused memory available for
          object storage."
     <primitive: 112>! !

! SymbolSet class methods !
 setUpSymbolTable
         "Rehash the symbol table, an instance
          of SymbolSet.  Answer the symbol table."
     ^(super new: 1024) becomeSymbolTable! !

! SymbolSet methods !
 add: aSymbol
         "Private - Add aSymbol to the receiver collection."
     Symbol mustBeSymbol: aSymbol.
     ^super add: aSymbol!
 becomeSymbolTable
         "Private - Reconstruct the symbol table by
          copying all its elements to the receiver
          and turning the receiver into the symbol
          table."
     | oldSymbolTable |
     oldSymbolTable := Symbol symbolTable.
     oldSymbolTable do: [ :symbol |
         self add: symbol].
     oldSymbolTable become: self.
     ^oldSymbolTable!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner."
     aCloner
         symbolSetPosition: aStream position;
         dump: (self class new: self basicSize) on: aStream!
 findElementIndex: anObject
         "Private - Answer the index of anObject in
          the receiver.  If anObject is not present,
          answer the index of a nil entry where
          anObject may be stored."
     | index indexedObject lastIndex |
     lastIndex := self basicSize.
     index := anObject stringHash \\ lastIndex + 1.
     [(indexedObject := self basicAt: index) == nil
         ifTrue: [^index].
     indexedObject equals: anObject]
         whileFalse: [
             (index := index + 1) > lastIndex
                 ifTrue: [ "index wraparound"
                     index := 1]].
     ^index! !

! Compiler class methods ! !

! Compiler methods ! !

! Context class methods ! !

! Context methods !
 value
         "Answer the result of evaluating the no argument
          block described by the receiver."
     ^self value!
 value: anObject
         "Answer the result of evaluating the one argument
          block described by the receiver."
     ^self value: anObject!
 value: arg1 value: arg2
         "Answer the result of evaluating the two argument
          block described by the receiver."
     <primitive: 81>
     ^self primitiveFail!
 whileFalse: aBlock
         "Repetitively evaluate the receiver block and aBlock,
          until the result of receiver block evaluation is
          true.  Answer nil."
     self value
         ifFalse: [
             aBlock value.
             self whileFalse: aBlock].
     ^nil!
 whileTrue: aBlock
         "Repetitively evaluate the receiver block and aBlock,
          until the result of receiver block evaluation is
          false.  Answer nil."
     self value
         ifTrue: [
             aBlock value.
             self whileTrue: aBlock].
     ^nil! !

! CursorManager class methods !
 new
         "Answer a CursorManager containing
          the current cursor position."
     ^(super new) setOffset! !

! CursorManager methods !
 cursorPrimWith: arg1 function: anInteger
         "Private -  This is the cursor (keyboard/mouse)
          interface primitive.  The value of
          arg1 is either a Point or nil depending on the
          function (defined by anInteger) desired."
     <primitive: 102>
     ^self primitiveFailed!
 display
         "Set the cursor position to the point defined by the
          instance variable offset.  Answer the receiver."
     self cursorPrimWith: offset function: 4!
 down
         "Move the cursor down by one character position
          unless it is already on the bottom line
          of the display screen.  Answer the receiver."
     offset := self sense.
     (Display offset y + Display height) <= (offset y + 1)
         ifFalse:[offset y: offset y + 1].
     self display!
 hide
         "Make the cursor invisible on the display screen.
          This method will be ignored unless the system is
          being used with a mouse.  Answer the receiver."
     self cursorPrimWith: nil function: 2!
 isThereInput
         "Answer true if there is input from the mouse or
          keyboard waiting to be processed, else answer false."
     ^self cursorPrimWith: nil function: 5!
 jumpDown
         "Tab the cursor down to the next vertical tab position
          (vertical tabs are set every four lines from the
          top line of the display screen).  Answer the receiver."
     offset := self sense.
     (Display offset y + Display height) <= (offset y + 4)
         ifTrue: [offset y: Display offset y + Display height - 1]
         ifFalse: [offset y: (offset y // 4) * 4 + 4].
     self display!
 jumpLeft
         "Tab the cursor left to the previous horizontal tab position
          (horizontal tabs are set every eight character positions
          from the left of the display screen).  Answer the receiver."
     offset := self sense.
     (offset x - 8) < (Display offset x)
         ifTrue: [offset x: Display offset x]
         ifFalse: [offset x: (offset x - 1// 8) * 8].
     self display!
 jumpRight
         "Tab the cursor right to the next horizontal tab position
          (horizontal tabs are set every eight character positions
          from the left of the display screen).  Answer the receiver."
     offset := self sense.
     (Display offset x + Display width) <= (offset x + 8)
         ifTrue: [offset x: Display offset x + Display width - 1]
         ifFalse: [offset x: ((offset x // 8) * 8) + 8].
     self display!
 jumpUp
         "Tab the cursor up to the previous vertical tab position
          (vertical tabs are set every four lines from the
          top line of the display screen).  Answer the receiver."
     offset := self sense.
     (offset y - 4) < (Display offset y)
         ifTrue: [offset y: Display offset y]
         ifFalse: [offset y: (offset y - 1// 4) * 4].
     self display!
 left
         "Move the cursor left by one character position
          unless it is already on the leftmost
          character position of the display screen.
          Answer the receiver."
     offset := self sense.
     (offset x) <= (Display offset x)
         ifTrue: [offset x: Display offset x]
         ifFalse:[offset x: offset x - 1].
     self display!
 offset
         "Answer a Point containing the current
          cursor position coordinates contained by
          the instance variable offset."
     ^offset x @ offset y!
 offset: aPoint
         "Set cursor position to aPoint on the display
          screen and update the contents of the instance
          variable offset with aPoint.   Answer the receiver."
     offset:= (aPoint min: Display extent - (1@1))
         max: 0@0.
     self display!
 right
         "Move the cursor right by one character position
          unless it is already on the rightmost
          character position of the display screen.
          Answer the receiver."
     offset := self sense.
     offset x = (Display offset x + Display width - 1)
         ifFalse: [offset x: offset x + 1].
     self display!
 sense
         "Answer the current cursor position coordinates
          from the display screen as a Point."
     ^self cursorPrimWith: nil function: 3!
 setOffset
         "Update the cursor position in the instance
          variable offset with the current cursor position
          on the display screen.  Answer the receiver."
     self offset: self sense!
 setOffset: aPoint
         "Update the cursor position in the instance
          variable offset with the position aPoint.
          Answer the receiver."
     offset := aPoint!
 show
         "Make the cursor visible on the display screen.
          This method will be ignored unless the system
          is being used with a mouse.  Answer the receiver."
     self cursorPrimWith: nil function: 1!
 up
         "Move the cursor up by one character position
          unless it is already on the top line
          of the display screen.  Answer the receiver."
     offset := self sense.
     (offset y) <= (Display offset y)
         ifFalse:[offset y: offset y - 1].
     self display! !

! Directory class methods !
 create: newPathName
         "Create a DOS directory on disk with complete
          path name newPathName."
     self dosError:
         (self primitiveCreate: newPathName asAsciiZ)!
 current
         "Answer a Directory representing the current
          DOS directory."
     | currPath index |
     currPath := String new: 67.
     self dosError:
         (self primitiveSenseDirInto: currPath).
     index := 3.
     currPath := currPath asLowerCase.
     [(currPath at: index) asciiValue > 0]
         whileTrue: [index := index + 1].
     ^Directory new
         drive: (currPath at: 1);
         pathName: (currPath copyFrom: 3 to: index - 1)!
 extractDateTimeFrom: aDirEntry
         "Answer a String in form 'yy-mm-dd hh:mm:ss'
          describing date and time from DOS directory
          entry aDirEntry."
     | answer byte1 byte2 field1 field2 field3 tempStream |
     answer := String new: 18.
     tempStream := WriteStream on: answer.
         "computing the yy-mm-dd part"
     byte1 := (aDirEntry at: 25) asciiValue.
     byte2 := (aDirEntry at: 26) asciiValue.
     field1 := (byte2 bitShift: -1) + 80.
     field2 := (byte1 bitShift: -5)
         + ((byte2 bitAnd: 1) * 8).
     field3 := byte1 bitAnd: 31.
     field1 < 10
         ifTrue: [tempStream nextPut: $0].
     field1 printOn: tempStream.
     tempStream nextPut: $-.
     field2 < 10
         ifTrue: [tempStream nextPut: $0].
     field2 printOn: tempStream.
     tempStream nextPut: $-.
     field3 < 10
         ifTrue: [tempStream nextPut: $0].
     field3 printOn: tempStream.
     tempStream space; space.
         "computing the hh:mm:ss part"
     byte1 := (aDirEntry at: 23) asciiValue.
     byte2 := (aDirEntry at: 24) asciiValue.
     field1 := byte2 bitShift: -3.
     field2 := (byte1 bitShift: -5)
         + ((byte2 bitAnd: 7) * 8).
     field3 := (byte1 bitAnd: 31) * 2.
     field1 < 10
         ifTrue: [tempStream nextPut: $0].
     field1 printOn: tempStream.
     tempStream nextPut: $:.
     field2 < 10
         ifTrue: [tempStream nextPut: $0].
     field2 printOn: tempStream.
     tempStream nextPut: $:.
     field3 < 10
         ifTrue: [tempStream nextPut: $0].
     field3 printOn: tempStream.
     ^answer!
 extractFileNameFrom: aDirEntry
         "Answer a string representing the file name
          from a DOS directory entry aDirEntry."
     | name ext |
     ((aDirEntry at: 12) asciiValue bitAnd: 8) = 8
         ifTrue: [
             ^(aDirEntry copyFrom: 1 to: 11)
                 trimBlanks asLowerCase].
     name := (aDirEntry copyFrom: 1 to: 8) trimBlanks.
     ext := (aDirEntry copyFrom: 9 to: 11) trimBlanks.
     ext isEmpty
         ifFalse: [
             name := name, (String with: $.), ext].
     ^name asLowerCase!
 extractFlagsFrom: aDirEntry
         "Answer a String containing attribute flags
          from a DOS directory entry aDirEntry.
          Attributes are: 'r' read only, 'h' hidden,
          's' system, and 'a' archive."
     | flags byte12 |
     flags := String new.
     byte12 := (aDirEntry at: 12) asciiValue.
     (byte12 bitAnd: 1) > 0
         ifTrue: [flags := 'r'].
     (byte12 bitAnd: 2) > 0
         ifTrue: [flags := flags, 'h'].
     (byte12 bitAnd: 4) > 0
         ifTrue: [flags := flags, 's'].
     (byte12 bitAnd: 32) > 0
         ifTrue: [flags := flags, 'a'].
     ^flags!
 extractSizeFrom: aDirEntry
         "Answer the file size extracted from a DOS
          directory entry aDirEntry."
     | size |
     size := 0.
     32 to: 29 by: -1 do: [ :index |
         size := size * 256
             + (aDirEntry at: index) asciiValue].
     ^size!
 freeDiskSpace
         "Answer the free space in bytes on the disk
          containing the current directory."
     ^self dosError: (self primitiveFreeDiskSpace)!
 pathName: aPathName
         "Answer a Directory described by the complete
          path name aPathName."
     ^self new
         drive: (aPathName at: 1);
         pathName: (aPathName copyFrom: 3 to: aPathName size)!
 primitiveCreate: pathName
         "Private - Create a directory on disk at the
          complete path name pathName."
     <primitive: 79>
     ^self primitiveFailed!
 primitiveFreeDiskSpace
         "Private - Answer the number of bytes of
          free space on the current drive."
     <primitive: 69>!
 primitiveRemove: oldPathName
         "Private - Remove the directory from disk
          described by oldPathName."
     <primitive: 80>
     ^self primitiveFailed!
 primitiveSenseDirInto: curPathName
         "Private - Set the String curPathName (with
          a minimum length of 67) to the path name
          of the current directory."
     <primitive: 121>
     ^self primitiveFailed!
 primitiveSetTo: newPathName
         "Private - Make newPathName the current DOS directory."
     <primitive: 118>
     ^self primitiveFailed!
 remove: oldPathName
         "Remove DOS directory with path name oldPathName."
     | dosReturnCode |
     dosReturnCode := self
         primitiveRemove: oldPathName asAsciiZ.
     dosReturnCode = -5
         ifTrue: [self dosError: -19]
         ifFalse: [self dosError: dosReturnCode]!
 setTo: newPathName
         "Make newPathName the current DOS directory."
     self dosError:
         (self primitiveSetTo: newPathName asAsciiZ)! !

! Directory methods !
 allSubdirs
         "Answer an OrderedCollection of Arrays for the
          entire subtree of directories under the receiver
          directory. Each Array contains the complete path
          name and the file name of a subdirectory."
     | answer subdirs |
     answer := OrderedCollection new.
     subdirs := self subdirectories.
     answer addAll: subdirs.
     subdirs do: [ :each |
         answer
             addAll:
                 (Directory new
                     drive: self drive;
                     pathName: (each at: 1)) allSubdirs].
     ^answer!
 contents
         "Answer an OrderedCollection of Strings
          for the receiver Directory.  Each String
          is a DOS directory entry for a file."
     | answer aString tempFCB errorCode |
     answer := OrderedCollection new.
     tempFCB := FileControlBlock unopened.
     self makeCurrent.
     [aString := String new: 32.
      (errorCode := self nextEntryInto: aString using: tempFCB) > 0]
         whileTrue: [
             ((aString at: 12) asciiValue bitAnd: 8) = 8
                 ifTrue: [
                     volumeLabel := Directory
                         extractFileNameFrom: aString]
                 ifFalse: [
                     (aString at: 1) == $.
                         ifFalse: [answer add: aString]]].
     errorCode = 0
         ifFalse: [^self dosError: errorCode].
     ^answer!
 create
         "Create a DOS directory on disk for the
          receiver directory."
     Directory create: (String with: self drive),
         ':', self pathName!
 drive
         "Answer the disk drive letter of the receiver."
     ^drive!
 drive: aCharacter
         "Initialize the drive for the receiver to
          aCharacter."
     volumeLabel := String new.
     drive := aCharacter!
 file: aString
         "Answer a FileStream for the file named
          aString in the current directory.  If the file
          doesn't exist, it will be created."
     ^FileStream on: (File open: aString in: self)!
 formatted
         "Answer a collection of arrays of file information
          for the receiver directory.  Each array has four
          entries: file name, size, date/time and attributes."
     | answer fileEntries tempArray |
     fileEntries := self contents.
     answer := OrderedCollection new: fileEntries size.
     fileEntries do: [ :each |
         (each at: 12) asciiValue = 16
             ifFalse: [
                 tempArray := Array new: 4.
                 tempArray
                     at: 1 put:
                         (Directory extractFileNameFrom: each);
                     at: 2 put:
                         (Directory extractSizeFrom: each);
                     at: 3 put:
                         (Directory extractDateTimeFrom: each);
                     at: 4 put:
                         (Directory extractFlagsFrom: each).
                 answer add: tempArray]].
     ^answer!
 makeCurrent
         "Make the receiver directory the current
          DOS directory."
     Directory setTo: (String with: self drive),
         ':', self pathName!
 newFile: aString
         "Answer a FileStream for the file named
          aString in the current directory.  If the file
          exists, it will be removed and a new file
          will be created."
     | file |
     file := self file: aString.
     file size > 0
         ifTrue: [
             File remove: file pathName.
             file := self file: aString].
     ^file!
 nextEntryInto: aString using: aFileControlBlock
         "Private - Set aString to the next DOS
          directory entry for the receiver.  The
          next entry is described by aFileControlBlock."
     <primitive: 68>
     ^self primitiveFailed!
 pathName
         "Answer a String representing the path name
          of the receiver directory (drive letter not
          included)."
     ^pathName trimBlanks!
 pathName: aString
         "Set the receiver directory path name to aString."
     aString isEmpty
         ifTrue: [pathName := aString]
         ifFalse: [pathName := aString asAsciiZ]!
 remove
         "Remove the directory described
          by the receiver from the disk."
     Directory remove: (String with: self drive),
         ':', self pathName!
 subdirectories
         "Answer an OrderedCollection of arrays, where
          each Array contains the complete path name and
          the file name of a subdirectory of the receiver."
     | dirs path name |
     (path := self pathName) = '\'
         ifTrue: [path := String new].
     dirs := OrderedCollection new.
     self contents do: [ :entry |
         (entry at: 12) asciiValue = 16
             ifTrue: [
                 name := Directory extractFileNameFrom: entry.
                 dirs add:
                     (Array
                         with: path, '\', name
                         with: name)]].
     ^dirs!
 subDirectory: aPathName
         "Answer a Directory whose path name
          equals the receiver path name concatenated
          with aPathName."
     | path |
     (path := self pathName) = '\'
         ifTrue: [path := String new].
     ^self class new
         drive: self drive;
         pathName: path, '\', aPathName!
 volumeLabel
         "Answer a String containing the volume label
          for the disk containing the receiver Directory."
     ^volumeLabel! !

! DiskBrowser class methods ! !

! DiskBrowser methods !
 accept
         "Private - Write the file pane contents
          to the file stream."
     contentsPane fileOutOn: (selectedDirectory file: selectedFile).
     contentsPane dispatcher modified: false.
     self changed: #label!
 boldSortPane
         "Private - Make the sort pane display bold."
     sortPane
         selection: 1;
         displayWindow;
         showPane!
 buildDirectoryList
         "Private - Build an OrderedCollection of
          directory file name Strings for all
          directories on the disk.  Precede names
          with spaces to indicate directory
          hierarchy."
     | dir subDirectoryList listSize aStream index totalPath backSlash |
     volumeLabel := String new.
     backSlash := '\'.
     selectedDirectory := nil.
     selectedFile := nil.
     subDirectoryList := SortedCollection
         sortBlock: [ :a :b | (a at: 1) < (b at: 1)].
     dir := Directory new
         drive: device;
         pathName: backSlash.
     subDirectoryList add: (Array with: backSlash with: backSlash).
     dir allSubdirs do: [ :subdir |
         subDirectoryList add: subdir].
     volumeLabel := dir volumeLabel.
     listSize := subDirectoryList size.
     directoryList := OrderedCollection new: listSize.
     pathNameArray := Array new: listSize.
     aStream := WriteStream on: (String new: 30).
     index := 1.
     subDirectoryList do: [ :subdir |
         totalPath := subdir at: 1.
         aStream reset.
         totalPath  = backSlash
             ifFalse: [
                 (totalPath occurrencesOf: $\)
                     timesRepeat: [aStream space]].
         aStream nextPutAll: (subdir at: 2).
         directoryList add: aStream contents.
         pathNameArray at: index  put: totalPath.
         index := index + 1]!
 changeFileMode
         "Private - Request new file mode with
          Prompter, and change mode of selected
          file to the answered mode."
     | path defaultMode |
     selectedFile == nil
         ifTrue: [^nil].
     defaultMode := 'a'.
     (path := selectedDirectory pathName) = '\'
         ifTrue: [path := String new].
     defaultMode := Prompter
         prompt: 'Mode? (rhs)'
         default: defaultMode.
     defaultMode == nil
         ifTrue: [^nil].
     File changeModeOf: (String with: device), ':',
         path, '\',  selectedFile to: defaultMode.
     self changed: #directory!
 copyFile
         "Private - Request the name of a destination file
          with a Prompter and copy the selected file to
          the file entered."
     | dir source dest |
     selectedFile == nil
         ifTrue: [^nil].
     dir := self promptForPathName.
     dir == nil
         ifTrue: [^nil].
     dest := (String with: dir drive), ':', dir pathName.
     source := (selectedDirectory file: selectedFile)
         pathName.
     File copy: source to: dest.
     self showDirectory!
 createDirectory
         "Private - Request the name of a new directory with
          a Prompter and create a subdirectory with the entered
          name under the selected directory."
     | dir |
     dir := self promptForPathName.
     dir == nil
         ifFalse: [
             dir  create.
             self update]!
 createFile
         "Private - Request a file name using a Prompter
          and create a new file with the entered name
          in the selected directory."
     | oldName newName file |
     selectedDirectory == nil
         ifTrue: [^nil].
     oldName := 'filename.ext'.
     newName := Prompter
         prompt: 'File name? (No path name permitted)'
         default: oldName.
     newName == nil
         ifTrue: [^nil].
     file := selectedDirectory newFile: newName.
     file close.
     self showDirectory!
 directories
         "Private - Answer the list of directories
          for the device."
     selectedDirectory := nil.
     ^directoryList!
 directory
         "Private - Answer a String containing the text
          pane data for the selected directory.  For each
          file the file name, size, creation date/time and
          mode (attribute) bytes are displayed."
     | linesAsString tempString |
     linesAsString := WriteStream on:
         (String new: sortedFileList size * 46).
     sortedFileList do: [ :each |
         tempString := each at: 1.
         linesAsString
             nextPutAll: tempString;
             next: (12 - tempString size) put: $ .
         tempString := (each at: 2) printString.
         linesAsString
             next: (8 - tempString size) put: $ ;
             nextPutAll: tempString.
         linesAsString
             space; space;
             nextPutAll: (each at: 3);
             space; space;
             nextPutAll: (each at: 4);
             cr].
     ^linesAsString contents!
 directory: listIndex
         "Private - Set the selected directory to be
          the one at listIndex.  Display directory
          data in both the list pane and text pane."
     Scheduler topDispatcher flashLabel.
     selectedDirectory := Directory new
         drive: device;
         pathName: (pathNameArray at: listIndex).
     self showDirectory.
     Scheduler topDispatcher unflashLabel!
 directoryListMenu
         "Private - Answer the directory pane menu."
     ^Menu
         labels: 'remove\update\create' withCrs
         lines: Array new
         selectors: #(removeDirectory  update createDirectory)!
 directorySort
         "Private - Answer an Array containing the text
          for the directory sort pane."
     ^Array with: ('Directory by ', sortCriteria asString)!
 file
         "Private - Read the selected file and display
          its contents in the text pane."
     | aFile |
     aFile := selectedDirectory file: selectedFile.
     contentsPane fileInFrom: aFile.
     aFile close.
     contentsPane dispatcher modified: false.
     contentsPane forceSelectionOntoDisplay!
 file: fileName
         "Private - Set the selected file to fileName.
          Display the file contents in the text pane."
     | file |
     selectedFile := fileName.
     contentsPane name: #file.
     file := selectedDirectory file: selectedFile.
     (wholeFileRequest := file size < 6000)
         ifTrue: [self file]
         ifFalse: [self showPartialFile].
     self changed: #directorySort!
 fileListMenu
         "Private - Answer the file pane menu."
     ^Menu
         labels: 'remove\rename\copy\print\create\mode'
              withCrs
         lines: Array new
         selectors: #(removeFile renameFile copyFile printFile
             createFile changeFileMode)!
 files
         "Private - Answer a sorted list of files for
          the selected directory."
     | lines |
     selectedFile := nil.
     sortedFileList := SortedCollection sortBlock:
         sortedFileList sortBlock.
     lines := SortedCollection new.
     selectedDirectory == nil
         ifTrue: [^lines].
     sortedFileList addAll: selectedDirectory formatted.
     sortedFileList do: [ :each | lines add: (each at: 1)].
     ^lines!
 label
         "Private - Answer a String for the window label
          which contains the disk label, the selected
          directory path name, and the remaining space
          on disk (in bytes)."
     | tempLabel |
     tempLabel := '[', volumeLabel, '] ',
         (String with: device), ':'.
     selectedDirectory == nil
         ifTrue: [
             (Directory new drive: device; pathName: '\')
                 makeCurrent]
         ifFalse: [
             selectedDirectory makeCurrent.
             tempLabel := tempLabel, selectedDirectory pathName].
     ^tempLabel, '   ', Directory freeDiskSpace printString!
 loadEntireFile
         "Private - Process menu request for loading
          the entire file."
     wholeFileRequest := true.
     self file!
 openOn: driveCharacter
         "Open a disk browser window on the device
          identified by driveCharacter.  Define the
          type, behavior and relative size of each
          pane and schedule the window."
     | topPane |
     device := driveCharacter.
     self buildDirectoryList.
     sortedFileList := SortedCollection
         sortBlock: [ :a :b | (a at: 1) < (b at: 1)].
     sortCriteria := #name.
     ratio == nil
         ifTrue: [ratio := 2 / 5].
     wholeFileRequest := false.
     topPane := TopPane new
         model: self;
         label: '[',volumeLabel, '] ',
             (String with: device), ':';
         minimumSize: 20 @ 10;
         yourself.
     topPane addSubpane:
         (ListPane new
             model: self;
             name: #directories;
             change: #directory:;
             menu: #directoryListMenu;
             returnIndex: true;
             framingBlock: [:box|
                 box origin extent:
                 box width // 2 - 1 @
                     ((self topPaneHeight: box) - 2)]).
     topPane addSubpane:
         (ListPane new
             model: self;
             name: #files;
             change: #file:;
             menu: #fileListMenu;
             framingBlock: [:box|
                 box origin+(box width//2 @ 0) extent:
                 box width-(box width//2) @
                     (self topPaneHeight: box)]).
     topPane addSubpane:
         (contentsPane := TextPane new
             model: self;
             name: #directory;
             menu: #textMenu;
             framingBlock: [:box|
                 box origin+(0 @ (1 + (self topPaneHeight: box)))
                         corner: box corner]).
     topPane addSubpane:
         (sortPane := ListPane new
             model: self;
             name: #directorySort;
             change: #sortBy:;
             menu: #sortMenu;
             selection: 1;
             framingBlock: [:box|
                 box origin + (0 @ ((self topPaneHeight: box) - 1))
                     extent: box width // 2 - 1 @ 1]).
     topPane dispatcher open scheduleWindow!
 printBanner
         "Private - Print a banner page on the printer
          which contains the selected file name and
          the current date and time. (May need modification
          for non-EPSON printers.)"
     | wide string fileName |
     28 timesRepeat: [
         (String with: 10 asCharacter) outputToPrinter].
     fileName := selectedFile asUpperCase.
     wide := (String
         with: 27 asCharacter
         with: $W
         with: $1).
     fileName := wide,
         ('              '),
         ('     '
             copyFrom: 1
             to: 12 - fileName trimBlanks size // 2),
         fileName.
     wide at: 3 put: $0.
     fileName := fileName, wide,
         (String
             with: 10 asCharacter
             with: 10 asCharacter),
         '                            ',
         Date today printString, ' ** ',
         Time now printString.
     fileName outputToPrinter.
     self resetPrinter!
 printFile
         "Private - Print the selected file on the printer."
     | fcb buffer pageSize currentPos bytesRead |
     selectedFile == nil
         ifTrue: [^nil].
     self printBanner.
     fcb := (selectedDirectory file: selectedFile)
         file fileId.
     pageSize := File pageSize.
     buffer := String new: pageSize.
     currentPos := 1.
     [bytesRead := fcb
         readInto: buffer
         atPosition: currentPos.
      currentPos := currentPos + pageSize.
      bytesRead = 512]
         whileTrue: [buffer outputToPrinter].
     bytesRead > 0
         ifTrue: [(buffer copyFrom: 1 to: bytesRead) outputToPrinter].
     fcb close.
     self resetPrinter!
 promptForPathName
         "Private - Request a path name using a Prompter.
          Answer a Directory corresponding to the
          entered path name."
     | drive path newPath |
     drive := device.
     selectedDirectory == nil
         ifTrue: [path := '\']
         ifFalse: [path := selectedDirectory pathName].
     newPath := Prompter
         prompt: 'PathName?'
         default: (String with: device), ':', path.
     newPath == nil
         ifTrue: [^nil].
     (newPath size > 1 and: [(newPath at: 2) == $:])
         ifTrue: [
             drive := newPath at: 1.
             newPath size > 2
                 ifTrue: [
                     newPath := newPath
                         copyFrom: 3
                         to: newPath size]
                 ifFalse: [newPath := String new]].
     (newPath size > 0 and: [(newPath at: 1) == $\])
         ifTrue: [^Directory new drive: drive; pathName: newPath].
     drive = device
         ifTrue: [
             path = '\'
                 ifTrue: [path := String new]]
         ifFalse: [path := String new].
     ^Directory new drive: drive; pathName: path, '\', newPath!
 removeDirectory
         "Private - Remove the selected directory."
     | dir |
     selectedDirectory == nil
         ifTrue: [^nil].
     (Directory new drive: device; pathName: '\') makeCurrent.
     selectedDirectory remove.
     self update!
 removeFile
         "Private - Remove the selected file."
     | path |
     selectedFile == nil
         ifTrue: [^nil].
     (path := selectedDirectory pathName) = '\'
         ifTrue: [path := String new].
     File remove: (String with: device), ':',
         path, '\',  selectedFile.
     self showDirectory!
 renameFile
         "Private - Request a file name with a Prompter
          and change the selected file name to the entered
          name."
     | dir |
     selectedFile == nil
         ifTrue: [^nil].
     dir := self promptForPathName.
     dir == nil
         ifTrue: [^nil].
     File
         rename: selectedFile
         to: (String with: dir drive), ':', dir pathName.
     self showDirectory!
 replaceCrsIn: aString
         "Private - Modify aString so that carriage-returns
          in carriage-return line-feed pairs are set to
          blank, and single carriage-returns
          are set to line-feed."
     | limit index |
     limit := aString size.
     index := 0.
     [index := index + 1.
      index < limit]
         whileTrue: [
             (aString at: index) == Cr
                 ifTrue: [
                     (aString at: index + 1) == Lf
                         ifTrue: [aString at: index put: $ ]
                         ifFalse: [aString at: index put: Lf]]]!
 resetPrinter
         "Private - Send escape sequence to printer to
          reset it. (May need modification for non-EPSON
          printers.)"
     ((String
         with: 12 asCharacter
         with: 27 asCharacter
         with: 64 asCharacter),
     (String
         with: 27 asCharacter
         with: $N
         with: 6 asCharacter))
             outputToPrinter!
 restoreDirList
         "Private - Cause the text pane to show the
          selected directory description."
     selectedDirectory == nil
         ifFalse: [self changed: #directory]!
 saveAs
         "Private - Request a file name using a
          Prompter and write the contents of the text
          pane to the entered file name."
     | dir delimiter pathNameArray file |
     dir := self promptForPathName.
     dir == nil
         ifTrue: [^nil].
     pathNameArray := File splitPath: dir pathName.
     dir pathName: (pathNameArray at: 1).
     file := dir file: (pathNameArray at: 2).
     selectedFile == nil
         ifFalse: [
             file lineDelimiter:
                 (selectedDirectory file: selectedFile) lineDelimiter].
     file size = 0
         ifTrue: [
             contentsPane fileOutOn: file.
             file close.
             self showDirectory]
         ifFalse: [
             file close.
             self dosError: -5]!
 showDirectory
         "Private - Recompute the directory
          list and display it."
     contentsPane name: #directory.
     self
         changed: #label;
         changed: #files;
         changed: #directory;
         boldSortPane!
 showPartialFile
         "Private - Display the head and tail of the
          selected file in the text pane."
     | file fileHead fileTail startMessage endMessage |
     file := selectedDirectory file: selectedFile.
     startMessage := 'File size is greater than 6000 bytes
 first 2000 bytes are ...
 '.
     endMessage := '
 ***********************
 last 2000 bytes are ...
 '.
     fileHead := file copyFrom: 1 to: 2000.
     fileTail := file copyFrom: file size - 2000 to: file size.
     file lineDelimiter == Cr
         ifTrue: [
             self replaceCrsIn: fileHead.
             self replaceCrsIn: fileTail].
     file close.
     contentsPane
         selectAll;
         replaceWithText: (startMessage, fileHead, endMessage, fileTail);
         selectBefore: 1@1;
         forceSelectionOntoDisplay.
     self changed: #directorySort!
 sortBy: aSymbol
         "Private - Change the text pane to a directory
          pane and show the information for the
          selected directory."
     self showDirectory!
 sortByDate
         "Private - Set sortBlock for directory
          date order sort."
     sortedFileList sortBlock:
         [ :a :b | (a at: 3) > (b at: 3)].
     sortCriteria := #date.
     self updateSortPane!
 sortByName
         "Private - Set sortBlock for directory
          name order sort."
     sortedFileList sortBlock:
         [ :a :b | (a at: 1) < (b at: 1)].
     sortCriteria := #name.
     self updateSortPane!
 sortBySize
         "Private - Set sortBlock for directory
          size order sort."
     sortedFileList sortBlock:
         [ :a :b | (a at: 2) > (b at: 2)].
     sortCriteria := #size.
     self updateSortPane!
 sortMenu
         "Private - Answer the directory sort menu."
     ^Menu
         labels: 'date order\name order\size order' withCrs
         lines: Array new
         selectors: #(sortByDate sortByName sortBySize)!
 textMenu
         "Private - Answer the text pane menu which is
          the editing menu if the entire file
          was read in, else answer a restricted menu."
     selectedFile == nil
         ifTrue: [
             ^Menu
                 labels: 'copy\cut\paste\show it\do it\save as\restore' withCrs
                 lines: Array new
                 selectors: #(copySelection cutSelection pasteSelection
                     printIt doIt saveAs restoreDirList)].
     wholeFileRequest
         ifTrue: [
             ^Menu
                 labels: 'install\copy\cut\paste\show it\do it\save\save as\restore' withCrs
                 lines: Array new
                 selectors: #(fileItIn copySelection cutSelection
                      pasteSelection printIt doIt accept saveAs file)]
         ifFalse: [
             ^Menu
                 labels: 'install\copy\cut\paste\show it\do it\read it\restore' withCrs
                 lines: Array new
                 selectors: #(fileItIn copySelection cutSelection
                      pasteSelection printIt doIt loadEntireFile showPartialFile)]!
 topPaneHeight: aRectangle
         "Private - Answer the top pane height using
          ratio applied to aRectangle."
     ^(aRectangle height - 1 min: (2 max: (
         aRectangle height * ratio) truncated))!
 update
         "Private - Recompute the directory list
          and display it."
     Scheduler topDispatcher flashLabel.
     self
         buildDirectoryList;
         changed: #directories;
         showDirectory.
     Scheduler topDispatcher unflashLabel!
 updateSortPane
         "Private - Update the sort criteria pane."
     | remainBold |
     remainBold := sortPane selection = 1.
     self
         changed: #directorySort;
         changed: #directory.
     remainBold
         ifTrue: [self boldSortPane]! !

! Dispatcher class methods !
 initialize
         "Private - Initialize class variables.
          Do nothing for default here."!
 new
         "Answer a new instance of class Dispatcher
          with its instance variables initialized."
     ^super new initialize! !

! Dispatcher methods !
 activate
         "Make the receiver active.  Most subclasses
          supplement this method."
     active := true!
 activateWindow
         "Make the receiver window active by displaying
          it and then giving control to the pane that
          contains the cursor.  This is the main
          processing loop for the active window."
     self display.
     pane activateWindow.
     [active] whileTrue: [
         pane hasCursor
             ifTrue: [
                 pane searchForActivePane
                     dispatcher processInput]
             ifFalse: [self processKey: Terminal read]]!
 active
         "Answer true if the receiver is the
          active dispatcher, else answer false."
     ^active!
 closeIt
         "Close the receiver window and resume the
          Scheduler main processing loop."
     self closeWindow.
     Scheduler resume!
 closeWindow
         "Close the receiver window and remove the
          receiver from the Scheduler dispatchers."
     | topPane |
     topPane := pane topPane.
     topPane close.
     Scheduler remove: topPane dispatcher!
 cycle
         "Deactivate the receiver window and cause the
          windows to rotate."
     pane deactivatePane.
     Scheduler cycle!
 cyclePane
         "Move to the next pane in the receiver window."
     pane cyclePane!
 deactivate
         "Make the receiver inactive."
     active := false!
 deactivateWindow
         "Mark the receiver pane to be
          inactive and change their visual clues
          to reflect so."
       pane deactivateWindow!
 display
         "Display the receiver window."
     pane displayWindow!
 doesNotHandle
         "Ring the bell for input not handled
          by the receiver."
     Terminal write: Bell!
 homeCursor
         "Move the cursor to the receiver
          home position."
     Cursor offset: pane frame origin!
 initialize
         "Private - Initialize the receiver to be inactive."
     active := false!
 isControlActive
         "Answer true if the receiver is active and
          contains the cursor.  Some subclasses will
          override and/or supplement this test."
     ^active and: [pane hasCursor]!
 isControlWanted
         "Answer true if the pane contains the
          cursor, else answer false."
     ^pane hasCursor!
 modified
         "Indicate whether or not the contents of
          the receiver pane have been modified.
          Answer false as default."
     ^false!
 open
         "Prompt the user for a rectangle on the
          screen.  Open and activate the receiver
          window in the rectangle area."
     | topPane |
     topPane := pane topPane.
     topPane reframe:
         (PointDispatcher rectangleFromUserOfSize:
             topPane minimumSize).
     topPane dispatcher openWindow!
 openIn: aRectangle
         "Open the receiver window as the
          active one over aRectangle."
     | topPane |
     topPane := pane topPane.
     topPane reframe: aRectangle.
     topPane dispatcher openWindow!
 openWindow
         "Open the receiver window
          and home the cursor."
     self homeCursor.
     pane open!
 pane: aPane
         "Set the receiver pane to be aPane
          and initialize the receiver."
     pane := aPane.
     self initialize!
 processControlKey: aCharacter
         "Private - Ring the bell since control keys
          are processed by subclasses of this class."
     self doesNotHandle!
 processFunctionKey: aCharacter
         "Private - Process the keyboard function keys
          and mouse events represented by aCharacter."
     aCharacter == SetLoc        ifTrue: [^self].
 
     aCharacter == LeftFunction  ifTrue: [^Cursor left].
     aCharacter == RightFunction ifTrue: [^Cursor right].
     aCharacter == UpFunction    ifTrue: [^Cursor up].
     aCharacter == DownFunction  ifTrue: [^Cursor down].
 
     aCharacter == JumpLeftFunction  ifTrue: [^Cursor jumpLeft].
     aCharacter == JumpRightFunction ifTrue: [^Cursor jumpRight].
     aCharacter == JumpDownFunction  ifTrue: [^Cursor jumpDown].
     aCharacter == JumpUpFunction    ifTrue: [^Cursor jumpUp].
 
     aCharacter == SelectFunction
         ifTrue: [
             self select.
             Terminal initialize.
             ^self].
     aCharacter == EndSelectFunction ifTrue: [^self].
     aCharacter == CycleFunction  ifTrue: [^self cycle].
     aCharacter == PaneCycleFunction ifTrue: [^self cyclePane].
 
     WindowMenuRequest == aCharacter
         ifTrue: [
             pane topPane hasCursor
                 ifTrue: [^pane topPane performMenu]
                 ifFalse: [^Terminal bell]].
     PaneMenuRequest == aCharacter
         ifTrue: [
             pane topPane hasCursor
                 ifTrue: [^pane performMenu]
                 ifFalse: [^Terminal bell]].
     ControlBreak == aCharacter
         ifTrue: [^self].
     self doesNotHandle!
 processInput
         "Private - Activate the receiver pane.
          Read and process user input as long
          as the cursor remains inside the pane.
          This is the main processing loop for
          the active pane."
     pane activatePane.
     [self isControlActive]
         whileTrue: [self processKey: Terminal read].
     pane deactivatePane!
 processInputKey: aCharacter
         "Private - Ring the bell since aCharacter
          should be processed by subclasses of this class."
     self doesNotHandle!
 processKey: aCharacter
         "Private - Categorize the input aCharacter
          and invoke the appropriate method to
          process aCharacter."
     (MouseEvent or: [FunctionKey])
         ifTrue: [^self processFunctionKey: aCharacter].
     (aCharacter between: Space and: $variaMethod)
         ifTrue: [self processInputKey: aCharacter]
         ifFalse: [self processControlKey: aCharacter]!
 scheduleWindow
         "Activate the receiver window."
     Scheduler schedule: pane topPane dispatcher!
 select
         "Ring the bell since this function
          should be implemented by subclasses of
          this class."
     self doesNotHandle!
 topDispatcher
         "Answer the top dispatcher
          for the receiver window."
     ^pane topPane dispatcher! !

! PointDispatcher class methods !
 forBox: aRectangle
     ofMinSize: extent
     perform: aSymbol
         "Private - Create a PointDispatcher displaying
          aRectangle which will be either moved or
          framed by the user based on aSymbol. The
          final rectangle must have a minimal size of
          extent. Answer the top left corner of the
          final rectangle."
     self new
         moveOrSizeBox: aSymbol;
         minBoxExtent: extent;
         displayBox: aRectangle;
         return: [ :aPoint | ^aPoint]!
 pointFromUserDisplaying: box
         "Display a rectangle of size box which
          may be moved by the user to the desired
          position.  Answer the top left corner of
          the rectangle when the user selects a
          position."
     self new
         moveOrSizeBox: #move;
         displayBox: box;
         return: [ :p | ^p]!
 rectangleFromUser
         "Answer a rectangle specified by the user."
     ^self rectangleFromUserOfSize: 1@1!
 rectangleFromUserOfSize: extent
         "Answer a rectangle of minimum size extent
          which may be moved and sized by the user."
     | origin initialSize minExtent bottomCorner |
     initialSize := 45 @ 16.
     minExtent := extent max: 3 @ 3.
     origin := self
         forBox: (Cursor offset extent: initialSize)
         ofMinSize: minExtent
         perform: #frame.
     bottomCorner :=
         origin + initialSize - 1 min: Display extent.
     Cursor offset: bottomCorner.
     self new
         moveOrSizeBox: #size;
         minBoxExtent: minExtent;
         displayBox: (Rectangle
             origin: origin corner: bottomCorner);
         return: [ :corner |
             ^(origin corner: corner)
                 merge: (origin extent: minExtent)]! !

! PointDispatcher methods !
 adjustBox
         "Private - Adjust the displayBox and the
          cursor offset so that the displayBox is
          not out of the display screen."
     | cursor |
     moveOrSizeBox == #move
         ifTrue: [
             cursor := Display extent - displayBox extent
                 min: Cursor offset.
             cursor = Cursor offset
                 ifFalse: [Cursor offset: cursor].
             displayBox origin: Cursor offset]
         ifFalse: [
             moveOrSizeBox == #frame
                 ifTrue: [
                     cursor := Display extent - minBoxExtent
                         min: Cursor offset.
                     cursor = Cursor offset
                         ifFalse: [Cursor offset: cursor].
                     displayBox origin: Cursor offset]
                 ifFalse: [
                     cursor := displayBox origin + minBoxExtent - 1
                         max: Cursor offset.
                     cursor = Cursor offset
                         ifFalse: [Cursor offset: cursor].
                     displayBox := displayBox origin corner: Cursor offset]]!
 displayBox: aRectangle
         "Private - Set display box to aRectangle."
     displayBox := aRectangle!
 minBoxExtent: extent
         "Private - Set minBoxExtent to the Point extent."
     minBoxExtent := extent!
 moveOrSizeBox: moveOrSizeSymbol
         "Private - Set moveOrSizeBox to moveOrSizeSymbol which
          can be #move, #frame, or #size."
     moveOrSizeBox := moveOrSizeSymbol!
 processFunctionKey: aCharacter
         "Private - Perform the requested function from
          the keyboard or mouse."
     aCharacter == SetLoc
         ifTrue: [^self].
     aCharacter == LeftFunction
         ifTrue: [^Cursor left].
     aCharacter == RightFunction
         ifTrue: [^Cursor right].
     aCharacter == UpFunction
         ifTrue: [^Cursor up].
     aCharacter == DownFunction
         ifTrue: [^Cursor down].
 
     aCharacter == JumpLeftFunction
         ifTrue: [^Cursor jumpLeft].
     aCharacter == JumpRightFunction
         ifTrue: [^Cursor jumpRight].
     aCharacter == JumpDownFunction
         ifTrue: [^Cursor jumpDown].
     aCharacter == JumpUpFunction
         ifTrue: [^Cursor jumpUp].
 
     (MouseEvent
         ifTrue: [aCharacter == EndSelectFunction]
         ifFalse: [aCharacter == SelectFunction])
             ifTrue: [^self select]
             ifFalse: [^self].
     self doesNotHandle!
 processInput
         "Private - Save a copy of the display screen image.
          Draw displayBox on the screen. Process
          input from the user to move and/or resize
          displayBox until the select function is
          issued."
     savedDisplay := Form
         fromDisplay: (0@0 extent: Display extent).
     displayBox draw.
     [true]
         whileTrue: [self processKey: Terminal read]!
 processKey: aCharacter
         "Private - Show the adjusted displayBox after
          processing the input aCharacter."
     | result |
     result := super processKey: aCharacter.
     savedDisplay
         displayOn: Display
         at: 0 @ 0
         clippingBox: displayBox
         rule: Form over
         mask: 0.
     self adjustBox.
     displayBox draw!
 return: aBlock
         "Private - Set returnBlock to aBlock and
          then invoke the loop for getting
          the user input."
     | cursor |
     returnBlock := aBlock.
     self adjustBox.
     self processInput!
 select
         "Private - The select function has been issued
          by the user. Restore the display and
          evaluate the returnBlock."
     savedDisplay display.
     returnBlock value: Cursor offset! !

! ScreenDispatcher class methods !
 initializeFor: screenColor
         "Private - Initialize the system menu depending on
          the screenColor Symbol (#color or #monochrome)."
     super initialize.
     screenColor == #color
         ifTrue: [
             ScreenMenu := Menu
                 labels: 'color screen\exit Methods\browse disk\open workspace\browse classes\redraw screen\save image' withCrs
                 lines: Array new
                 selectors: #(color exit openDiskBrowser openWorkspace openClassBrowser redraw save )]
         ifFalse: [
             ScreenMenu := Menu
                 labels: ' \exit Methods\browse disk\open workspace\browse classes\redraw screen\save image' withCrs
                 lines: Array new
                 selectors: #(continue exit openDiskBrowser openWorkspace openClassBrowser redraw save )]!
 systemMenu
         "Answer the system menu."
     ^ScreenMenu! !

! ScreenDispatcher methods !
 activateWindow
         "Make the background window active.  Begin
          the loop to process input to the background
          window."
     active := true.
     [self active]
         whileTrue: [self processKey: Terminal read]!
 close
         "Report an error. The background window can not be closed."
     self doesNotHandle!
 color
         "Pop-up the color Menu to let the user
          select a screen background color."
     | color cursor |
     (color := Menu pickColor) == nil
         ifFalse: [
             color := color * 16 +
                 (color == Black
                     ifTrue: [White]
                     ifFalse: [Black]).
             cursor := Cursor offset.
             Display setBorderTo: color // 16.
             ScreenBackground := ScreenColor := color.
             Cursor offset: cursor.
             Scheduler resume]!
 continue
         "Do nothing and answer nil."
     ^nil!
 cycle
         "Cycle the windows."
     Scheduler cycle!
 cyclePane
         "Same as cycling windows since screen
          background has no panes."
     self cycle!
 exit
         "Pop-up the exit menu."
     (Menu
         labels: ' forget image \   continue\  save image' withCrs
         lines: Array new
         selectors: #(forgetImage continue saveImage))
             popUpAt: Cursor offset for: self!
 forgetImage
         "Exit Methods without saving the image."
     (Sources at: 2)
         setToEnd;
         flush.
     Methods exit: true!
 openClassBrowser
         "Open a class hierarchy browser."
     ClassHierarchyBrowser new
         openOn: (Array with: Object)!
 openDiskBrowser
         "Prompt the user for a disk device and then open a
          disk browser on it."
     | deviceCharacter |
     deviceCharacter := Prompter
         prompt: 'disk device letter?'
         default: 'a'.
     (deviceCharacter == nil or: [deviceCharacter isEmpty])
         ifFalse: [
             DiskBrowser new openOn: (deviceCharacter at: 1)]!
 openWorkspace
         "Open an empty workspace for editing."
     '' edit!
 processFunctionKey: aKey
         "Private - Process function keys input from
          the keyboard and mouse."
     (WindowMenuRequest == aKey or: [PaneMenuRequest == aKey])
         ifTrue: [
             ^self class systemMenu
             popUpAt: Cursor offset for: self].
     super processFunctionKey: aKey!
 redraw
         "Redraw the display screen."
     Scheduler display!
 save
         "Save the current image and log the event
          on the change log."
     Display background.
     'Saving image on file: image,' displayAt: 26 @ 11.
     'please wait...' displayAt: 33 @ 14.
     Disk makeCurrent.
     self dosError: Methods save.
     Methods logEvaluate:
         '"*** saved image on: '
         , Date today printString, ' '
         , Time now printString, ' ***"'.
     (Sources at: 2) flush.
     Scheduler display!
 saveImage
         "Save the current image and exit Methods."
     self save.
     Methods exit: true!
 select
         "Make the ScreenDispatcher inactive.
          This will cause the ScreenDispatcher
          to exit and the Scheduler will search
          for the active window."
     active := false! !

! ScrollDispatcher class methods !
 initialize
         "Private - Initialize PageScroll to false."
     PageScroll := false! !

! ScrollDispatcher methods !
 amountToPageLeft
         "Answer a half of the pane frame width
          as the amount for scrolling left."
     ^pane frame width + 1 // 2!
 amountToPageUp
         "Answer the pane frame height minus one
          as the amount for scrolling up."
     ^pane frame height - 1 max: 1!
 amountToScrollLeft
         "Answer the number of characters to scroll left."
     ^PageScroll
         ifTrue: [self amountToPageLeft]
         ifFalse: [4 min: pane frame width]!
 amountToScrollUp
         "Answer the number of lines to scroll up."
     ^PageScroll
         ifTrue: [self amountToPageUp]
         ifFalse: [1]!
 continueScroll
         "Private - If the cursor is within the current pane, it
          is not a continuous scroll, answer false.  Else
          perform the continuous scroll and answer true."
     | curLoc frame |
     frame := pane frame.
     curLoc := Cursor offset.
     (frame containsPoint: curLoc)
         ifTrue: [^false].
     [curLoc y < frame top
         ifTrue: [self scrollUpAt: curLoc]
         ifFalse: [
             curLoc y > frame bottom
                 ifTrue: [self scrollDownAt: curLoc]
                 ifFalse: [
                     curLoc x < frame left
                         ifTrue: [
                             pane
                                 scrollLeft: self amountToScrollLeft negated;
                                 showPane]
                         ifFalse: [
                             pane
                                 scrollLeft: self amountToScrollLeft;
                                 showPane]
                         ]].
      Cursor isThereInput]
         whileFalse: [].
     ^true!
 mouseScroll
         "Private - Perform mouse scroll."
     | oldLoc char |
     oldLoc := Terminal mouseOffset.
     [true] whileTrue: [
         char := Terminal read.
         char == ScrollDownFunction
             ifTrue: [
                 oldLoc isNil
                     ifTrue: [^self]
                     ifFalse: [ "hand move"
                         ^pane
                             scrollHand: oldLoc
                             to: Cursor offset]].
         char == SetLoc
             ifTrue: [
                 self continueScroll
                     ifTrue: [oldLoc := nil]]
             ifFalse: [
                 char = PaneMenuRequest
                     ifTrue: [^self]]]!
 processFunctionKey: aCharacter
         "Private - Process scrolling related
          input from keyboard or mouse."
     aCharacter == ScrollUpFunction
         ifTrue: [
             MouseEvent
                 ifTrue: [
                     PageScroll := false.
                     ^self mouseScroll]
                 ifFalse: [^pane scrollUp: self amountToScrollUp]].
     aCharacter == PageUpFunction
         ifTrue: [
             MouseEvent
                 ifTrue: [
                     PageScroll := true.
                     ^self mouseScroll]
                 ifFalse: [^pane scrollUp: self amountToPageUp]].
     aCharacter == ScrollDownFunction
         ifTrue: [
             PageScroll := false.
             ^pane scrollUp: self amountToScrollUp negated].
     aCharacter == PageDownFunction
         ifTrue: [^pane scrollUp: self amountToPageUp negated].
     aCharacter == ScrollLeftFunction
         ifTrue: [^pane scrollLeft: self amountToScrollLeft].
     aCharacter == PageLeftFunction
         ifTrue: [^pane scrollLeft: self amountToPageLeft].
     aCharacter == ScrollRightFunction
         ifTrue: [^pane scrollLeft: self amountToScrollLeft negated].
     aCharacter == PageRightFunction
         ifTrue: [^pane scrollLeft: self amountToPageLeft negated].
     super processFunctionKey: aCharacter!
 scrollDelay: cursor
         "Private - Perform a delay between each scroll of a
          continuous scroll.  For page scroll, the
          delay time is a constant.  For line scroll,
          it is a function of the distance between the
          cursor and the top-right corner of the
          current pane."
     | delay lineDelay pageDelay frame time |
     pageDelay := 4.       "delay between page scrolls"
     lineDelay := 5.        "delay between line scrolls"
     PageScroll
         ifTrue: [delay := pageDelay]
         ifFalse: [
             frame := pane frame.
             delay := lineDelay
                 * (frame corner x - cursor x)
                 // frame width].
     time := Time mouseClockValue.
     [delay > 0]
         whileTrue: [
             Time mouseClockValue = time
                 ifFalse: [
                     time := Time mouseClockValue.
                     delay := delay - 1]]!
 scrollDownAt: curLoc
         "Private - Perform a downward scroll and
          use the point curLoc to calculate the
          delay time after the scroll."
     PageScroll := curLoc x > pane frame right.
     pane
         scrollUp: self amountToScrollUp;
         showPane.
     ^self scrollDelay: curLoc!
 scrollUpAt: curLoc
         "Private - Perform an upward scroll and
          use the point curLoc to calculate the
          delay time after the scroll."
     PageScroll := curLoc x > pane frame right.
     pane
         scrollUp: self amountToScrollUp negated;
         showPane.
     ^self scrollDelay: curLoc! !

! ListSelector class methods ! !

! ListSelector methods !
 processKey: aKey
         "Private - Let the superclass process the input key
          and then reverse the line where the
          cursor is positioned."
     super processKey: aKey.
     self isControlActive
         ifTrue: [pane showCursorLine]!
 select
         "Private - Inform the pane to select the line where
          the cursor is positioned."
     pane selectAtCursor! !

! TextEditor class methods !
 initialize
         "Private - Send initialize message to superclass
          and initialize the standard edit menu."
     super initialize.
     StandardEditMenu := Menu
         labels: 'copy\cut\paste\show it\do it\save\restore' withCrs
         lines: #()
         selectors: #(copySelection cutSelection
                      pasteSelection printIt doIt accept cancel)!
 initializeTranscript
         "Private - create the system transcript
          window."
     | topPane |
     SystemTranscript := self new.
     topPane := TopPane new.
     topPane
         label: 'System Transcript';
         model: topPane dispatcher;
         menu: #transcriptMenu;
         addSubpane:
             (TextPane new
                 dispatcher: SystemTranscript;
                 model: 'Welcome to Methods Version 1.1
 Copyright 1985 Digitalk, Inc.';
                 yourself)!
 menu
         "Answer StandardEditMenu."
     ^StandardEditMenu!
 systemTranscript
         "Answer SystemTranscript."
     ^SystemTranscript! !

! TextEditor methods !
 accept
         "Save the modified text."
     modified ifTrue: [
         pane topPane flashLabel.
         modified := pane accept not.
         pane topPane unflashLabel]!
 backspace
         "Delete a non-gap selection or the
          preceding character of a gap selection."
     pane hideSelection.
     priorSelection :=  pane selection.
     pane isGapSelection
         ifTrue: [priorSelection origin > (1@0)
             ifTrue: [priorSelection
                         origin: priorSelection corner
                         corner: priorSelection corner]
             ifFalse: [pane backspaceSelection]].
     CopyBuffer := priorText := pane selectedString.
     newSelection := priorSelection origin
         corner: priorSelection origin - (1@0).
     pane replaceWithText: nil.
     modified := true.
     pane
         selectAfter: newSelection corner;
         forceSelectionOntoDisplay!
 cancel
         "Restore the last saved version of the text."
     modified := false.
     pane topPane flashLabel.
     pane
         cancel;
         selectAfter: 0@1;
         forceSelectionOntoDisplay.
     pane topPane unflashLabel!
 compilerError: aString at: anInteger in: codeString
         "Display the error message aString in reversed
          form at the indicated position anInteger
          in the source codeString."
     | origin corner box location |
     location := anInteger max: 1.
     pane
         hideSelection;
         selectAtEnd;
         selectFrom: 1@1 to: pane selection corner.
     box := pane replaceWithText:
         (codeString copyFrom: 1 to: location - 1).
     corner := 1 @ (box corner y + 1).
     (location > 1 and: [(codeString at: location - 1) == Lf])
         ifTrue: [
             origin := corner.
             pane selectBefore: corner]
         ifFalse: [
             origin := box corner + (1@0).
             pane selectAtEnd].
     box := pane replaceWithText: aString trimBlanks.
     pane selectAtEnd.
     corner := box corner.
     pane
         replaceWithText: (codeString copyFrom: location to: codeString size);
         selectFrom: origin to:  corner;
         forceSelectionOntoDisplay!
 copySelection
         "Place the selected text in the copy buffer."
     pane hideSelection.
     CopyBuffer := priorText := pane selectedString.
     priorSelection := newSelection := pane selection.
     pane
         selectAfter: newSelection corner;
         forceSelectionOntoDisplay!
 cr
         "Append a line-feed to the end of the
          text in the pane."
     ^self nextPut: Lf!
 crTab
         "Append a line-feed and a tab to the end of the
          text in the pane."
     self nextPut: Lf.
     ^self nextPut: Tab!
 crTab: anInteger
         "Append a line-feed and anInteger number
          of tabs to the end of the text in the pane."
     self nextPut: Lf.
     anInteger timesRepeat: [self nextPut: Tab]!
 cutSelection
         "Remove the selected text and
          place it in copy buffer."
     pane hideSelection.
     CopyBuffer := priorText := pane selectedString.
     priorSelection :=  pane selection.
     newSelection := priorSelection origin
         corner: priorSelection origin - (1@0).
     pane replaceWithText: nil.
     modified := true.
     pane
         selectAfter: newSelection corner;
         forceSelectionOntoDisplay!
 doIt
         "Evaluate the selected text."
     ^pane doIt!
 fileItIn
         "Compile and evaluate the selected text
          (in change log format)."
     pane topPane flashLabel.
     (ReadStream on: pane selectedString) fileIn.
     pane
         hideSelection;
         selectAfter: pane selection corner;
         forceSelectionOntoDisplay.
     pane topPane unflashLabel!
 initialize
         "Private - Initialize instance variables."
     priorSelection := nil.
     priorText := nil.
     newSelection := nil.
     modified := false.
     super initialize!
 modified
         "Answer true if the text has been modified
          since the last save, else answer false."
     ^modified!
 modified: aBoolean
         "Change modified to aBoolean."
     modified := aBoolean!
 nextPut: aCharacter
         "Add aCharacter at the end of the text in the pane."
     pane appendChar: aCharacter!
 nextPutAll: aString
         "Add aString at the end of the text in the pane."
     | lastIndex |
     (aString == nil or: [aString isEmpty])
         ifTrue: [^self].
     lastIndex := 1.
     1 to: aString size do: [ :index |
         (aString at: index) == Lf
             ifTrue: [
                 pane appendText:
                     (aString copyFrom: lastIndex to: index - 1).
                 pane appendChar: Lf.
                 lastIndex := index + 1]].
     pane appendText:
         (aString copyFrom: lastIndex to: aString size)!
 pasteSelection
         "Replace the selected text with
          the copy buffer contents."
     pane hideSelection.
     priorText := pane selectedString.
     priorSelection := pane selection.
     newSelection := pane replaceWithText: CopyBuffer.
     modified := true.
     pane
         selectAfter: newSelection corner;
         forceSelectionOntoDisplay!
 positionAtBeginning
         "Select at the beginning of the text in the pane."
     pane
         selectBefore: 1@1;
         forceSelectionOntoDisplay!
 printIt
         "Evaluate the selected text.  Send the
          result the message printString.  Display
          the result of printString immediately
          after the text that was evaluated."
     | answer |
     answer := (pane doIt: [
         pane topPane unflashLabel.
         ^self]) printString.
     pane selectTo:
         (pane replaceWithText: ' ', answer)
                 corner;
         hideSelection;
         displayChanges;
         forceSelectionOntoDisplay!
 processControlKey: aCharacter
         "Private - Process control keys like back-space,
          carriage-return, line-feed, and tab."
     Bs == aCharacter
         ifTrue: [^self backspace].
     (Cr == aCharacter or: [Lf == aCharacter])
         ifTrue: [^self processInputKey: Lf].
     Tab == aCharacter
         ifTrue: [^self processInputKey: Tab].
     super processControlKey: aCharacter!
 processFunctionKey: aCharacter
         "Private - Process function keys from the
          keyboard or mouse."
     SelectFunction == aCharacter
         ifTrue: [^self selectAtCursor].
     SelectToFunction == aCharacter
         ifTrue: [^self selectToShifted].
     SetLoc == aCharacter
         ifTrue: [
             Terminal mouseSelectOn
                 ifTrue: [^self selectToCursor]].
     super processFunctionKey: aCharacter!
 processInputKey: key
         "Private - For a non-gap selection, replace
          the selected text with the key. For a gap
          selection, insert the key at the selection."
     pane isGapSelection
         ifFalse: [pane hideSelection].
     newSelection := pane replaceWithChar: key.
     modified := true.
     pane
         selectAfter: newSelection corner;
         forceSelectionOntoDisplay!
 selectAtCursor
         "Inform the pane to make a gap selection
          at the cursor position."
     pane selectAtCursor!
 selectToCursor
         "Inform the pane to extend the selection to
          the cursor position."
     pane selectToCursor!
 selectToShifted
         "Inform the pane to extend the selection to
          the cursor position.  This is used for the
          combination of the shift key and mouse
          select button."
     pane selectToShifted!
 show: aString
         "Add aString at the end of the text in the pane
          and force it to be shown on the display screen."
     self nextPutAll: aString.
     pane forceEndOntoDisplay!
 space
         "Append a space to the end of the text in the pane."
     ^self nextPut: Space!
 tab
         "Append a tab to the end of the text in the pane."
     ^self nextPut: Tab! !

! PromptEditor class methods ! !

! PromptEditor methods !
 accept
         "Inform the pane to accept the response of
          the Prompter. Set modified to false
          if the pane accepts it, else set it to true."
     modified := true.
     modified := pane accept not!
 processControlKey: aCharacter
         "Private - If aCharacter is carriage-return or
          line-feed, treat it as user's acceptance of
          the response, else do nothing."
     (Cr == aCharacter or: [Lf == aCharacter])
         ifTrue: [^self accept].
     super processControlKey: aCharacter!
 processFunctionKey: aCharacter
         "Private - Process selection, menu request, and
          cursor movements while keeping the cursor
          within the prompter (mouse movements can
          still go out of the prompter)."
     | cursorBounds priorOffset |
     priorOffset := Cursor offset.
     cursorBounds :=
         [(pane frame containsPoint: Cursor offset)
             ifFalse: [
                 Cursor offset: priorOffset.
                 Terminal bell]].
     aCharacter == EndSelectFunction
         ifTrue: [
             (pane frame containsPoint: Cursor offset)
                 ifFalse: [Terminal bell]].
     aCharacter == LeftFunction
         ifTrue: [
             Cursor left.
             ^cursorBounds value].
     aCharacter == RightFunction
         ifTrue: [
             Cursor right.
             ^cursorBounds value].
     aCharacter == UpFunction
         ifTrue: [^Terminal bell].
     aCharacter == DownFunction
         ifTrue: [^Terminal bell].
     aCharacter == JumpLeftFunction
         ifTrue: [
             Cursor jumpLeft.
             ^cursorBounds value].
     aCharacter == JumpRightFunction
         ifTrue: [
             Cursor jumpRight.
             ^cursorBounds value].
     aCharacter == JumpDownFunction
         ifTrue: [^Terminal bell].
     aCharacter == JumpUpFunction
         ifTrue: [^Terminal bell].
     aCharacter == CycleFunction
         ifTrue: [^Terminal bell].
     aCharacter == WindowMenuRequest
         ifTrue: [^Terminal bell].
     super processFunctionKey: aCharacter!
 processInput
         "Private - This is the main processing loop
          in a Prompter.  It gets input from the user
          and invokes the other methods to process it."
     pane activatePane.
     [self active]
         whileTrue: [self processKey: Terminal read].
     pane deactivatePane! !

! TopDispatcher class methods !
 initializeFor: screenMode
         "Set up the standard window menu depending
          on screenMode (#color or #monochrome)."
     screenMode == #color
         ifTrue: [
             TopPaneMenu := Menu
                 labels: 'color\collapse\cycle\frame\move\close' withCrs
                 lines: #()
                 selectors: #(color collapse cycle frame move closeIt).
             TranscriptMenu := Menu
                 labels: 'color\cycle\frame\move' withCrs
                 lines: #()
                 selectors: #(color cycle frame move).
             WorkSpaceMenu := Menu
                 labels: 'color\collapse\cycle\frame\move\close\label' withCrs
                 lines: #()
                 selectors: #(color collapse cycle frame move closeIt newLabel)]
         ifFalse: [
             TopPaneMenu := Menu
                 labels: 'collapse\cycle\frame\move\close' withCrs
                 lines: #()
                 selectors: #(collapse cycle frame move closeIt).
             TranscriptMenu := Menu
                 labels: 'cycle\frame\move' withCrs
                 lines: #()
                 selectors: #(cycle frame move).
             WorkSpaceMenu := Menu
                 labels: 'label\collapse\cycle\frame\move\close' withCrs
                 lines: #()
                 selectors: #(newLabel collapse cycle frame move closeIt)]!
 menu
         "Answer the standard menu for windows."
     ^TopPaneMenu! !

! TopDispatcher methods !
 background
         "Let user select a color from the color
          menu and change the window background
          to that color."
     | color |
     (color := Menu pickColor) == nil
         ifFalse: [
             self deactivateWindow.
             self background: color.
             pane
                 displayWindow;
                 activateWindow]!
 background: aColorAttribute
         "Change the window background color
          to aColorAttribute."
     pane background: aColorAttribute!
 collapse
         "Collapse the window so that only
          its label is shown."
     pane collapse.
     Scheduler resume!
 color
         "Pop up a menu to let user decide whether
          to color the text or window background."
     (Menu
         labels: ' color text \color window' withCrs
         lines: #()
         selectors: #(foreground background))
             popUpAt: Cursor offset for: self!
 deactivateWindow
         "Deactivate the receiver window."
     active
         ifTrue: [pane deactivateWindow]!
 flashLabel
         "Inform the top pane to flash the window label
          signaling work in process."
     pane topPane flashLabel!
 foreground
         "Let the user select a color from the color
          menu and change the window text
          to that color."
     | color |
     (color := Menu pickColor) == nil
         ifFalse: [
             self deactivateWindow.
             self foreground: color.
             pane
                 displayWindow;
                 activateWindow]!
 foreground: aColorAttribute
         "Change the window's text color
          to aColorAttribute."
     pane foreground: aColorAttribute!
 frame
         "Reframe the window."
     self deactivateWindow.
     pane reframe.
     self homeCursor.
     Scheduler resume!
 highlightLabel
         "Inform the top pane to highlight the window
          label signaling the active window."
     pane highlightLabel!
 homeCursor
         "Move the cursor to home position of
          the first subpane."
     pane collapsed
         ifTrue: [
             Cursor offset:
                 (pane frame origin + (1 @ 0))]
         ifFalse: [pane cyclePane: pane]!
 isControlActive
         "Answer true if the receiver is the
          topDispatcher and its window has the cursor
          and the cursor is not in any subpanes, else
          answer false."
     ^self == Scheduler topDispatcher
         and: [pane hasCursor
             and: [pane searchForActivePane == pane]]!
 label
         "Prompt the user for a new label of
          the window and answer the label."
     ^Prompter
         prompt: 'New Label?'
         default: ''!
 label: aString
         "Change the window label to aString."
     pane
         label: aString;
         displayWindow!
 move
         "Move the window to a new position on
          the display screen."
     self deactivateWindow.
     pane move.
     self homeCursor.
     Scheduler resume!
 newLabel
         "Label the receiver window."
     self changed: #label!
 processInput
         "Private - This is the main processing
          loop for handling input for a TopPane."
     pane activatePane.
     [self isControlActive]
         whileTrue: [self processKey: Terminal read]!
 recolor
         "Inform the top pane to recolor the window."
     pane recolor!
 select
         "Deactivate the window if it does not
          have the cursor, else ring the bell."
     pane hasCursor
         ifTrue: [self doesNotHandle]
         ifFalse: [self deactivateWindow]!
 transcriptMenu
         "Answer the menu for the System Transcript
          window."
     ^TranscriptMenu!
 unflashLabel
         "Inform the top pane to stop flashing the window
          label signaling work done."
     pane topPane unflashLabel!
 workSpaceMenu
         "Answer the menu for the work space window."
     ^WorkSpaceMenu! !

! DispatchManager class methods !
 initialize
         "Private - Initialize the class variable None to
          a ScreenDispatcher."
     None := ScreenDispatcher new!
 new
         "Answer a DispatchManager with no
          dispatchers."
     ^super new setDispatchers! !

! DispatchManager methods !
 cycle
         "Rotate the order of the windows known to the receiver."
     dispatchers isEmpty
         ifFalse: [
             dispatchers first deactivateWindow.
             (dispatchers addFirst: dispatchers removeLast)
                 homeCursor].
     self runMethods!
 dispatchers
         "Answer the OrderedCollection
          containing the dispatchers
          known to the receiver."
     ^dispatchers!
 display
         "Display all the windows known to the receiver."
     Display background.
     dispatchers reverseDo: [ :dispatcher |
         dispatcher display]!
 includes: aDispatcher
         "Answer true if aDispatcher is included in the
          receiver, else answer false."
     ^dispatchers includes: aDispatcher!
 reinitialize
         "Close all the windows including the Transcript
          and then create a new Transcript."
     dispatchers copy do: [ :i | i closeWindow].
     Object initDependents.
     TextEditor initializeTranscript.
     Transcript := TextEditor systemTranscript.
     self display.
     Transcript open scheduleWindow!
 remove: aDispatcher
         "Remove aDispatcher from the
          receiver collection of dispatchers."
     dispatchers remove: aDispatcher ifAbsent: []!
 resume
         "Restart the main processing
          loop of the user interface."
     dispatchers isEmpty
         ifFalse: [dispatchers first deactivateWindow].
     self
         display;
         runMethods!
 runMethods
         "Drop all the pending message sends, restart
          the main processing loop by searching for the window
          containing the cursor and giving it control."
     Process dropSenderChain.
     [true] whileTrue: [
         self searchForActiveDispatcher activateWindow.
         dispatchers isEmpty
             ifFalse: [dispatchers first deactivateWindow]]!
 schedule: aDispatcher
         "Activate the window associated with aDispatcher."
     dispatchers isEmpty
         ifFalse: [
             dispatchers first deactivateWindow.
             dispatchers remove: aDispatcher ifAbsent: []].
     dispatchers addFirst: aDispatcher.
     self runMethods!
 searchForActiveDispatcher
         "Private - Search for the window containing the cursor
          and make it the top one. Answer its dispatcher."
     | active |
     active := dispatchers
         detect: [:c| c isControlWanted]
         ifNone: [^None].
     active == dispatchers first
         ifFalse: [
             dispatchers addFirst:
                 (dispatchers remove: active)].
     ^active!
 setDispatchers
         "Private - Initialize the receiver to
          contain an empty collection of
          dispatchers."
     dispatchers := OrderedCollection new!
 systemDispatcher
         "Answer the screen dispatcher."
     ^None!
 topDispatcher
         "Answer the dispatcher for the top window."
     dispatchers isEmpty
         ifTrue: [^None]
         ifFalse:[^dispatchers first]! !

! DisplayObject class methods ! !

! DisplayObject methods !
 boundingBox
         "Answer a Rectangle with offset as its
          origin and with width and height as its
          extent."
     ^Rectangle origin: offset extent: self extent!
 display
         "Show the receiver on the display screen."
     self displayOn: Display!
 displayAt: aPoint
         "Show the receiver on the display screen
          at aPoint."
     self displayOn: Display at: aPoint!
 displayOn: aDisplayMedium
         "Show the receiver on aDisplayMedium at
          the top-left corner."
     ^self
         displayOn: aDisplayMedium
         at: 0 @ 0
         clippingBox: (0@0 extent: aDisplayMedium extent)
         rule: Form over
         mask: Form nothing!
 displayOn: aDisplayMedium at: aPoint
         "Show the receiver on aDisplaymedium
          at aPoint."
     ^self
         displayOn: aDisplayMedium
         at: aPoint
         clippingBox: (0@0 extent: aDisplayMedium extent)
         rule: Form over
         mask: Form nothing!
 displayOn: aDisplayMedium
     at: aPoint
     clippingBox: aRectangle
         "Show the receiver on aDisplaymedium
          at aPoint with aRectangle as
          the clipping rectangle."
     ^self
         displayOn: aDisplayMedium
         at: aPoint
         clippingBox: aRectangle
         rule: Form over
         mask: Form nothing!
 displayOn: aDisplayMedium
     at: aPoint
     clippingBox: aRectangle
     rule: anInteger
         "Show the receiver on aDisplaymedium
          at aPoint with aRectangle as the
          clipping rectangle and anInteger
          as the combination rule."
     ^self
         displayOn: aDisplayMedium
         at: aPoint
         clippingBox: aRectangle
         rule: anInteger
         mask: Form nothing!
 displayOn: aDisplayMedium
     at: aPoint
     clippingBox: aRectangle
     rule: anInteger
     mask: maskInteger
         "Show the receiver on aDisplaymedium
          at aPoint with aRectangle as
          the clipping rectangle, anInteger
          as the combination rule, and maskInteger
          as the halftone."
     |aByteBlt|
     aByteBlt:= ByteBlt
         destForm: aDisplayMedium
         sourceForm: self
         halftone: maskInteger
         combinationRule: anInteger
         destOrigin: aPoint + offset
         sourceOrigin: 0 @ 0
         extent: aDisplayMedium extent
         clipRect: aRectangle.
     ^aByteBlt copyBytes!
 extent
         "Answer a Point describing the width
          and height of the receiver."
     ^(width @ height)!
 height
         "Answer the height of the receiver."
     ^height!
 offset
         "Answer the offset of the receiver."
     ^offset!
 offset: aPoint
         "Change the offset to aPoint."
     offset := aPoint!
 rounded
         "Round the offset of the receiver to
          the nearest integer."
     offset := offset rounded!
 setWidth: w height: h
         "Change the width to w, height to h,
          and offset to the top-left corner."
     width := w.
     height := h.
     offset := 0@0!
 translateBy: aPoint
         "Add aPoint to offset."
     self offset: offset + aPoint!
 width
         "Answer the width of the receiver."
     ^width! !

! DisplayMedium class methods !
 black
         "Answer a byte representing the
          white on black attribute."
     ^16r7!
 blink
         "Answer a byte representing the
          blink attribute."
     ^16r80!
 bold
         "Answer a byte representing the
          bold (high intensity) attribute."
     ^16r8!
 nothing
         "Answer a byte representing the
          zero (black on black) attribute."
     ^0!
 white
         "Answer a byte representing the
          black on white attribute."
     ^16r70! !

! DisplayMedium methods !
 attrMap
         "Answer the instance variable attrMap."
     ^attrMap!
 black
         "Black out the receiver."
     self
         fill: (0 @ 0 extent: self extent)
         rule: Form over
         color: InfiniteForm black!
 black: aRectangle
         "Black out aRectangle area of
          the receiver."
     self
         fill: aRectangle
         rule: Form over
         color: InfiniteForm black!
 blink
         "Blink the receiver."
     self
         fill: (0 @ 0 extent: self extent)
         rule: Form under
         mask: Form blink!
 blink: aRectangle
         "Blink aRectangle area of the receiver."
     self
         fill: aRectangle
         rule: Form under
         mask: Form blink!
 bold
         "Bold the receiver foreground."
     self
         fill: (0 @ 0 extent: self extent)
         rule: Form under
         mask: Form bold!
 bold: aRectangle
         "Bold aRectangle area of the
          receiver foreground."
     self
         fill: aRectangle
         rule: Form under
         mask: Form bold!
 fill: aRectangle mask: anAttributeByte
         "Replace each attribute byte in
          the receiver with anAttributeByte."
     self
         fill: aRectangle
         rule: Form over
         mask: anAttributeByte!
 fill: aRectangle rule: rule color: aForm
         "Combine the content of aForm
          to aRectangle area of the
          receiver by rule."
     (ByteBlt
         destForm: self
         sourceForm: aForm
         halftone: 0
         combinationRule: rule
         destOrigin: aRectangle origin
         sourceOrigin: 0 @ 0
         extent: aRectangle extent
         clipRect: (0@0 extent: self extent))
             copyBytes!
 fill: aRectangle rule: rule mask: anAttributeByte
         "Combine anAttributeByte to each attribute
          byte in aRectangle area of the receiver
          by rule."
     (ByteBlt
         destForm: self
         sourceForm: nil
         halftone: anAttributeByte
         combinationRule: rule
         destOrigin: aRectangle origin
         sourceOrigin: 0 @ 0
         extent: aRectangle extent
         clipRect: (0@0 extent: self extent))
             copyBytes!
 reverse
         "Reverse the color of the receiver."
     self
         fill: (0 @ 0 extent: self extent)
         rule: Form reverse
         mask: ReverseMask!
 reverse: aRectangle
         "Reverse the color of aRectangle area
          of the receiver."
     self
         fill: aRectangle
         rule: Form reverse
         mask: ReverseMask!
 reverse: aRectangle with: anAttribute
         "Wherever anAttribute byte contains a
          one bit, reverse the corresponding bit
          of the attribute bytes in aRectangle
          area of the receiver."
     self
         fill: aRectangle
         rule: Form reverse
         mask: anAttribute!
 reverseMask: anAttribute
         "Wherever anAttribute byte contains
          a one bit, reverse the corresponding
          bit of all the attribute bytes in
          the receiver."
     self
         fill: (0 @ 0 extent: self extent)
         rule: Form reverse
         mask: anAttribute!
 setWidth: w height: h
         "Set width to w and height to h. Also
          initialize attrMap with a ByteArray
          the size of w * h."
     (attrMap == nil or: [attrMap size ~= (w * h)])
         ifTrue: [attrMap := ByteArray new: w * h].
     super setWidth: w height: h!
 white
         "White out the receiver."
     self
         fill: (0 @ 0 extent: self extent)
         rule: Form over
         color: InfiniteForm white!
 white: aRectangle
         "White out aRectangle area of the
          receiver."
     self
         fill: aRectangle
         rule: Form over
         color: InfiniteForm white! !

! Form class methods !
 destination
         "Answer the combination rule which
          yields the destinaton attributes unchanged."
     ^5!
 erase
         "Answer the combination rule which
          erases (sets to zero) the destinaton
          attribute bits if the corresponding
          source attribute bits are ones."
     ^4!
 fromDisplay: aRectangle
         "Answer a new Form whose content is
          taken from aRectangle area of
          the display screen."
     ^self new fromDisplay: aRectangle!
 over
         "Answer the combination rule which
          replaces the destination attributes
          with the source attributes."
     ^3!
 reverse
         "Answer the combination rule which
          combines the source attributes with the
          destination attributes by a logical XOR."
     ^6!
 under
         "Answer the combination rule which
          combines the source attributes with the
          destination attributes by logical OR."
     ^7! !

! Form methods !
 charMap
         "Answer the instance variable charMap."
     ^charMap!
 extent: aPoint
         "Change the receiver width and
          height to the components of aPoint
          and initialize it to be blank."
     self width: aPoint x height: aPoint y.
     (ByteBlt
         destForm: self
         sourceForm: nil
         halftone: nil
         combinationRule: Form over
         destOrigin: 0@0
         sourceOrigin: 0@0
         extent: aPoint
         clipRect: (0@0 extent: self extent))
             copyBytes!
 fromDisplay: aRectangle
         "Take the receiver content from aRectangle
          area of the display screen."
     self offset: 0@0.
     self width: aRectangle width height: aRectangle height.
     (ByteBlt
         destForm: self
         sourceForm: Display
         halftone: nil
         combinationRule: Form over
         destOrigin: 0@0
         sourceOrigin: aRectangle origin
         extent: aRectangle extent
         clipRect: (0@0 extent: self extent))
             copyBytes!
 width: w height: h
         "Change the receiver width to w and height
          to h, and reinitialize charMap and attrMap."
     (charMap == nil or: [charMap size ~= (w * h)])
         ifTrue: [charMap := String new: w * h].
     super setWidth: w height: h! !

! DisplayScreen class methods ! !

! DisplayScreen methods !
 background
         "Repaint the background on the receiver."
     (InfiniteForm new
         attribute: ScreenBackground;
         character: BackgroundCharacter )
             displayOn: self!
 color
         "Set the mode of the display screen to 80x25
          color mode and initialize the affected variables."
     | cursor |
     MenuBackground := Cyan * 16.
     MenuBorder := Cyan * 16 + Bold + Brown.
     ReverseMask := 16r7.
     ScreenBackground := ScreenColor.
     BorderBackground := 0.
     PaneColors := OrderedCollection new.
     PaneColors
         add: Blue;
         add: Green;
         add: Cyan;
         add: Red;
         add: Magenta;
         add: Brown.
     Scheduler topDispatcher deactivate.
     TopPane initializeFor: #color.
     Menu
         initialize;
         setUpMenusFor: #color.
     cursor := Cursor offset.
     Cursor hide.
     self setMonochrome: false.
     Cursor show.
     self setBorderTo: ScreenBackground // 16.
     Cursor offset: cursor!
 monochrome
         "Set the mode of the display screen
          to 80x25 black and white mode and
          initialize the affected variables."
     | cursor |
     MenuBackground := Black * 16 + Bold + White.
     MenuBorder := Black * 16 + Bold + White.
     ReverseMask := 16r77.
     ScreenBackground := White.
     BorderBackground := 16r7F.
     PaneColors := OrderedCollection with: White.
     TopPane initializeFor: #monochrome.
     Menu setUpMenusFor: #monochrome.
     Scheduler topDispatcher deactivate.
     Scheduler dispatchers do: [ :dispatcher |
         dispatcher
             foreground: Black;
             background: White].
     cursor := Cursor offset.
     Cursor hide.
     self setMonochrome: true.
     Cursor
         show;
         offset: cursor!
 setBorderTo: aColor
         "Set the border color of the display screen to aColor."
     <primitive: 123>!
 setMonochrome: aBoolean
         "Private - Set the mode of the display screen
          to monochrome if aBoolean is true, else set
          it to color."
     <primitive: 122>! !

! DisplayString class methods !
 for: aString
         "Answer a new instance of class DisplayString
          with aString as its content."
     ^self new
         offset: 0@0;
         string: aString! !

! DisplayString methods !
 at: anInteger
         "Answer the character at index
          position anInteger in the receiver."
     ^string at: anInteger!
 at: anInteger put: aCharacter
         "Answer aCharacter.  Replace the character at
          the index position anInteger in the receiver
          with aCharacter."
     ^string at: anInteger put: aCharacter!
 charMap
         "Answer the instance variable string
          as the receiver charMap (to be
          compatible with Form)."
     ^string!
 size
         "Answer the size of the instance
          variable string."
     ^string size!
 string
         "Answer the instance variable
          string."
     ^string!
 string: aString
         "Set the instance variable string
          to aString and initialize width
          and height."
     self setWidth: aString size height: 1.
     string := aString! !

! InfiniteForm class methods !
 black
         "Answer a new instance of InfiniteForm
          with its content initialized as a
          black space."
     ^self new attribute: Form black; character: Space!
 blank
         "Answer a new instance of InfiniteForm
          with its content initialized as a
          black space."
     ^self new
         attribute: Form nothing;
         character: Space!
 new
         "Answer a new instance of InfiniteForm
          with empty content."
     ^super new offset: 0@0; setWidth: 0 height: 0!
 white
         "Answer a new instance of InfiniteForm
          with its content initialized as a
          white space."
     ^self new attribute: Form white; character: Space! !

! InfiniteForm methods !
 attribute
         "Answer the instance variable attribute."
     ^attribute!
 attribute: aByte
         "Set the instance variable attribute
          to aByte."
     attribute := aByte!
 character
         "Answer the instance variable character."
     ^character!
 character: aCharacter
         "Set the instance variable character
          to aCharacter."
     character := aCharacter! !

! Example class methods !
 named: aString
         "Answer an Example with myname set to aString"
     (aString isKindOf: String)
         ifTrue: [^self new name: aString]
         ifFalse: [self error: 'must be a String']! !

! Example methods !
 goodBye
         "Write good bye to my name on the Transcript"
     myname isNil
         ifTrue: [self noNameYet]
         ifFalse: [self goodByeTo: myname]!
 goodByeTo: aString
         "Say good bye to aString in the Transcript"
     Transcript cr.
     Transcript show: 'Good bye ', aString.
     Transcript cr.
     Transcript show: 'Sorry to see you go'!
 hello
         "Write hello to myname in the Transcript"
     myname isNil
         ifTrue: [self noNameYet]
         ifFalse: [self helloTo: myname]!
 helloTo: aString
         "Say hello to aString in the Transcript"
     Transcript cr.
     Transcript show: 'Hello to ', aString!
 name: aString
         "Set my name to aString"
     (aString isKindOf: String)
         ifTrue: [myname := aString]
         ifFalse: [
             Transcript
                 cr; show: 'my name must be a String';
                 cr; show: 'such as: ''John Smith''';
                 cr; show: '    note the quotes']!
 noNameYet
         "Display error in the Transcript"
     Transcript cr.
     Transcript show: 'I don''t have a name yet'! !

! File class methods !
 changeModeOf: fileName to: attrString
         "Change the attributes of the file identified by
          fileName to those of attrString.  Attributes are:
          $r - read only, $h - hidden, $s - system,
          $a - archive (see DOS manual)."
     | attribute |
     attribute := 0.
     (attrString includes: $r)
         ifTrue: [attribute := attribute + 1].
     (attrString includes: $h)
         ifTrue: [attribute := attribute + 2].
     (attrString includes: $s)
         ifTrue: [attribute := attribute + 4].
     (attrString includes: $a)
         ifTrue: [attribute := attribute + 32].
     self dosError: (self
         primitiveChangeModeOf: fileName asAsciiZ
         to: attribute)!
 copy: oldPath to: newPath
         "Copy the file identified by oldPath to the
          file identified by newPath.  Multiple buffers
          are used for fast copying."
     | dir pathNameArray oldFCB newFCB pageSize arrayOfBuffers buffIndex
       startPos currentPos bytesRead done |
     pathNameArray := File splitPath:
         (newPath copyFrom: 3 to: newPath size).
     dir := Directory pathName:
         (String with: (newPath at: 1)), ':',
         (pathNameArray at: 1).
     newFCB := (dir newFile: (pathNameArray at: 2))
         file fileId.
     pathNameArray := File splitPath:
         (oldPath copyFrom: 3 to: oldPath size).
     dir := Directory pathName:
         (String with: (oldPath at: 1)), ':',
         (pathNameArray at: 1).
     oldFCB := (dir file: (pathNameArray at: 2))
         file fileId.
     pageSize := File pageSize.
     arrayOfBuffers := Array new: 64.
     1 to: arrayOfBuffers size do: [ :index |
         arrayOfBuffers at: index put: (String new: pageSize)].
     startPos := 1.
     done := false.
 
     [done]
         whileFalse: [
             buffIndex := 1.
             currentPos := startPos.
 
             [bytesRead := oldFCB
                 readInto: (arrayOfBuffers at: buffIndex)
                 atPosition: currentPos.
              buffIndex := buffIndex + 1.
              currentPos := currentPos + pageSize.
              bytesRead = 512 and: [buffIndex <= arrayOfBuffers size]]
                 whileTrue: [].
 
             buffIndex := buffIndex - 1.
             bytesRead < 512
                 ifTrue: [buffIndex := buffIndex - 1].
             currentPos := startPos.
 
             1 to: buffIndex do: [ :index |
                 newFCB
                     writeFrom: (arrayOfBuffers at: index)
                     toPosition: currentPos
                     for: 512.
                 currentPos := currentPos + pageSize].
 
             bytesRead < 512
                 ifTrue: [
                     newFCB
                         writeFrom: (arrayOfBuffers at: buffIndex + 1)
                         toPosition: currentPos
                         for: bytesRead.
                     done := true]
                 ifFalse: [startPos := currentPos]].
     oldFCB close.
     newFCB close!
 fileName: stringOne extension: stringTwo
         "Answer a String which is a derived file name
          from stringOne and stringTwo. Lower case
          vowels are dropped from the right of stringOne
          until it is less than or equal to 8 characters."
     | size fileName |
     size := stringOne size.
     fileName :=
         (stringOne reversed select: [ :char |
         (char isVowel and: [char isLowerCase])
             ifTrue: [(size := size - 1) < 8]
             ifFalse: [true]]) reversed, '       '.
     ^(fileName copyFrom: 1 to: 8),
         (String with: $.),
         ((stringTwo, '   ') copyFrom: 1 to: 3)!
 open: aString in: aDirectory
         "Answer an instance of the receiver opened on
          a file named aString in aDirectory."
     ^super new
         setName: aString setDirectory: aDirectory!
 pageSize
         "Answer 512, the constant number
          of bytes in a file page."
     ^512!
 primitiveChangeModeOf: fileName to: anInteger
         "Private - Change the attribute byte of
          fileName to anInteger."
     <primitive: 78>
     ^self primitiveFailed!
 primitiveRemove: fileName
         "Private - Remove file fileName."
     <primitive: 117>
     ^self primitiveFailed!
 primitiveRename: oldFileName to: newFileName
         "Private - Rename oldFileName to newFileName."
     <primitive: 77>
     ^self primitiveFailed!
 remove: fileName
         "Erase fileName."
     self dosError:
         (self primitiveRemove: fileName asAsciiZ)!
 rename: oldFileName to: newFileName
         "Change oldFileName to newFileName.
          If drives are specified in the names,
          they must refer to the same one."
     self dosError: (self
         primitiveRename: oldFileName asAsciiZ
         to: newFileName asAsciiZ)!
 splitPath: aPathName
         "Answer an array of two strings, the first is the
          directory path and the second is the file name."
     | lastSlash index dirPath fileName |
     index := 0.
     lastSlash := 0.
     aPathName do: [ :aChar |
         index := index + 1.
         aChar == $\
             ifTrue: [lastSlash := index]].
     lastSlash = 0
         ifTrue: [^Array with: '' with: aPathName].
     dirPath := aPathName copyFrom: 1 to: lastSlash - 1.
     fileName := aPathName copyFrom: lastSlash + 1 to: aPathName size.
     dirPath = ''
         ifTrue: [dirPath := '\'].
     ^Array with: dirPath with: fileName! !

! File methods !
 close
         "Close the receiver file."
     fileId close!
 directory
         "Answer the directory which contains the
          receiver file."
     ^directory!
 fileId
         "Answer the FileControlBlock used to access
          the receiver file."
     ^fileId!
 flush
         "Force all data written to the receiver to be
          recorded on disk.  For DOS, this requires
          closing and re-opening the file."
     fileId close.
     fileId := FileControlBlock open: name in: directory!
 name
         "Answer a String containing the receiver
          file name."
     ^name!
 readBuffer: aString atPosition: anInteger
         "Read the page of receiver file containing
          the position anInteger into aString.  Answer
          the number of bytes read."
     | bytesRead |
     bytesRead := fileId
         readInto: aString
         atPosition: anInteger - 1.
     bytesRead < 0 ifTrue: [self error: 'error reading file'].
     ^bytesRead.!
 setName: aString setDirectory: aDirectory
         "Private - Set the file name and directory
          and open the file."
     name := aString.
     fileId := FileControlBlock
         open: aString
         in: aDirectory.
     directory := aDirectory!
 size    "Answer the receiver file size in bytes."
     ^fileId endByte!
 species
         "Private - The species of a file is String."
     ^String!
 writeBuffer: aString ofSize: size atPosition: anInteger
         "Write size bytes from aString at position
          anInteger in the receiver file."
     fileId
         writeFrom: aString
         toPosition: anInteger - 1
         for: size! !

! Inspector class methods ! !

! Inspector methods !
 accept: codeString from: aDispatcher
         "Private - Compile and evaluate codeString.  Replace
          the selected instance variable with the result
          of the evaluation.  Answer true if there is no
          compilation error, else notify aDispatcher
          as to the error and answer false."
     | result |
     result := Compiler
         evaluate: codeString
         in: object class
         to: object
         notifying: aDispatcher
         ifFail: [^false].
     Methods logEvaluate: codeString.
     instIndex = 1
         ifFalse: [
             object class isBytes
                 ifTrue: [
                     object
                         at: (instIndex - 1)
                         put: result]
                 ifFalse: [
                     object
                         instVarAt: (instIndex  - 1)
                         put: result]].
     self changed: #instance.
     ^true!
 doIt
         "Private - Evaluate the selected text in the
          context of the inspected object."
     | source result selection |
     instPane topPane dispatcher flashLabel.
     source := instPane selectedString.
     result := Compiler
         evaluate: source
         in: object class
         to: object
         notifying: instPane dispatcher
         ifFail: [
             instPane topPane dispatcher
                 unflashLabel;
                 deactivateWindow.
             Scheduler runMethods].
     Methods logEvaluate: source.
     instPane topPane dispatcher unflashLabel.
     selection := instPane selection.
     instPane
         hideSelection;
         selectAfter: selection corner;
         displayChanges;
         showSelection.
     ^result!
 inspectMenu
         "Private - Answer the menu to inspect an
          instance variable."
     ^Menu
         labels: 'inspect'
         lines: Array new
         selectors: #(inspectSelection)!
 inspectSelection
         "Private - Open an inspector on the
          selected instance variable."
     instIndex = 1
         ifTrue:  [object inspect]
         ifFalse: [
             object class isBytes
                 ifTrue: [(object at: (instIndex - 1)) inspect]
                 ifFalse: [
                     (object instVarAt: (instIndex - 1)) inspect]]!
 instance
         "Private - Answer the ASCII representation of
          the selected instance variable."
     instIndex = 1
         ifTrue: [^object printString].
     object class isPointers
        ifTrue: [^(object instVarAt: instIndex - 1) printString]
        ifFalse: [^(object at: instIndex - 1) printString]!
 instVarList
         "Private - Answer an OrderedCollection of
          instance variable names and/or numbers for
          the list pane."
     instIndex := 1.
     instList := OrderedCollection new.
     instList add: 'self'.
     instList := instList,
         object class allInstVarNames .
     object class isVariable
         ifTrue: [
             1 to: object basicSize do: [ :index |
                 instList add: index printString]].
     ^instList!
 openOn: anObject
         "Open an inspector window on anObject.  Define
          the pane sizes and behavior, and shedule the
          window."
     | topPane |
     object := anObject.
     instPane := TextPane new
         model: self;
         name: #instance;
         change: #accept:from:;
         framingBlock: [ :box |
             box origin + (10@0) corner: box corner].
     topPane := TopPane new.
     topPane
         label: 'Inspecting: ', object class printString;
         model: topPane dispatcher;
         menu: #workSpaceMenu;
         minimumSize: 30@5;
         yourself.
     topPane addSubpane:
         (ListPane new
             menu: #inspectMenu;
             model: self;
             name: #instVarList;
             change: #selectInstance:;
             returnIndex: true;
             framingBlock: [ :box |
                 box origin extent: 9@(box height)]).
     topPane addSubpane: instPane.
     topPane dispatcher open scheduleWindow!
 printIt
         "Private - Evaluate the selected text.  Send the
          message printString to the result and display
          the result String as the selected text."
     | answer |
     answer := self doIt printString.
     Cursor offset:
         (instPane formCoordinates: instPane selection origin)
         + instPane frame origin.
     instPane selectTo:
         (instPane replaceWithText: ' ', answer)
                 corner;
         hideSelection;
         displayChanges;
         forceSelectionOntoDisplay!
 selectInstance: anInteger
         "Private - Select the instance variable at
          index position anInteger in the list."
     instIndex := anInteger.
     self changed: #instance! !

! DictionaryInspector class methods ! !

! DictionaryInspector methods !
 accept: codeString from: aDispatcher
         "Private - Compile and evaluate codeString.  Replace
          the selected instance variable with the result
          of the evaluation.  Answer true if there is no
          compilation error, else notify aDispatcher
          as to the error and answer false."
     | result |
     instIndex == nil
         ifTrue: [^false].
     result := Compiler
         evaluate: codeString
         in: object class
         to: object
         notifying: aDispatcher
         ifFail: [^false].
     object
         at: (instList at: instIndex)
         put: result.
     self changed: #instance.
     ^true!
 add
         "Private - Add a new key to the dictionary
          by prompting for a new key expression."
     | key |
     key := Prompter
         prompt: 'new key expression'
         defaultExpression: String new.
     key == nil
         ifFalse: [
             object
                 at: key
                 put: nil.
             self
                 changed: #instVarList;
                 changed: #instance]!
 inspectMenu
         "Private - Answer the dictionary inspector list
          pane menu."
     ^Menu
         labels: 'remove\inspect\add' withCrs
         lines: Array new
         selectors: #(remove inspectSelection add)!
 inspectSelection
         "Private - Open an inspector on the value
          object associated with the selected key."
     instIndex == nil
         ifTrue: [^self].
     (object at: (instList at: instIndex))
         inspect!
 instance
         "Private - Answer an ASCII representation of
          the value associated with the selected key."
     instIndex == nil
         ifTrue: [^String new].
     ^(object at: (instList at: instIndex)) printString!
 instVarList
         "Private - Answer an OrderedCollection of
          key strings for the list pane."
     instIndex := nil.
     (instList := SortedCollection new)
         sortBlock: [:a :b| a printString < b printString];
         addAll: object keys.
     ^instList
         inject: OrderedCollection new
         into: [:list :key| list add: key printString. list]!
 remove
         "Private - Remove the selected key from the
          dictionary."
     instIndex == nil
         ifFalse: [
             object removeKey: (instList at: instIndex).
             self
                 changed: #instVarList;
                 changed: #instance]! !

! Magnitude class methods ! !

! Magnitude methods !
 < aMagnitude
         "Answer true if the receiver is less
          than aMagnitude, else answer false."
     ^self implementedBySubclass!
 <= aMagnitude
         "Answer true if the receiver is less than
          or equal to aMagnitude, else answer false."
     ^self implementedBySubclass!
 = aMagnitude
         "Answer true if the receiver is equal
          to aMagnitude, else answer false."
     ^self implementedBySubclass!
 > aMagnitude
         "Answer true if the receiver is greater
          than aMagnitude, else answer false."
     ^self implementedBySubclass!
 >= aMagnitude
         "Answer true if the receiver is greater than
          or equal to aMagnitude, else answer false."
     ^self implementedBySubclass!
 between: min and: max
         "Answer true if the receiver is greater than or
          equal to min and less than or equal to max,
          else answer false."
     ^(min <= self) and: [self <= max]!
 hash
         "Answer the positive integer hash
          value for the receiver."
     ^self implementedBySubclass!
 max: anObject
         "Answer the receiver if it's greater
          than anObject, else answer anObject."
     self > anObject
         ifTrue:  [^self]
         ifFalse: [^anObject]!
 min: anObject
         "Answer the receiver if it's less
          than anObject, else answer anObject."
     self < anObject
         ifTrue:  [^self]
         ifFalse: [^anObject]! !

! Association class methods !
 key: anObject
         "Answer an instance of class Association
          whose key is initialized to anObject."
     ^self new key: anObject!
 key: aKey value: anObject
         "Answer an instance of class Association
          whose key is initialized to aKey and
          whose value is initialized to anObject."
     ^(self key: aKey) value: anObject! !

! Association methods !
 < anAssociation
         "Answer true if the receiver key is less than
          anAssociation key, else answer false."
     ^key < anAssociation key!
 <= anAssociation
         "Answer true if the receiver key is less than or
          equal to anAssociation key, else answer false."
     ^key <= anAssociation key!
 = anAssociation
         "Answer true if the receiver key is equal
          to anAssociation key, else answer false."
     ^(anAssociation class == Association)
         and: [key = anAssociation key]!
 > anAssociation
         "Answer true if the receiver key is greater
          than anAssociation key, else answer false."
     ^key > anAssociation key!
 >= anAssociation
         "Answer true if the receiver key is greater than or
          equal to anAssociation key, else answer false."
     ^anAssociation key <= key!
 hash
         "Answer the integer hash value for the key
          of the receiver."
     ^key hash!
 key
         "Answer the key of the receiver."
     ^key!
 key: anObject
         "Answer the receiver.  Set the key
          of the receiver to be anObject."
     key := anObject!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     key printOn: aStream.
     aStream nextPutAll: ' ==> '.
     value printOn: aStream!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reinstantiated."
     aStream nextPutAll: 'Association key: ('.
     key storeOn: aStream.
     aStream nextPutAll: ') value: ('.
     value storeOn: aStream.
     aStream nextPut: $)!
 value
         "Answer the value of the receiver."
     ^value!
 value: anObject
         "Answer the receiver.  Set the value
          of the receiver to be anObject."
     value := anObject! !

! Character class methods !
 digitValue: anInteger
         "Answer the character representation of the
          digit anInteger."
     (0 > anInteger or: [35 < anInteger])
         ifTrue: [self error: 'digitValue not in range 0..35'].
     anInteger < 10
         ifTrue: [ "return $0 .. $9"
             ^self value: anInteger + 48]
         ifFalse: [ "return $A .. $Z"
             ^self value: anInteger + 55]!
 new
         "Disallow the instantiation of characters because
          characters are immutable."
     ^self invalidMessage!
 value: anInteger
         "Answer the character whose ASCII
          encoding matches anInteger."
     (0 > anInteger or: [255 < anInteger])
         ifTrue: [
             self error:
                 'Character value out of range 0..255'].
         "The following takes advantage of the fact that in our system
          consecutive characters in the ASCII sequence have consecutive
          object pointer numbers"
     ^($A hash - 65 + anInteger) asObject! !

! Character methods !
 < aCharacter
         "Answer true if the receiver ASCII value
          is less than the ASCII value of aChararacter ,
          else answer false."
     ^asciiInteger < aCharacter asciiValue!
 <= aChararacter
         "Answer true if the receiver ASCII value
          is less than or equal to the
          ASCII value of aChararacter, else answer false."
     ^asciiInteger <= aChararacter asciiValue!
 = aChararacter
         "Answer true if the receiver ASCII value
          is equal to the ASCII value of aChararacter,
          else answer false."
     <primitive: 110>!
 > aChararacter
         "Answer true if the receiver ASCII value
          is greater than the ASCII value of aChararacter,
          else answer false."
     ^asciiInteger > aChararacter asciiValue!
 >= aChararacter
         "Answer true if the receiver ASCII value
          is greater than or equal to the
          ASCII value of aChararacter, else answer false."
     ^aChararacter asciiValue <= asciiInteger!
 asciiValue
         "Answer the number corresponding to
          the ASCII encoding of the receiver."
     ^asciiInteger!
 asLowerCase
         "Answer the lower case value of the receiver
          if it is a letter, else answer the receiver."
     self isUpperCase
         ifTrue: [^(asciiInteger + 32) asCharacter].
     ^self!
 asUpperCase
         "Answer the upper case value of the receiver
          if it is a letter, else answer the receiver."
     self isLowerCase
         ifTrue: [^(asciiInteger - 32) asCharacter].
     ^self!
 deepCopy
         "Answer a copy of the receiver with shallow
          copies of each instance variable.  Because
          characters are immutable (cannot instantiate
          a copy), answer the receiver."
     ^self!
 digitValue
         "Answer a number corresponding to the digit
          value of the receiver."
     (asciiInteger > 47 and: [asciiInteger < 58])
         ifTrue: [ "$0..$9 become 0..9"
             ^asciiInteger - 48].
     (asciiInteger > 64 and: [asciiInteger < 91])
         ifTrue: [ "$A..$Z become 10..35"
             ^asciiInteger - 55].
     self error: 'digitValue requires characters $0..$9, $A..$Z'!
 hash
         "Answer the integer hash value for the receiver."
     <primitive: 75>!
 isAlphaNumeric
         "Answer true if the receiver is in the range of
          characters from 0 to 9 or in the range from a to z
          or in the range from A to Z, else answer false."
     ^self isDigit or: [self isLetter]!
 isDigit
         "Answer true if the receiver is in the range
          of characters from 0 to 9, else answer false."
     ^asciiInteger > 47 and: [asciiInteger < 58]!
 isLetter
         "Answer true if the receiver is in the range of
          of characters from  a and z or in the range from
          A and Z, else answer false."
     ^(asciiInteger > 64 and: [asciiInteger < 91])
         or: [asciiInteger > 96 and: [asciiInteger < 123]]!
 isLowerCase
         "Answer true is the receiver is in the range of
          characters from a to z, else answer false."
     ^asciiInteger > 96 and: [asciiInteger < 123]!
 isSeparator
         "Answer true if the receiver character is either a
          space, tab, carriage-return, line-feed or form-feed
          character, else answer false."
     ^self == Space
         or: [self == Tab
             or: [self == Cr
                 or: [self == Lf
                     or: [self == Ff]]]]!
 isUpperCase
         "Answer true if the receiver is in the range
          of character from A to Z, else answer false."
     ^asciiInteger > 64 and: [asciiInteger < 91]!
 isVowel
         "Answer true if the receiver is any one of the
          characters a,A,e,E,i,I,o,O,u,U, else answer false."
     ^'aAeEiIoOuU' includes: self!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     aStream nextPut: $$.
     aStream nextPut: self!
 shallowCopy
         "Answer a copy of the receiver which shares
          the receiver instance variables.  Because
          characters are immutable (cannot instantiate
          a copy), answer the receiver."
     ^self!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reconstructed."
     self printOn: aStream! !

! Date class methods !
 baseDay
         "Private - Answer a constant to reduce (possibly)
          the date instance variable to a small integer."
     ^30300!
 calendarForMonth: monthName year: yearInteger
         "Answer a String containing the formatted calendar
          for the month Symbol monthName in the year yearInteger."
     | aStream index daysInMonth firstDayIndex daysBlank |
     firstDayIndex := (self newDay: 1 month: monthName
         year: yearInteger) dayIndex.
     aStream := WriteStream on: (String new: 200).
     daysInMonth := self daysInMonth: monthName
         forYear: yearInteger.
     aStream nextPutAll: 'Su Mo Tu We Th Fr Sa'; cr.
     daysBlank := firstDayIndex \\ 7.
     index := 1.
     [index <= daysBlank ]
         whileTrue: [
             aStream nextPutAll: '   '.
             index := index + 1].
     1 to: 9 do: [ :i |
         index > 7
             ifTrue: [
                 index := 1.
                 aStream cr].
         aStream space.
         i printOn: aStream.
         aStream space.
         index := index + 1].
     10 to: daysInMonth do: [ :i |
         index > 7
             ifTrue: [
                 index := 1.
                 aStream cr].
         i printOn: aStream.
         aStream space.
         index := index + 1].
     ^aStream contents!
 checkDay: dayNumber month: monthName year: yearInteger
         "Private - Check the validity of the dayNumber argument
          for the month Symbol monthName in the year yearInteger.
          If the date is invalid, invoke the method 'errorInDay'
          in this class to handle the error."
     (dayNumber < 1 or: [ dayNumber >
         (self daysInMonth: monthName forYear: yearInteger)])
         ifTrue: [^self errorInDay]!
 checkDay: dayNumber year: yearInteger
         "Private - Check the validity of the dayNumber argument
          for the year yearInteger.  If the date is invalid, invoke
          the method 'errorInDay' in this class to handle the error."
     (dayNumber < 1 or: [ dayNumber >
         ((self leapYear: yearInteger) + 365)])
         ifTrue: [^self errorInDay]!
 currentDateInto: anArray
         "Private - Answer the argument anArray set to the
          current date (3 elements: year, month, day)."
     <primitive: 119>
     ^self primitiveFailed!
 dateAndTimeNow
         "Answer an Array of two elements.  The first element
          is a Date representing the current
          date and the second element is a
          Time representing the current time."
     ^(Array new: 2)
         at: 1 put: self today;
         at: 2 put: Time now;
         yourself!
 dayOfWeek: dayName
         "Answer a number from 1 to 7 indicating the
          weekday number for the Symbol dayName (1 meaning Monday,
          to 7 meaning Sunday)."
     ^#(Monday Tuesday Wednesday Thursday Friday Saturday Sunday)
         indexOf: dayName ifAbsent: [self errorInDay]!
 daysInMonth: monthName forYear: yearInteger
         "Answer the total number of days for the
          month Symbol monthName in the year yearInteger."
     | monthIndex |
     (monthIndex := self indexOfMonth: monthName) = 2
         ifTrue: [ ^28 + (self leapYear: yearInteger)].
     ^#(31 28 31 30 31 30 31 31 30 31 30 31)
         at: monthIndex!
 daysInYear: yearInteger
         "Answer the total number of days
          for the year yearInteger."
     ^365 + (self leapYear: yearInteger)!
 errorInDay
         "Private - Report the error that a particular
          method argument, representing a day, is in error."
     ^self error: 'Error in day argument'!
 errorInMonth
         "Private - Report the error that a particular
          method argument, representing a month, is in error."
     ^self error: 'Error in month argument'!
 fromDays: anInteger
         "Answer the date that is anInteger number of
          days before or after January 1, 1901 depending
          on the sign of anInteger."
     ^self new day: anInteger!
 fromString: aString
         "Answer a Date specified by aString.
          aString contains first the day number then the
          month name and then the year separated with blanks."
     | stream day month year |
     stream := ReadStream on: aString.
     [stream peekFor:  $ ] whileTrue: [].
     day :=  stream upTo: $ .
     [stream peekFor: $ ] whileTrue: [].
     month := (stream upTo: $ ) asLowerCase.
     [stream peekFor: $ ] whileTrue: [].
     year := stream upTo: $ .
     month := MonthStrings at: month
         ifAbsent: [self errorInMonth].
     ^self
         newDay: day asInteger
         month: month
         year: year asInteger!
 indexOfMonth: monthName
         "Answer a number from 1 to 12 indicating
          the month for the monthName Symbol."
     ^MonthNames at: monthName
         ifAbsent: [self errorInMonth]!
 initialize
         "Initialize the class dictionary variables
          MonthNames and MonthStrings that contain the
          associations between the month names as symbols,
          month names as strings, and the month indices."
         "This is one time code so it is commented --
     MonthNames := Dictionary new.
     MonthNames
         at: #Jan put: 1;
         at: #January put: 1;
         at: #Feb put: 2;
         at: #February put: 2;
         at: #Mar put: 3;
         at: #March put: 3;
         at: #Apr put: 4;
         at: #April put: 4;
         at: #May put: 5;
         at: #Jun put: 6;
         at: #June put: 6;
         at: #Jul put: 7;
         at: #July put: 7;
         at: #Aug put: 8;
         at: #August put: 8;
         at: #Sep put: 9;
         at: #September put: 9;
         at: #Oct put: 10;
         at: #October put: 10;
         at: #Nov put: 11;
         at: #November put: 11;
         at: #Dec put: 12;
         at: #December put: 12.
     MonthStrings := Dictionary new.
     MonthStrings
         at: 'jan' put: #Jan;
         at: 'january' put: #Jan;
         at: 'feb' put: #Feb;
         at: 'february' put: #Feb;
         at: 'mar' put: #Mar;
         at: 'march' put: #Mar;
         at: 'apr' put: #Apr;
         at: 'april' put: #Apr;
         at: 'may' put: #May;
         at: 'jun' put: #Jun;
         at: 'june' put: #Jun;
         at: 'jul' put: #Jul;
         at: 'july' put: #Jul;
         at: 'aug' put: #Aug;
         at: 'august' put: #Aug;
         at: 'sep' put: #Sep;
         at: 'september' put: #Sep;
         at: 'oct' put: #Oct;
         at: 'october' put: #Oct;
         at: 'nov' put: #Nov;
         at: 'november' put: #Nov;
         at: 'dec' put: #Dec;
         at: 'december' put: #Dec --"!
 leapYear: yearInteger
         "Answer true if the year yearInteger is
          a leap year, else answer false."
     (yearInteger \\ 4 = 0
         and: [yearInteger \\ 100 > 0
             or: [yearInteger \\ 400 = 0]])
                 ifTrue:  [^1]
                 ifFalse: [^0]!
 leapYearsTo: yearInteger
         "Answer the number of leap years from 1901
          to the year before yearInteger."
     | priorYear |
     priorYear := yearInteger - 1.
     ^(priorYear // 4) + (priorYear // 400) -
         (priorYear // 100) - 460!
 monthNameFromString: aString
         "Answer the Symbol for a month name corresponding
          to the month name specified in aString."
     ^MonthStrings at: aString trimBlanks asLowerCase
         ifAbsent: [self errorInMonth]!
 nameOfDay: dayIndex
         "Answer the Symbol for a weekday name corresponding
          to the weekday number dayIndex (Monday for dayIndex
          1, to Sunday for dayIndex 7)."
     (dayIndex > 7 or: [dayIndex < 1])
         ifTrue: [self errorInDay].
     ^#(Monday Tuesday Wednesday
         Thursday Friday Saturday Sunday) at: dayIndex!
 nameOfMonth: monthIndex
         "Answer the symbol for a month name corresponding
          to the month index monthIndex (January for monthIndex
          1, to December for monthIndex 12)."
     (monthIndex > 12 or: [monthIndex < 1])
         ifTrue: [self errorInMonth].
     ^#(January February March April May
        June July August September October
        November December ) at: monthIndex!
 newDay: dayNumber month: monthName year: yearInteger
         "Answer a Date of the day dayNumber in the
          month Symbol monthName for the year yearInteger."
     | daysToMonth monthIndex |
     self checkDay: dayNumber month: monthName year: yearInteger.
     monthIndex := self indexOfMonth: monthName.
     daysToMonth := #(0 31 59 90 120 151 181 212 243 273 304 334)
         at: monthIndex.
     (monthIndex > 2 and:
         [(self leapYear: yearInteger) = 1])
             ifTrue: [daysToMonth := daysToMonth + 1].
     daysToMonth := daysToMonth + dayNumber.
     ^self newDay: daysToMonth year: yearInteger!
 newDay: dayCount year: yearInteger
         "Answer the Date of the day dayCount
          in the year yearInteger."
     self checkDay: dayCount year: yearInteger.
     ^self new day: yearInteger - 1901 *
         365 + (self leapYearsTo: yearInteger) + dayCount - 1!
 today
         "Answer the current date."
     | anArray |
     anArray := self currentDateInto: (Array new: 3).
     ^self
         newDay: (anArray at: 3)
         month: (self nameOfMonth: (anArray at: 2))
         year: (anArray at: 1)! !

! Date methods !
 < aDate
         "Answer true if the receiver
          date is before aDate."
     ^self day < aDate day!
 <= aDate
         "Answer true if the receiver date
          is before or the same as aDate."
     ^self day <= aDate day!
 = aDate
         "Answer true if the receiver date
          is the same as aDate."
     ^self day = aDate day!
 > aDate
         "Answer true if the receiver
          date is after aDate."
     ^self day > aDate day!
 >= aDate
         "Answer true if the receiver date
          is the same or after aDate."
     ^aDate day <= self day!
 addDays: dayCount
         "Answer a Date that is dayCount number of days
          after the receiver Date."
     ^self class fromDays: self day + dayCount!
 asSeconds
         "Answer the number of seconds that have elapsed
          from January 1, 1901 to the receiver Date."
     ^self elapsedSecondsSince:
         (self class newDay: 1 year: 1901)!
 day
         "Answer the number of days from the
          receiver date to January 1, 1901."
     ^day + self class baseDay!
 day: dayCount
         "Private - Answer the receiver.  Set the day
          instance variable of the receiver to dayCount
          number of days."
     day := dayCount - self class baseDay!
 dayIndex
         "Answer a number from 1 to 7 indicating
          the weekday number  of the receiver Date
          (1 meaning Monday, to 7 meaning Sunday)."
     ^self day + 1 \\ 7 + 1!
 dayName
         "Answer the name of the weekday of
          the receiver Date."
     ^self class nameOfDay: self dayIndex!
 dayOfMonth
         "Answer a number from 1 to 31 indicating the day
          number within the  month of the receiver Date."
     ^self dayOfYear - self firstDayInMonth + 1!
 dayOfYear
         "Answer a number from 1 to 366 indicating the
          day within the year of the receiver Date."
     | yearNumber |
     yearNumber := self year.
     ^self day - (yearNumber - 1901 * 365 +
         (self class leapYearsTo: yearNumber)) + 1!
 daysInMonth
         "Answer the total number of days in
          the receiver month."
     ^self class
         daysInMonth: self monthName
         forYear: self year!
 daysInYear
         "Answer the total number of days in
          the receiver year."
     ^self class daysInYear: self year!
 daysLeftInMonth
         "Answer number of days remaining in
          the receiver month."
     | daysToMonth dayNumber index|
     daysToMonth :=
         #(31 59 90 120 151 181 212 243 273 304 334 365).
     dayNumber := self dayOfYear.
     dayNumber > 59
         ifTrue: [
             dayNumber := dayNumber -
                 (self class leapYear: self year)].
     index := 1.
     [dayNumber > (daysToMonth at: index)]
         whileTrue: [index := index + 1].
     ^(daysToMonth at: index) - dayNumber!
 daysLeftInYear
         "Answer number of days remaining in
          the receiver year."
     ^self daysInYear - self dayOfYear!
 elapsedDaysSince: aDate
         "Answer the number of elapsed days
          between the receiver Date and aDate."
     ^self day - aDate day!
 elapsedMonthsSince: aDate
         "Answer the number of elapsed months
          between the receiver Date and aDate."
     ^self year - aDate year * 12 +
         (self monthIndex - aDate monthIndex)!
 elapsedSecondsSince: aDate
         "Answer the number of elapsed seconds
          between the receiver Date and aDate."
     ^(self subtractDate: aDate) * 86400
         "86400 is the number of seconds in a day"!
 firstDayInMonth
         "Answer the number of the first day in the
          receiver month relative to the beginning
          of the receiver year."
     | indexOfMonth daysToMonth |
     indexOfMonth := self monthIndex.
     daysToMonth :=
         #(1 32 60 91 121 152 182 213 244 274 305 335)
             at: indexOfMonth.
     indexOfMonth > 2
         ifTrue: [
             ^daysToMonth := daysToMonth +
                 (self class leapYear: self year)].
     ^daysToMonth!
 firstDayOfMonth
         "Answer the Date of the first day in
          the receiver month."
     ^self class
         newDay: 1
         month: self monthName
         year: self year!
 formPrint
         "Answer a string representing the
          receiver Date in the form: mm/dd/yy."
     | monthNumber dayNumber yearNumber stream |
     stream := WriteStream with: (String new: 8).
     dayNumber := self dayOfMonth.
     monthNumber := self monthIndex.
     yearNumber := self year \\ 100.
     monthNumber < 10
         ifTrue: [stream nextPut: $0].
     stream nextPutAll: (monthNumber printString), '/'.
     dayNumber < 10
         ifTrue: [stream nextPut: $0].
     stream nextPutAll: (dayNumber printString), '/',
         yearNumber printString.
     ^stream contents!
 hash
         "Answer the integer hash value for the receiver."
     ^day abs!
 monthIndex
         "Answer a number from 1 to 12 indicating
          the month of the receiver Date."
     | daysToMonth dayNumber index|
     daysToMonth :=
         #(31 59 90 120 151 181 212 243 273 304 334 365).
     dayNumber := self dayOfYear.
     dayNumber > 59
         ifTrue: [
             dayNumber := dayNumber -
                 (self class leapYear: self year)].
     index := 1.
     [dayNumber > (daysToMonth at: index)]
         whileTrue: [index := index + 1].
     ^index!
 monthName
         "Answer a Symbol containing the month
          name of the receiver Date."
     ^self class nameOfMonth: self monthIndex!
 previousWeekday: dayName
         "Answer a Date reflecting the most recent
          dayName (a Symbol) preceding the receiver Date."
     | dayIndex dayIndexPrev daysToSub |
     dayIndex := self dayIndex.
     dayIndexPrev := self class dayOfWeek: dayName.
     daysToSub := dayIndex - dayIndexPrev.
     dayIndex <= dayIndexPrev
         ifTrue: [daysToSub := daysToSub + 7].
     ^self class fromDays: (self day - daysToSub)!
 printOn: aStream
         "Append the ASCII representation of the receiver
          to aStream  in the form: mmm dd, yyyy. (The form
          yyyy is satisfied only for positive year numbers
          of 4 digits)."
     | dayNumber nameOfMonth |
     dayNumber := self dayOfMonth.
     nameOfMonth := #('Jan' 'Feb' 'Mar' 'Apr' 'May'
         'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec').
     aStream
         nextPutAll: (nameOfMonth at: self monthIndex);
         space.
     dayNumber <= 9 ifTrue: [ aStream nextPut:$ ].
     dayNumber printOn: aStream.
     aStream nextPutAll: ', '.
     self year printOn: aStream!
 subtractDate: aDate
         "Answer the number of days between
          the receiver Date and aDate."
     ^self day - aDate day!
 subtractDays: dayCount
         "Answer the date that is dayCount number
          of days before the receiver Date."
     ^self class fromDays: self day - dayCount!
 year
         "Answer the year number of receiver Date."
     | numOfDays years n400 r400 n100 r100 n4 r4 n1 |
     numOfDays := self day + 693960.
         "693960 is the number of days from year 0
          to year 1900 leap year days included"
     n400 := numOfDays // 146097 * 400.
         "146097 = 400 * 365 + 97"
     r400 := numOfDays \\ 146097 min: 146095.
     n100 := r400 // 36524 * 100.
         "36524 = 100 * 365 + 24"
     r100 := r400 \\ 36524.
     n4 := r100 // 1461 * 4.
         "1461 = 4 * 365 + 1"
     r4 := r100 \\ 1461 min: 1459.
     n1 := r4 // 365.
     ^n400 + n100 + n4 + n1 + 1! !

! Number class methods ! !

! Number methods !
 * aNumber
         "Answer the result of multiplying
          the receiver by aNumber."
     self implementedBySubclass!
 + aNumber
         "Answer the sum of the receiver and aNumber."
     self implementedBySubclass!
 - aNumber
         "Answer the difference between
          the receiver and aNumber."
     self implementedBySubclass!
 / aNumber
         "Answer the result of dividing
          the receiver by aNumber."
     self implementedBySubclass!
 // aNumber
         "Answer the integer result of dividing the
          receiver by aNumber with truncation
          towards negative infinity."
     self implementedBySubclass!
 @ aNumber
         "Answer a point with receiver as the x-coordinate
          and aNumber as the y-coordinate."
     ^Point new
         x: self;
         y: aNumber!
 \\ aNumber
         "Answer the integer remainder after dividing
          the receiver by aNumber with truncation
          towards negative infinity."
     self implementedBySubclass!
 abs
         "Answer the absolute value of the receiver."
     self < 0
         ifTrue: [^self negated].
     ^self!
 arcCos
         "Answer the arc-cosine, an angle in
          radians, of the receiver."
     ^(Float pi / 2) - self arcSin!
 arcSin
         "Answer the arc-sine, an angle in
          radians, of the receiver."
     (self > 1 or: [self < -1])
         ifTrue: [^self error: 'receiver of arcSin out of range'].
     self = 1
         ifTrue: [^Float pi / 2].
     self = -1
         ifTrue: [^(Float pi / 2) negated].
     ^(self / (1 - (self * self)) sqrt) arcTan!
 arcTan
         "Answer the arc-tangent, an angle in
          radians, of the receiver."
     ^self asFloat arcTan!
 ceiling
         "Answer the integer nearest the receiver
          towards positive infinity."
     | integerValue |
     integerValue := self // 1.
         "truncates >> negative infinity"
     integerValue = self ifTrue: [^self].
     ^integerValue + 1!
 cos
         "Answer a Float which is the cosine of the receiver.
          The receiver is an angle measured in radians."
     ^self asFloat cos!
 degreesToRadians
         "Answer the receiver converted
          from degrees to radians."
     ^self asFloat degreesToRadians!
 denominator
         "Answer the denominator of the receiver.  Default
          is one which can be overridden by the subclasses."
     ^1!
 even
         "Answer true if the integer part of
          the receiver is even, else answer false."
     ^self \\ 2 = 0!
 exp
         "Answer a Float which is the
          exponential of the receiver."
     ^self asFloat exp!
 floor
         "Answer the integer nearest the receiver
          truncating towards negative infinity."
     ^self // 1!
 ln
         "Answer a Float which is the
          natural log of the receiver."
     ^self asFloat ln!
 log: aNumber
         "Answer a Float which is the log
          base aNumber of the receiver."
     ^self asFloat ln / aNumber asFloat ln!
 negated
         "Answer the negation of the receiver."
     self implementedBySubclass!
 negative
         "Answer true if the receiver is less
          than zero, else answer false."
     ^self < 0!
 numerator
         "Answer the numerator of the receiver.  Default
          is the receiver which can be overridden by the
          subclasses."
     ^self!
 odd
         "Answer true if the integer part of
          the receiver is odd, else answer false."
     ^self \\ 2 = 1!
 positive
         "Answer true if the receiver is greater
          than or equal to zero, else answer false."
     ^self >= 0!
 printFraction: numberFractionDigits
         "Answer a string, the ASCII representation
          of the receiver truncated to numberFractionDigits
          decimal places."
    | stream fraction integer |
     numberFractionDigits < 0
         ifTrue: [self error: 'Negative digit count'].
     stream := WriteStream on: (String new: 16).
     (integer := self // 1) printOn: stream.
     stream nextPut: $..
     fraction := self - integer.
     integer := 0.
     numberFractionDigits timesRepeat: [
         fraction := (fraction - integer) * 10.
         (integer := fraction // 1) printOn: stream].
     ^stream contents!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     ^self implementedBySubclass!
 printRounded: numberFractionDigits
         "Answer a string, the ASCII representation
          of the receiver rounded to numberFractionDigits
          decimal places."
     | rounder |
     rounder := 1/(#(1 10 100 1000 10000
         100000 10000000 100000000)
         at: numberFractionDigits + 1).
     ^(self roundTo: rounder)
         printFraction: numberFractionDigits!
 quo: aNumber
         "Answer the integer quotient
          with truncation toward zero."
      ^(self / aNumber) truncated!
 radiansToDegrees
         "Answer the receiver converted
          from radians to degrees."
     ^self asFloat radiansToDegrees!
 raisedTo: aNumber
         "Answer a Float which is the receiver
          raised to the power of aNumber."
     ^(aNumber * self ln) exp!
 raisedToInteger: anInteger
         "Answer the receiver raised
          to the power of anInteger."
     | result |
     (anInteger isKindOf: Integer)
         ifTrue: [
             result := 1.
             anInteger abs timesRepeat: [
                 result := self * result].
             anInteger < 0
                 ifTrue:  [^1 / result]
                 ifFalse: [^result]].
     self error: 'raisedToInteger needs integer power'!
 reciprocal
         "Answer one divided by the receiver."
     self implementedBySubclass!
 rem: aNumber
         "Answer the integer remainder after dividing
          the receiver by aNumber with truncation
          towards zero."
     ^self - ((self quo: aNumber) * aNumber)!
 rounded
         "Answer the nearest integer to the receiver."
     ^self + self + self sign quo: 2!
 roundTo: aNumber
         "Answer the receiver rounded to the
          nearest multiple of aNumber."
     ^self + (aNumber/2) truncateTo: aNumber!
 sign
         "Answer 1 if the receiver is greater than zero,
          answer -1 if the receiver is less than zero,
          else answer zero."
     self strictlyPositive
         ifTrue: [^1].
     self negative
         ifTrue: [^-1].
     ^0!
 sin
         "Answer a Float which is the sine of the receiver.
          The receiver is an angle measured in radians."
     ^self asFloat sin!
 sqrt
         "Answer a Float which is the square
          root of the receiver."
     ^self asFloat sqrt!
 squared
         "Answer the receiver multiplied by the receiver."
     ^self * self!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reinstantiated."
     self printOn: aStream!
 strictlyPositive
         "Answer true if the receiver is
          greater than zero, else answer false."
     ^self > 0!
 tan
         "Answer a Float which is the tangent of the
          receiver.  The receiver is an angle
          measured in radians."
     ^self asFloat tan!
 timesTwoPower: anInteger
         "Answer the result of multiplying the
          receiver by 2 to the exponent anInteger."
     ^self asFloat timesTwoPower: anInteger!
 to: stop
         "Answer an Interval for the numbers between
          the receiver and the argument stop where each
          number is the previous number plus 1."
     ^Interval from: self to: stop!
 to: stop by: step
         "Answer an Interval for the numbers between
          the receiver and the argument stop where each
          number is the previous number plus the argument step."
     ^Interval from: self to: stop by: step!
 to: stop by: step do: aBlock
         "Evaluate the one argument block aBlock for the
          numbers between the receiver and the argument
          stop where each number is the previous number
          plus the argument step."
     | nextValue |
     nextValue := self.
     step > 0
         ifTrue: [
             [nextValue <= stop] whileTrue: [
                 aBlock value: nextValue.
                 nextValue := nextValue + step]]
         ifFalse: [
             [stop <= nextValue] whileTrue: [
                 aBlock value: nextValue.
                 nextValue := nextValue + step]]!
 to: stop do: aBlock
         "Evaluate the one argument block aBlock for the
          numbers between the receiver and the argument
          stop where each number is the previous number plus 1."
     | next |
     next := self.
     [next <= stop]
         whileTrue: [
             aBlock value: next.
             next := next + 1]!
 truncateTo: aNumber
         "Answer the receiver truncated (towards
          zero) to the nearest multiple of aNumber."
     ^self // aNumber * aNumber! !

! Float class methods !
 floatError
         "Query the floating point coprocessor
          as to type of exception and report it."
     | status |
     status := self status.
     (status bitAnd: 8) ~= 0
         ifTrue: [^self error: 'Float overflow exception'].
     (status bitAnd: 16r10) ~= 0
         ifTrue: [^self error: 'Float underflow exception'].
     (status bitAnd: 4) ~= 0
         ifTrue: [^self error: 'Float divide by zero exception'].
     (status bitAnd: 2) ~= 0
         ifTrue: [^self error: 'Float denormalized operand'].
     (status bitAnd: 1) ~= 0
         ifTrue: [^self error: 'Float invalid operation'].
     (status bitAnd: 16r80) ~= 0
         ifTrue: [^self error: 'Math coprocessor missing'].
     ^self error: 'Float undefined exception'!
 fromInteger: anInteger
         "Answer a floating point representation
          of the argument anInteger."
     <primitive: 40>
     ^self floatError!
 new: argumentIgnored
         "Answer an instance of the class Float.
          This method reports an error."
     ^self invalidMessage!
 pi
         "Answer the floating point representation of pi."
     ^1 arcTan * 4!
 status
         "Answer the status of the floating point
          coprocessor as a small integer (refer to
          coprocessor status word definition)."
     <primitive: 86>! !

! Float methods !
 * aNumber
         "Answer the result of multiplying
          the receiver by aNumber."
     <primitive: 49>
     aNumber class == Float
         ifTrue: [^self class floatError]
         ifFalse: [^self * aNumber asFloat]!
 + aNumber
         "Answer sum of the receiver and aNumber."
     <primitive: 41>
     aNumber class == Float
         ifTrue: [^self class floatError]
         ifFalse: [^self + aNumber asFloat]!
 - aNumber
         "Answer the difference between
          the receiver and aNumber."
     <primitive: 42>
     aNumber class == Float
         ifTrue: [^self class floatError]
         ifFalse: [^self - aNumber asFloat]!
 / aNumber
         "Answer the result of dividing
          the receiver by aNumber."
     <primitive: 50>
     aNumber class == Float
         ifTrue: [^self class floatError]
         ifFalse: [^self / aNumber asFloat]!
 // aNumber
         "Answer the integer quotient after dividing the
          receiver by aNumber with truncation
          towards negative infinity."
     | answer quotient |
     quotient := self / aNumber.
     (answer := quotient truncated) < 0
         ifTrue: [
             answer = quotient
                 ifFalse: [^answer - 1]].
     ^answer!
 < aNumber
         "Answer true if the receiver is less
          than aNumber, else answer false."
     <primitive: 43>
     aNumber class == Float
         ifTrue: [^self class floatError]
         ifFalse: [^self < aNumber asFloat]!
 <= aNumber
         "Answer true if the receiver is less than
          or equal to aNumber, else answer false."
     ^(aNumber asFloat < self) not!
 = aNumber
         "Answer true if the receiver is equal
          to aNumber, else answer false."
     <primitive: 47>
     aNumber class == Float
         ifTrue: [^self class floatError]
         ifFalse: [^self = aNumber asFloat]!
 > aNumber
         "Answer true if the receiver is greater
          than aNumber, else answer false."
     ^aNumber asFloat < self!
 >= aNumber
         "Answer true if the receiver is greater than
          or equal to aNumber, else answer false."
     ^(self < aNumber) not!
 \\ aNumber
         "Answer the integer remainder after dividing
          the receiver by aNumber with truncation
          towards negative infinity."
     ^(self - (self // aNumber * aNumber))
         truncated!
 arcTan
         "Answer the arc-tangent, an angle in
          radians, of the receiver."
     <primitive: 85>
     ^self class floatError!
 asFloat
         "Answer the receiver as a floating
          point number."
     ^self!
 cos
         "Answer the cosine of the receiver.  The
          receiver is an angle measured in radians"
     <primitive: 30>
     ^self class floatError!
 degreesToRadians
         "Answer the number of radians the
          receiver represents in degrees."
     ^self * Float pi / 180!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner."
     | size index |
     size := self basicSize.
     aStream nextTwoBytesPut: (aCloner cloneOopFor: self class).
     aStream nextTwoBytesPut: size + 2.
     index := 1.
     [ index <= size ]
         whileTrue: [
             aStream nextBytePut: (self at: index).
             index := index + 1]!
 exp
         "Answer the exponential of the receiver."
     <primitive: 45>
     ^self class floatError!
 exponent
         "Answer the floating point number whose value
          is the exponent part of the floating
          point representation of the receiver."
     <primitive: 53>
     ^self class floatError!
 hash
         "Answer the integer hash value for the receiver."
     | value index |
     value := 0.
     index := 8.
     [index <= 4]
         whileFalse: [
             value := value + ((self at: index) hash).
             index := index - 1].
     ^value!
 ln
         "Answer the natural log of the receiver."
     <primitive: 46>
     ^self class floatError!
 negated
         "Answer the receiver subtracted from zero."
     ^0 asFloat - self!
 printOn: aStream
         "Answer the receiver.  Append the ASCII
          representation (maximum of 8 digits) of
          the receiver to aStream."
     | digitCount integer number rounder scale n |
     (number := self) < 0
         ifTrue: [
             aStream nextPut: $-.
             number := self negated].
     rounder := 1/20000000.
     number = 0
         ifTrue: [^aStream nextPutAll: '0.0'].
     scale := 0.
     [number >= 10]
         whileTrue: [
             number := number / 10.
             scale := scale + 1].
     [number < 1]
         whileTrue: [
             number := number * 10.
             scale := scale - 1].
     number := number + rounder.
     number >= 10
         ifTrue: [
             number := number /10.
             scale := scale + 1].
     (scale > 7 or: [
     scale < -7 or: [
     scale < 0 and: [
     n := number * (10 raisedToInteger: 7 + scale).
     ((n - n truncated) * (10 raisedToInteger:
         scale negated)) truncated ~= 0]]])
         ifFalse: [
             number := number * (10 raisedToInteger: scale).
             rounder := rounder * (10 raisedToInteger: scale).
             scale := 0].
     digitCount := aStream position.
     integer := number truncated.
     number := number - integer.
     integer printOn: aStream.
     aStream nextPut: $..
     rounder := rounder + rounder.
     digitCount := 9 - (aStream position - digitCount).
     [number := number * 10.
     integer := number truncated.
     number := number - integer.
     aStream nextPut: (Character digitValue: integer).
     (digitCount := digitCount - 1) > 0 and:
     [(rounder := rounder * 10) <= number]]
         whileTrue: [].
     scale = 0
         ifFalse: [
             aStream nextPut: $e.
             scale printOn: aStream]!
 radiansToDegrees
         "Answer the number of degrees the
          receiver represents in radians."
     ^self * 180 / Float pi!
 reciprocal
         "Answer one divided by the receiver."
     ^1 asFloat / self!
 significand
         "Answer the floating point number whose value
          is the significand part of the floating
          point representation of the receiver."
     <primitive: 52>
     ^self class floatError!
 sin
         "Answer the sine of the receiver.  The
          receiver is an angle measured in radians"
     <primitive: 48>
     ^self class floatError!
 sqrt
         "Answer the square root of the receiver."
     <primitive: 44>
     ^self class floatError!
 tan
         "Answer the tangent of the receiver.  The
          receiver is an angle measured in radians"
     <primitive: 83>
     ^self class floatError!
 timesTwoPower: anInteger
         "Answer 2 to the exponent anInteger
          multiplied by the receiver."
     <primitive: 54>
     ^self class floatError!
 truncate
         "Private - Answer the receiver as a kind of
          Integer truncating the fraction part."
     | answer float scale partialInt |
     scale := self exponent truncated.
     float := self timesTwoPower: scale \\ 13 - scale.
     answer := float truncated.
     float := float - answer asFloat.
     scale // 13 timesRepeat: [
         float := float timesTwoPower: 13.
         partialInt := float truncated.
         answer := answer * 8192 + partialInt.
         float := (float - partialInt asFloat)].
     ^answer!
 truncated
         "Answer the receiver as a kind of
          Integer truncating the fraction part."
     <primitive: 51>
     ^self truncate! !

! Fraction class methods !
 numerator: n denominator: d
         "Answer an instance of class Fraction and
          initialize both numerator and denominatior
          instance variables to n and d respectively."
     ^self new numerator: n denominator: d! !

! Fraction methods !
 * aNumber
         "Answer the result of multiplying
          the receiver by aNumber."
     ^(numerator * aNumber numerator) /
         (denominator * aNumber denominator)!
 + aNumber
         "Answer sum of the receiver and aNumber."
     ^((numerator * aNumber denominator) +
         (denominator * aNumber numerator)) /
             (denominator * aNumber denominator)!
 - aNumber
         "Answer the difference between
          the receiver and aNumber."
     ^((numerator * aNumber denominator) -
         (denominator * aNumber numerator)) /
             (denominator * aNumber denominator)!
 / aNumber
         "Answer the result of dividing
          the receiver by aNumber."
     ^(numerator * aNumber denominator) /
         (denominator * aNumber numerator)!
 // aNumber
         "Answer the integer quotient after dividing the
          receiver by aNumber with truncation
          towards negative infinity."
     ^(numerator * aNumber denominator) //
         (denominator * aNumber numerator)!
 < aNumber
         "Answer true if the receiver is less
          than aNumber, else answer false."
     ^(numerator * aNumber denominator) <
         (denominator * aNumber numerator)!
 <= aNumber
         "Answer true if the receiver is less than
          or equal to aNumber, else answer false."
     ^(numerator * aNumber denominator) <=
         (denominator * aNumber numerator)!
 = aNumber
         "Answer true if the receiver is equal
          to aNumber, else answer false."
     ^(aNumber isKindOf: Number) and:
         [numerator = aNumber numerator and:
             [denominator = aNumber denominator]]!
 > aNumber
         "Answer true if the receiver is greater
          than aNumber, else answer false."
     ^(numerator * aNumber denominator) >
         (denominator * aNumber numerator)!
 >= aNumber
         "Answer true if the receiver is greater than
          or equal to aNumber, else answer false."
     ^(denominator * aNumber numerator) <=
         (numerator * aNumber denominator)!
 \\ aNumber
         "Answer the integer remainder after dividing
          the receiver by aNumber with truncation
          towards negative infinity."
     ^(numerator * aNumber denominator) \\
         (denominator * aNumber numerator)!
 asFloat
         "Answer the receiver as a floating
          point number."
     ^numerator asFloat / denominator asFloat!
 denominator
         "Answer the denominator of the receiver."
     ^denominator!
 hash
         "Answer the integer hash value for the receiver."
     ^numerator abs + denominator abs!
 negated
         "Answer an instance of class Fraction
          which is the negative of the receiver."
     ^Fraction new
         numerator: self numerator negated
         denominator: self denominator!
 numerator
         "Answer the numerator of the receiver."
     ^numerator!
 numerator: n denominator: d
         "Answer the receiver.  The numerator and
          denominator of the receiver are set to the
          n and d arguments respectively."
     numerator := n.
     denominator := d!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     numerator printOn: aStream.
     aStream nextPut: $/.
     denominator printOn: aStream!
 reciprocal
         "Answer the reciprocal of the receiver by
          dividing the denominator by the numerator."
     ^denominator / numerator!
 truncated
         "Answer the receiver as a kind of
          Integer truncating the fraction part."
     ^numerator quo: denominator! !

! Integer class methods ! !

! Integer methods !
 * aNumber
         "Answer the result of multiplying
          the receiver by aNumber."
     <primitive: 29>
     ^aNumber * self!
 + aNumber
         "Answer the sum of the receiver and aNumber."
     <primitive: 21>
     ^aNumber + self!
 - aNumber
         "Answer the difference between
          the receiver and aNumber."
     <primitive: 22>
     ^(aNumber - self) negated!
 / aNumber
         "Answer the result of dividing
          the receiver by aNumber."
     | numerator denominator gcd |
     aNumber class == Float
         ifTrue: [^self asFloat / aNumber].
     numerator := self * aNumber denominator.
     (denominator := aNumber numerator) < 0
         ifTrue: [
             denominator := 0 - denominator.
             numerator := 0 - numerator].
     (gcd := numerator gcd: denominator) = denominator
         ifTrue: [^numerator // gcd]
         ifFalse: [
             ^Fraction
                 numerator: numerator // gcd
                 denominator: denominator // gcd]!
 // aNumber
         "Answer the qotient of dividing the
          receiver by aNumber with truncation
          towards negative infinity."
     | answer quotient |
     <primitive: 32>
     aNumber = 0 ifTrue: [^self zeroDivisor].
     quotient := self / aNumber.
     (answer := quotient truncated) < 0
         ifTrue: [
             answer = quotient
                 ifFalse: [^answer - 1]].
     ^answer!
 < aNumber
         "Answer true if the receiver is less
          than aNumber, else answer false."
     <primitive: 23>
     ^aNumber > self!
 <= aNumber
         "Answer true if the receiver is less than
          or equal to aNumber, else answer false."
     <primitive: 25>
     ^aNumber >= self!
 = aNumber
         "Answer true if the receiver is equal
          to aNumber, else answer false."
     <primitive: 27>
     ^false!
 > aNumber
         "Answer true if the receiver is greater
          than aNumber, else answer false."
     <primitive: 24>
     ^aNumber < self!
 >= aNumber
         "Answer true if the receiver is greater than
          or equal to aNumber, else answer false."
     <primitive: 26>
     ^aNumber <= self!
 \\ aNumber
         "Answer the integer remainder after dividing
          the receiver by aNumber with truncation
          towards negative infinity."
     <primitive: 31>
     aNumber = 0 ifTrue: [^self zeroDivisor].
     ^(self - (self // aNumber * aNumber)) truncated!
 allMask: anInteger
         "Answer true if the receiver bit ORed with
          the argument anInteger is equal to the receiver,
          else answer false."
     ^(self bitOr: anInteger) = self!
 anyMask: anInteger
         "Answer true if the receiver bit ANDed with
          the argument anInteger is not equal to zero,
          else answer false."
     ^(self bitAnd: anInteger) ~= 0!
 asCharacter
         "Answer the character whose ASCII encoding
          matches the value of the receiver."
     ^Character value: self!
 asFloat
         "Answer the floating point representation
          of the receiver."
     ^Float fromInteger: self!
 basicHash
         "Answer the hash value of the receiver
          which is the magnitude of the receiver."
     ^self abs!
 bitAnd: anInteger
         "Answer an Integer representing the receiver
          bits ANDed with the argument anInteger."
     <primitive: 34>
     ^self bitArgumentError!
 bitAt: anInteger
         "Answer 0 if the bit at index position anInteger
          in the receiver is 0, else answer 1."
     1 > anInteger ifTrue: [
         self error: 'bitAt: index must be greater than zero'].
     ^1 bitAnd: (self bitShift: 1 - anInteger)!
 bitInvert
         "Answer an integer whose bit values are
          the inverse of the bit values of the receiver."
     ^self bitXor: -1!
 bitOr: anInteger
         "Answer an Integer representing the receiver
          bits ORed with the argument anInteger."
     <primitive: 35>
     ^self bitArgumentError!
 bitShift: anInteger
         "Answer an integer which is the receiver bits
          shifted left anInteger number of bit positions
          if anInteger is positive, or bits shifted
          right for anInteger negated number of bit positions
          if anInteger is negative."
     <primitive: 37>
     ^self bitArgumentError!
 bitXor: anInteger
         "Answer the receiver bit XORed
          with the argument anInteger."
     <primitive: 36>
     ^self bitArgumentError!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner."
     | index |
     aStream nextTwoBytesPut: (aCloner cloneOopFor: self class).
     index := self basicSize.
     aStream nextTwoBytesPut: index + 1 * 2.
     1 to: index do: [ :i |
         aStream nextTwoBytesPut: (self at: i)]!
 factorial
         "Answer the factorial of the receiver."
     self > 1
         ifTrue: [^(self - 1) factorial * self].
     self < 0
         ifTrue: [^self error: 'negative factorial'].
     ^1!
 fibonacci
         "Answer the nth fibonacci number,
          where n is the receiver."
     self < 3 ifTrue: [^1].
     ^(self - 1) fibonacci + (self - 2) fibonacci!
 gcd: anInteger
         "Answer the greatest common divisor
          between the receiver and anInteger."
     | u v r |
     u := self abs.
     v := anInteger abs.
     [v = 0]
         whileFalse: [
             r := u \\ v.
             u := v.
             v := r].
     ^u!
 hash
         "Answer the hash value of the receiver
          which is the absolute value of the receiver."
     ^self abs!
 highBit
         "Answer 1 if the receiver is less than
          zero, else answer zero."
     self < 0
         ifTrue:  [^1]
         ifFalse: [^0]!
 lcm: anInteger
         "Answer the least common multiple
          between the receiver and anInteger."
     | gcd |
     (gcd := self gcd: anInteger) = 0
         ifFalse: [^(self // gcd * anInteger) abs].
     ^1!
 negated
         "Answer the receiver subtracted from zero."
     ^0 - self!
 noMask: anInteger
         "Answer true if the receiver bit ANDed
          with the argument anInteger equals zero,
          else answer false."
     ^(self bitAnd: anInteger) = 0!
 printOn: aStream
         "Append the ASCII representation (radix 10)
          of the receiver to aStream."
     | d divisor digits quotient remainder |
     self < 0
         ifTrue: [
             aStream nextPut: $-.
             0 - self printOn: aStream.
             ^self].
     digits := 4.
     divisor := 10000.
     [(d := divisor * divisor) < self]
         whileTrue: [divisor := d. digits := digits + digits].
     quotient := self // divisor.
     quotient printOn: aStream.
     remainder := (self - (quotient * divisor)) printString.
     aStream
         next: digits - remainder size put: $0;
         nextPutAll: remainder!
 printOn: aStream base: b
         "Append the ASCII representation of
          the receiver with radix b to aStream."
     | string tempStream n |
     b == 10
         ifFalse: ["print radix"
             b printOn: aStream base: 10.
             aStream nextPut: $r].
     (n := self) < 0
         ifTrue: [
             aStream nextPut: $-.
             n := self negated].
     string := String new: 16.
     tempStream := WriteStream on: string.
     [b <= n]
         whileTrue: [
             tempStream nextPut: (Character digitValue: n \\ b).
             n := n // b].
     aStream nextPut: (Character digitValue: n).
     n := tempStream position.
     [n == 0]
         whileFalse: [
             aStream nextPut: (string at: n).
             n := n - 1]!
 printPaddedTo: aWidth
         "Answer the string containing the ASCII representation
          of the receiver.  If the string is less than aWidth
          number of characters, the string is padded on the
          left so that the entire string is of size aWidth."
     | stream padding digits|
     stream := WriteStream on: (String new: 10).
     self printOn: stream base: 10.
     digits := stream contents.
     padding := aWidth - digits size.
     padding > 0
         ifTrue: [
             padding := ((String new: padding)
                 atAllPut: $ ;
                 yourself)]
         ifFalse:[padding := ''].
     ^padding, digits!
 quo: aNumber
         "Answer the integer quotient of the receiver
          divided by aNumber with truncation toward zero."
     <primitive: 33>
     aNumber = 0 ifTrue: [^self zeroDivisor].
     ^(self / aNumber) truncated!
 radix: baseInteger
         "Answer a string which is the ASCII representation
          of the receiver with radix baseInteger."
     | aStream |
     aStream := WriteStream on: (String new: 16).
     self printOn: aStream base: baseInteger.
     ^aStream contents!
 reciprocal
         "Answer one divided by the receiver."
     ^1 / self!
 rem: aNumber
         "Answer the integer remainder after dividing
          the receiver by aNumber with truncation
          towards zero."
     <primitive: 20>
     aNumber = 0 ifTrue: [^self zeroDivisor].
     ^self - (self / aNumber * aNumber) truncated!
 sieve
         "Do 10 iterations of the Sieve of Eratosthenes."
     | i j count prime flags k |
     flags := Array new: self.
     k := 10.
     [(k := k - 1) < 0] whileFalse: [
         i := 0.
         [(i := i + 1) <= self]
             whileTrue: [flags at: i put: true].
         i := count := 0.
         [(i := i + 1) <= self] whileTrue: [
             (flags at: i) ifTrue: [
                 prime := i + i + 1.
                 j := i + prime.
                 [j <= self] whileTrue: [
                     flags at: j put: false.
                     j := j + prime].
                 count := count + 1]]].
     ^count!
 timesRepeat: aBlock
         "Evaluate the block aBlock n number
          of times, where n is the receiver."
     | count |
     count := self.
     [count > 0] whileTrue: [
         count := count - 1.
         aBlock value]!
 truncated
         "Answer the receiver."
     ^self!
 zeroDivisor
         "Give a walkback with message saying that
          division by zero was attempted."
     self error: 'divisor is zero'!
 ~= aNumber
         "Answer true if the receiver is not
          equal to aNumber, else answer false."
     <primitive: 28>
     ^true! !

! LargeNegativeInteger class methods ! !

! LargeNegativeInteger methods ! !

! LargePositiveInteger class methods ! !

! LargePositiveInteger methods ! !

! SmallInteger class methods ! !

! SmallInteger methods !
 asObject
         "Answer an object whose object pointer is
          two times the receiver plus one."
     <primitive: 76>
     ^self primitiveFailed!
 asPrinterErrorFlag
         "Set the receiver as the printer
          error flags mask."
     <primitive: 87>
     ^self primitiveFailed!
 deepCopy
         "Answer a copy of the receiver with shallow
          copies of each instance variable.  Because
          small integers are immutable (cannot
          instantiate a copy), answer the receiver."
     ^self!
 dumpOn: aStream for: aCloner
         "Dump the receiver as a series of bytes to
          aStream for aCloner."
     aStream nextTwoBytesPut: self!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     | value divisor |
     (value := self) < 0
         ifTrue: [
             aStream nextPut: $-.
             value := 0 - self].
     divisor := 10.
     [divisor > value]
         whileFalse: [divisor := divisor * 10].
     [(divisor := divisor // 10) > 1]
         whileTrue: [
             aStream nextPut:
                 (Character value: value // divisor + 48).
             value := value \\ divisor].
     aStream nextPut: (Character value: value + 48)!
 shallowCopy
         "Answer a copy of the receiver which shares
          the receiver instance variables.  Because
          small integers are immutable (cannot
          instantiate a copy), answer the receiver."
     ^self! !

! Time class methods !
 currentTimeInto: anArray
         "Private - anArray is set to the current time.  anArray
          is an instance of class Array of size 4.  The
          elements in order contain hours, minutes, seconds
          and milliseconds."
     <primitive: 120>
     ^self primitiveFailed!
 dateAndTimeNow
         "Answer an Array of two elements.  The first element
          is an instance of class Date representing the current
          date and the second element is an instance of class
          Time representing the current time."
     ^Date dateAndTimeNow!
 fromSeconds: secondCount
         "Answer a Time which represents secondCount
          number of seconds from midnight."
     ^self new seconds:
         (secondCount < 0
             ifTrue: [86400 - (secondCount abs \\ 86400)]
             ifFalse: [secondCount \\ 86400])!
 initialize
         "Set the class variable ValueArray
          to an empty four element array."
     ValueArray := Array new: 4!
 millisecondClockValue
         "Answer the number of milliseconds from the beginning
          of the current day (midnight) to the current time."
     self currentTimeInto: ValueArray.
     ^(ValueArray at: 1) * 60
         + (ValueArray at: 2) * 60
             + (ValueArray at: 3) * 1000
                 + ((ValueArray at: 4) * 10)!
 millisecondsToRun: aBlock
         "Answer the number of milliseconds it
          takes to evaluate the block aBlock."
     | startTime stopTime |
     startTime := self millisecondClockValue.
     aBlock value.
     ^self millisecondClockValue - startTime!
 mouseClockValue
         "Answer the current second and millisecond
          clock value as milliseconds (used for timing
          mouse events)."
     self currentTimeInto: ValueArray.
     ^(ValueArray at: 3) * 100 + (ValueArray at: 4)!
 now
         "Answer a Time representing the
          current time in seconds."
     ^self new seconds: self totalSeconds!
 totalSeconds
         "Answer the number of seconds from the beginning
          of the current day (midnight) to the current time."
     self currentTimeInto: ValueArray.
     ^(ValueArray at: 1) * 60
         + (ValueArray at: 2) * 60
             + (ValueArray at: 3)! !

! Time methods !
 < aTime
         "Answer true if the receiver's seconds
          are less than aTime's seconds, else
          answer false."
     ^self asSeconds < aTime asSeconds!
 <= aTime
         "Answer true if the receiver's seconds are
          less than or equal to aTime's seconds,
          else answer false."
     ^self asSeconds <= aTime asSeconds!
 = aTime
         "Answer true if the receiver's seconds
          are equal to aTime's seconds, else
          answer false."
     ^self asSeconds = aTime asSeconds!
 > aTime
         "Answer true if the receiver's seconds
          are greater than aTime's seconds, else
          answer false."
     ^self asSeconds > aTime asSeconds!
 >= aTime
         "Answer true if the receiver's seconds are
          greater than or equal to aTime's seconds,
          else answer false."
     ^aTime asSeconds <= self asSeconds!
 addTime: timeAmount
         "Answer a Time which is timeAmount
          seconds past the receiver time."
     ^self class fromSeconds:
         (self asSeconds + timeAmount asSeconds)!
 asSeconds
         "Answer the number of seconds represented
          by the receiver time."
     ^seconds!
 hash
         "Answer the integer hash value for the receiver."
     ^seconds abs!
 hours
         "Answer the number of hours
          represented by the receiver time."
     ^self asSeconds // 3600!
 minutes
         "Answer the number of minutes past
          the hour in the receiver time."
     ^self asSeconds \\ 3600 // 60!
 printOn: aStream
         "Append the ASCII representation of the
          receiver to aStream in the form: hh:mm:ss."
     | time |
     time := self hours.
     time < 10
         ifTrue: [aStream nextPut: $0].
     time printOn: aStream.
     aStream nextPut: $:.
     time := self minutes.
     time < 10
         ifTrue: [aStream nextPut: $0].
     time printOn: aStream.
     aStream nextPut: $:.
     time := self seconds.
     time < 10
         ifTrue: [aStream nextPut: $0].
     time printOn: aStream!
 seconds
         "Answer the number of seconds past
          the minute in the receiver time."
     ^self asSeconds \\ 60!
 seconds: anInteger
         "Answer the receiver.  Set the number
          of seconds in the receiver to anInteger."
     seconds := anInteger!
 subtractTime: timeAmount
         "Answer the time that is timeAmount
          seconds before the receiver time."
     ^self class fromSeconds:
         (self asSeconds - timeAmount asSeconds)! !

! Menu class methods !
 black
         "Set PickedColor to Black."
     PickedColor := Black!
 blue
         "Set PickedColor to Blue."
     PickedColor := Blue!
 brown
         "Set PickedColor to Brown."
     PickedColor := Brown!
 cyan
         "Set PickedColor to Cyan."
     PickedColor := Cyan!
 green
         "Set PickedColor to Green."
     PickedColor := Green!
 initialize
         "Construct the ColorMenu and fill in each menu
          item with a different color."
     | form |
     ColorMenu := self
         labels: '\                \ \ \ \ \ \ \ \' withCrs
         lines: #()
         selectors: #(blue brown black cyan red
             white magenta green).
     form := ColorMenu popUpForm.
     1 to: 8 do: [ :color |
         form
             fill: (1 @ color extent: form width - 2 @ 1)
             rule: Form over
             mask: ( #(1 6 0 3 4 7 5 2) at: color) * 16].
     form
         fill: (1 @ 0 extent: form width - 2 @ 1)
         rule: Form over
         mask: Blue * 16 + Brown + Form bold.
     form
         fill: (1 @ (form height - 1) extent: form width - 2 @ 1)
         rule: Form over
         mask: Green * 16 + Brown + Form bold.!
 labels: aString lines: lineArray selectors: selectorArray
         "Answer a menu with aString for items,
          selectorArray for actions, and lines drawn
          under the items contained in lineArray."
     | items stream |
     items := Array new: selectorArray size.
     stream := ReadStream on: aString.
     1 to: items size do:
         [ :i | items at: i put: (stream upTo: Lf)].
     ^self new
         labels: items;
         lines: lineArray;
         selectors: selectorArray;
         yourself!
 magenta
         "Set PickedColor to Magenta."
     PickedColor := Magenta!
 pickColor
         "Pop up the ColorMenu and let the user select
          a color.  Answer the selected color."
     PickedColor := nil.
     ColorMenu popUpAt: Cursor offset for: self.
     ^PickedColor!
 red
         "Set PickedColor to Red."
     PickedColor := Red!
 setUpMenusFor: screenMode
         "Create built-in menues in TextEditor,
          TopDispatcher, and ScreenDispathcher
          according to screenMode (#color or #monochrome)."
     TextEditor initialize.
     TopDispatcher initializeFor: screenMode.
     ScreenDispatcher initializeFor: screenMode!
 white
         "Set PickedColor to White."
     PickedColor := White! !

! Menu methods !
 containsPoint: aPoint
         "Private - Answer true if the Menu window contains aPoint."
     ^aPoint > offset and:
         [aPoint < (popUpForm extent + offset - 1)]!
 disappear
         "Private - Restore the hidden part of the display that
          is underneath the Menu."
     hiddenArea displayAt: offset!
 displayAt: aPoint
         "Private - Display the menu at aPoint and
          save the image underneath."
     | frame newLoc |
     currentLine := nil.
     frame :=
         (aPoint x -
             (MouseEvent ifTrue: [popUpForm width // 2]
                         ifFalse: [0])) @
             (aPoint y - (popUpForm height // 2))
                 extent: popUpForm extent.
     frame corner < Display extent
         ifFalse: [
             frame corner:
                 (Display extent - 1 min: frame corner)].
     frame origin >= (0 @ 0)
         ifFalse: [frame origin: (0 @ 0 max: frame origin)].
     offset := frame origin.
     newLoc :=
         (offset x + 1) @ (offset y + (popUpForm height // 2)).
     MouseEvent
         ifTrue: [newLoc x: newLoc x + (popUpForm width // 2) - 1].
     Cursor offset: newLoc.
     hiddenArea := Form fromDisplay: frame.
     popUpForm displayAt: offset!
 labels: items
         "Place the string items in the popUpForm
          which will be shown as the menu."
     | width height byteBlt displayString border |
     height := items size.
     width := 0.
     items do: [:label| width := width max: label size].
     popUpForm := Form new
         offset: 0 @ 0;
         width: width + 2 height: height + 2;
         yourself.
     popUpForm
         fill: (0 @ 0 extent: popUpForm extent)
         rule: Form over
         color: (InfiniteForm blank
             attribute: MenuBackground).
     border := InfiniteForm new
         attribute: MenuBorder;
         yourself.
     displayString := DisplayString for: ''.
     byteBlt := ByteBlt new
         destForm: popUpForm
         sourceForm: border
         halftone: nil
         combinationRule: Form over
         destOrigin: 0 @ 0
         sourceOrigin: 0 @ 0
         extent: width + 2 @ 1
         clipRect: (0 @ 0 extent: (width + 2) @ ( height + 2)).
     border character: 16rDF asCharacter.
     byteBlt copyBytes.
     border character: 16rDC asCharacter.
     byteBlt
         destOrigin: 0 @ (height + 1);
         copyBytes.
     border character: 16rDB asCharacter.
     byteBlt
         destRect: (0@0 extent: 1 @ (height+2));
         copyBytes;
         destX: width + 1;
         copyBytes.
     byteBlt
         sourceForm: displayString;
         destOrigin: 1 @ 1;
         width: width;
         height: height;
         clipRect: (1 @ 1 extent: width @ height).
     1 to: items size do: [ :i |
         displayString string: (items at: i).
         byteBlt
             destY: i;
             copyBytes]!
 lines: lineArray
         "Underline the items contained in lineArray.  Do
          nothing for the character map version of Methods."!
 moveCursor: key
         "Private - Move the cursor according to the input
          character key. Answer key."
     key == SetLoc          ifTrue: [^SetLoc].
     key == LeftFunction    ifTrue: [^Cursor left].
     key == RightFunction   ifTrue: [^Cursor right].
     key == UpFunction      ifTrue: [^Cursor up].
     key == DownFunction    ifTrue: [^Cursor down].
 
     key == JumpLeftFunction  ifTrue: [^Cursor jumpLeft].
     key == JumpRightFunction ifTrue: [^Cursor jumpRight].
     key == JumpDownFunction  ifTrue: [^Cursor jumpDown].
     key == JumpUpFunction    ifTrue: [^Cursor jumpUp].
     (MouseEvent and: [key == SelectFunction])
         ifTrue: [^SetLoc].
     Terminal write: Bell.
     ^SetLoc!
 popUpAt: aPoint
         "Pop up menu at aPoint, give it control, and
          answer the user response or nil if no response."
     | key |
     priorCursor := Cursor offset.
     self displayAt: aPoint.
     [true] whileTrue: [
         self showCurrentLine.
         key := Terminal read.
         (MouseEvent or: [FunctionKey])
             ifTrue: [
                 (MouseEvent
                     ifTrue: [key == EndSelectFunction]
                     ifFalse: [key == SelectFunction])
                     ifTrue: [
                         self disappear.
                         (self containsPoint: Cursor offset)
                             ifFalse:[
                                 MouseEvent
                                     ifFalse: [Cursor offset: priorCursor].
                                 ^nil]
                             ifTrue: [
                                 Cursor offset: priorCursor.
                                 ^selectors at: currentLine]].
                 key := self moveCursor: key.
                 (self containsPoint: Cursor offset)
                     ifFalse: [
                         key == SetLoc
                             ifFalse: [
                                 self disappear.
                                 Cursor offset: priorCursor.
                                 ^nil]]]
             ifFalse: [Terminal write: Bell]]!
 popUpAt: aPoint for: anObject
         "Pop up menu at aPoint, give it control,
          and send response to anObject."
     | response |
     response := self popUpAt: aPoint.
     response == nil
         ifFalse: [anObject perform: response]!
 popUpForm
         "Private - Answer the instance variable
          popUpForm containing the menu."
     ^popUpForm!
 reverseLine: anIndex
         "Private - Display the cursor line reversed."
     anIndex == nil
         ifFalse: [
             Display
                 fill: ((offset x + 1) @ (offset y + anIndex)
                 extent: (popUpForm width - 2) @ 1)
                 rule: Form reverse
                 mask: ReverseMask + Bold]!
 selectors: anArray
         "Set selectors to anArray of action selectors."
     selectors := anArray!
 showCurrentLine
         "Private - Highlight the line where the cursor is at."
     | cursorLine cursor |
     cursor := Cursor offset.
     (self containsPoint: cursor)
         ifFalse: [
             self reverseLine: currentLine.
             currentLine := nil.
             ^self].
     cursorLine := cursor y - offset y.
     cursorLine = currentLine
         ifFalse: [
             self reverseLine: currentLine.
             self reverseLine: cursorLine.
             currentLine := cursorLine]! !

! Message class methods ! !

! Message methods !
 arguments
         "Answer the arguments array for the message."
     ^arguments!
 selector
         "Answer the message selector."
     ^selector! !

! Pane class methods !
 initialize
         "Default is do nothing. Initialization
          should be done by subclasses if any."!
 new
         "Create an instance of the receiver and
          initialize it."
     ^super new initialize! !

! Pane methods !
 activatePane
         "Mark the dispatcher of the receiver
          pane as active."
     dispatcher activate!
 activateWindow
         "Invoke the window activation methods
          of the receiver subpanes."
     subpanes do: [ :subpane |
         subpane activateWindow]!
 addSubpane: aPane
         "Add aPane as a subpane to the receiver."
     subpanes add: aPane.
     aPane superpane: self!
 border
         "OR in the border values of the
          receiver subpane on the borders form."
     self topPane border: frame!
 close
         "Close the subpanes and release their
          dependencies from the model."
     subpanes do: [ :subpane |
         subpane close].
     self release!
 collapsed
         "Answer true if the window is collapsed,
          else answer false."
     superpane == nil
         ifTrue: [^false]
         ifFalse:[^superpane collapsed]!
 cyclePane
         "Move the cursor to the pane next to the receiver.
          If none, home the cursor in the receiver pane."
     superpane isNil
         ifTrue: [dispatcher homeCursor]
         ifFalse:[
             self deactivatePane.
             superpane cyclePane: self]!
 cyclePane: subPane
         "Move the cursor to the pane next to subPane.
          If none, move to the one next to the receiver pane."
     (subpanes after: subPane
              ifNone: [^self cyclePane])
         dispatcher homeCursor!
 deactivatePane
         "Mark the receiver pane dispatcher as inactive."
     dispatcher notNil
         ifTrue: [dispatcher deactivate]!
 deactivateWindow
         "Mark the dispatchers of the receiver
          and its subpanes as inactive and change
          their visual clues to reflect an
          inactive window."
     subpanes do: [ :subpane |
         subpane deactivateWindow].
     dispatcher notNil
         ifTrue: [dispatcher deactivate]!
 defaultDispatcherClass
         "Answer the default dispatcher class of
          the receiver pane."
     ^self implementedBySubclass!
 dispatcher
         "Answer the dispatcher associated with the
          receiver pane and create one if there is none."
     dispatcher isNil
         ifTrue: [
             ^self dispatcher:
                 self defaultDispatcherClass new]
         ifFalse:[^dispatcher]!
 dispatcher: aDispatcher
         "Make aDispatcher the receiver pane's
          new dispatcher and initialize it."
     ^(dispatcher := aDispatcher) pane: self!
 displayWindow
         "Transfer the contents of the receiver
          subpanes to the borders form."
     subpanes do: [ :subpane |
         subpane displayWindow]!
 frame
         "Answer the frame rectangle of the receiver."
     ^frame!
 frame: aRectangle
         "Change the frame rectangle to aRectangle
          and combine the receiver pane's
          border values into the borders form."
     frame := aRectangle.
     self border!
 framingBlock: oneArgumentBlock
         "Initialize the framingBlock to the
          oneArgumentBlock which, when executed,
          yields the pane frame rectangle."
     framingBlock := oneArgumentBlock!
 hasCursor
         "Answer true if the pane contains the cursor,
          else answer false."
     ^self frame containsPoint: Cursor offset!
 homeCursor
         "Move the cursor to the top left
          corner of the pane."
     self dispatcher homeCursor!
 initialize
         "Set the default framing block to all of the
          outer frame and set the subpanes to be empty."
     subpanes := OrderedCollection new: 0.
     framingBlock := [ :box | box]!
 menu: aSymbol
         "Set the paneMenuSelector to the message
          selector contained in aSymbol which is used
          to generate the pane menu."
     paneMenuSelector := aSymbol!
 model: aModel
         "Set the model of the receiver to aModel and add
          the receiver as a dependent of the model."
     model release.
     model := aModel.
     model addDependent: self!
 modified
         "Answer true if the pane or any subpane
          has been modified and not saved."
     subpanes
         detect: [ :subpane | subpane modified]
         ifNone: [^dispatcher modified].
     ^true!
 open
         "Open all the subpanes of the receiver
          and answer the pane dispatcher."
     subpanes do: [ :subpane | subpane open].
     ^self dispatcher!
 popUp: aMenu
         "Display the pop-up menu aMenu at the
          cursor and perform the menu selection."
     self
         popUp: aMenu
         at: Cursor offset!
 popUp: aMenu at: aPoint
         "Display aMenu at aPoint.
          If the user choice is nil, do nothing.
          If the model can respond to the choice,
          let it perform the choice. Else,
          let the dispatcher perform it."
     | menuChoice |
     menuChoice := aMenu popUpAt: aPoint.
     menuChoice == nil
         ifFalse: [
             (model respondsTo: menuChoice)
                 ifTrue: [model perform: menuChoice]
                 ifFalse:[dispatcher perform: menuChoice]]!
 reframe: aRectangle
         "Change the frame rectangle of the receiver pane
          based on aRectagle and reframe the receiver subpanes."
     self frame: (framingBlock value: aRectangle).
     subpanes do: [ :subpane |
         subpane reframe: self frame]!
 release
         "Remove model dependency and
          disconnect the model from the pane."
     super release.
     model release.
     model := nil!
 searchForActivePane
         "Answer the lowest level subpane that
          contains the cursor."
     ^(subpanes
         detect: [ :subpane |
             subpane dispatcher isControlWanted]
         ifNone: [^self])
             searchForActivePane!
 superpane: aPane
         "Answer the receiver superpane."
     superpane := aPane!
 topPane
         "Answer the receiver top pane."
     superpane isNil
         ifTrue: [^self]
         ifFalse: [^superpane topPane]! !

! SubPane class methods ! !

! SubPane methods !
 change: aSymbol
         "Set the changeSelector to aSymbol."
     changeSelector := aSymbol!
 name: aSymbol
         "Set the name to aSymbol."
     name := aSymbol!
 performMenu
         "If the model has a menu creation method
          defined, give it control, else send
          this same message to the superclass."
     | menu |
     (model isNil or: [paneMenuSelector isNil])
         ifTrue: [^superpane performMenu].
     self popUp: (model perform: paneMenuSelector)!
 update: anObject
         "If anObject is equal to the receiver pane's
          name then update the contents of the pane."
     name == anObject
         ifTrue: [self update]
         ifFalse:[super update: anObject]!
 update: firstObject with: secondObject
         "If firstObject is equal to the receiver
          pane's name then perform the secondObject."
     name == firstObject
         ifTrue: [self perform: secondObject]
         ifFalse:[
             super
                 update: firstObject with: secondObject]! !

! ListPane class methods ! !

! ListPane methods !
 activatePane
         "Reverse the cursor line and activate
          the receiver pane dispatcher."
     self showCursorLine.
     super activatePane!
 activateWindow
         "Highlight the selected line in the
          receiver pane."
     self boldLine: selection.
     super activateWindow!
 boldLine: anInteger
         "Highlight the line indexed by
          anInteger in the receiver pane."
     | box |
     (box := self lineToRect: anInteger) isNil
         ifFalse: [paneScanner bold: box]!
 boldLineReverse: anInteger
         "Highlight and reverse the line indexed by
          anInteger in the receiver pane."
     | box |
     (box := self lineToRect: anInteger) isNil
         ifFalse: [paneScanner reverseBold: box]!
 close
         "Release the model and set the instance
          variables to nil."
     super close.
     list := selection := currentLine := nil!
 deactivatePane
         "Change visual clues to reflect an inactive pane
          and make the pane dispatcher inactive."
     self normalLine: currentLine;
          boldLine: selection.
     self showPane.
     currentLine := nil.
     super deactivatePane!
 deactivateWindow
         "Change visual clues to reflect an inactive window
          and make the pane dispatcher inactive."
     self normalLine: currentLine.
     paneScanner deactivate:
         (self lineToRect: selection).
     self showPane.
     currentLine := nil.
     super deactivateWindow!
 defaultDispatcherClass
         "Answer ListSelector which is the
          default dispatcher of a ListPane."
     ^ListSelector!
 displayWindow
         "Transfer the pane data to the borders form and
          highlight the selection using the paneScanner."
     self refreshAll.
     self boldLine: selection!
 frame: aRectangle
         "Initialize the paneScanner and compute
          the pane frame based on aRectangle."
     paneScanner := StringBlt new
         initialize: aRectangle
         on: self topPane bordersForm
         color: self topPane color attribute.
     super frame: aRectangle!
 initialize
         "Initialize the pane instance variables."
     super initialize.
     topCorner := 1@1.
     returnIndex := false!
 lineToRect: anInteger
         "Answer a Rectangle that surrounds the item in
          the list indexed by anInteger."
     | formLine |
     anInteger isNil ifTrue: [^nil].
     formLine := anInteger - topCorner y.
     (formLine between: 0 and: frame height - 1)
         ifFalse: [^nil].
     ^(0 @ formLine extent: frame width @ 1)!
 normalLine: anInteger
         "Turn off both reverse and highlight
          of the item indexed by anInteger."
     | formLine box |
     (box := self lineToRect: anInteger) isNil
         ifFalse: [paneScanner paint: box]!
 open
         "Initialize the receiver
          pane data from the model."
     list := model perform: name.
     super open!
 refreshAll
         "Transfer the data list to the borders
          form using the paneScanner."
     | sourceY lastY |
     paneScanner
         blank: (0@0 extent: frame extent).
     sourceY := topCorner y.
     lastY := topCorner y + frame height min: list size.
     paneScanner
         sourceX: topCorner x - 1.
     sourceY to: lastY do: [ :i |
         paneScanner
             moveString: (list at: i)
                 toX: 0
                 andY: i - sourceY]!
 returnIndex: aBoolean
         "Set the returnIndex to aBoolean."
     returnIndex := aBoolean!
 reverseLine: anInteger
         "Reverse the color of the item indexed by anInteger."
     | box |
     (box := self lineToRect: anInteger) isNil
         ifFalse: [paneScanner reverse: box]!
 scrollHand: oldPoint to: newPoint
         "Move the data contained in the pane
          from oldPoint to newPoint."
     self topCorner: topCorner
         - (newPoint - oldPoint)!
 scrollLeft: amount
         "Scroll the pane to the left by amount
          (if positive) or to the right by absolute
          amount (if negative)."
     self topCorner: topCorner - (amount @ 0).!
 scrollUp: amount
         "Scroll the pane up by amount (if positive)
          or down by absolute amount (if negative)."
     self topCorner: topCorner - (0 @ amount).!
 selectAtCursor
         "Set currentLine to the line
          at the cursor position."
     currentLine isNil
         ifTrue: [
             selection isNil ifTrue: [^self]]
         ifFalse: [
             currentLine > list size
                 ifTrue: [^self].
             self normalLine: selection.
             selection := currentLine].
     currentLine := nil.
     self showCursorLine.
     model
         perform: changeSelector
         with: (returnIndex
                 ifTrue: [selection]
                 ifFalse:[list at: selection])!
 selection
         "Answer an integer representing the index
          of the currently selected item."
     ^selection!
 selection: anInteger
         "Set selection to anInteger."
     selection := anInteger!
 showCursorLine
         "Reverse the cursor line and keep it
          bold if it is also selected."
     | listLine |
     (frame containsPoint: Cursor offset)
         ifFalse: [^self].
     listLine := Cursor
         offset y - frame origin y + topCorner y.
     (listLine == currentLine) ifFalse:[
         self normalLine: currentLine.
         (listLine == selection)
             ifTrue: [self boldLineReverse: listLine]
             ifFalse: [self reverseLine: listLine;
                            boldLine: selection].
         currentLine := listLine.
         self showPane]!
 showPane
         "Copy the rectangle area of the receiver
          pane from the borders form to the display screen
          using the paneScanner."
     paneScanner display:
         (0@0 extent: frame extent)!
 topCorner: aPoint
         "Change topCorner to aPoint."
     | oldCorner |
     oldCorner := topCorner.
     topCorner := (1 max: aPoint x) @
         (1 max: (aPoint y min: list size)).
     oldCorner = topCorner
         ifFalse: [
             currentLine := nil.
             self refreshAll]!
 update
         "Refresh the data list and the border form
          from the model and display them on the screen
          using the paneScanner."
     list := model perform: name.
     selection := currentLine := nil.
     self
         topCorner: 1@1;
         refreshAll;
         showPane! !

! TextPane class methods !
 initialize
         "Initialize the class variables
          to pre-built gap selection forms."
         "One time code so it is commented --
     GapAtChar := DisplayMedium new
         offset: 0 @ 0;
         setWidth: 1 height: 1;
         attrValueAt: 0 @ 0 put: 0;
         yourself.
     GapAtBlank := Form new
         offset: 0 @ 0;
         width: 1 height: 1;
         attrValueAt: 0 @ 0 put: 0;
         charValueAt: 0 @ 0 put: (Character value: 16r11);
         yourself --"!
 loggerLabeled: aString frame: aRectangle
         "Create a window with one text pane
          and answer that pane's dipatcher."
     | logger topPane |
     logger := self new.
     logger
         model: String new;
         dispatcher: logger dispatcher.
     topPane := TopPane new.
     topPane
         label: aString;
         addSubpane: logger.
     topPane dispatcher openIn: aRectangle.
     logger topPane dispatcher display.
     ^logger dispatcher! !

! TextPane methods !
 accept
         "Save the currently edited text."
     name == #yourself
         ifTrue: [
             model := textHolder string.
             ^true].
     (changeSelector == nil or: [model == nil])
         ifFalse: [
             ^model
                 perform: changeSelector
                 with: textHolder string
                 with: dispatcher]!
 activatePane
         "Activate the pane dispatcher and
          make the gap selection visible."
     super activatePane.
     self isGapSelection
         ifTrue: [self showSelection]!
 addLine: aString
         "Add aString as the last line of the text."
     textHolder addLine: aString.
     self displayChanges!
 appendChar: aCharacter
         "Append aCharacter to the end of the text."
     textHolder appendChar: aCharacter.
     aCharacter == Lf
         ifTrue: [self forceEndOntoDisplay]!
 appendText: aString
         "Append aString to the end of the text."
     textHolder appendText: aString!
 areaOnFormOf: aRectangle
         "Answer a Rectagle by converting aRectangle
          relative to the whole text to one relative to
          the pane frame."
     | origin corner formCorner |
     formCorner := frame extent - (1@1).
     origin := self
         formCoordinates: aRectangle origin.
     corner := self
         formCoordinates: aRectangle corner.
     origin y < 0
         ifTrue: [origin := 0 @ 0].
     corner y > formCorner y
         ifTrue: [corner := formCorner].
     ^(origin max: 0 @ 0)
         corner: (corner min: formCorner)!
 backspaceSelection
         "Extend the selection backwards by one space."
     ^selection
         origin: (textHolder backspacePoint: selection origin)
         corner: selection corner!
 cancel
         "Restore the last saved
          version of the text."
     name == #yourself
         ifTrue: [textHolder string: model]
         ifFalse: [
             (model respondsTo: #cancel)
                 ifTrue: [^model cancel]
                 ifFalse:[
                     textHolder
                         string: (model perform: name)]].
      self
         topCorner: 1@1;
         refreshAll!
 changedAreaOnForm
         "Answer a Rectangle representing the area on
          the pane frame that has pending changes."
     changedArea == nil
         ifTrue: [^1@1 corner: 0@0]
         ifFalse:[^self areaOnFormOf: changedArea]!
 close
         "Release the application model."
     super close!
 compilerError: aString at: anInteger in: codeString
         "Display the error message aString
          in reversed form at the indicated position
          anInteger in the source codeString."
     | origin corner box |
     self hideSelection.
     box := self replaceWithText:
         (codeString copyFrom: 1 to: anInteger - 1).
     origin := box corner + (1@0).
     self selectBefore: origin.
     box := self replaceWithText:
         aString trimBlanks.
     corner := box corner.
     self
         selectAfter: corner;
         replaceWithText:
             (codeString copyFrom: anInteger to: codeString size - 1);
         selectFrom: origin to: corner;
         forceSelectionOntoDisplay!
 deactivatePane
         "Deactivate the pane dispatcher
          and hide the gap selection."
     | box |
     super deactivatePane.
     self isGapSelection
         ifTrue: [
             self
                 hideSelection;
                 displayChanges]!
 defaultDispatcherClass
         "Answer TextEditor which is the default
          dispatcher of a TextPane."
     ^TextEditor!
 display: aRectangle
         "Regenerate the data in the area defined by aRectangle
          on the borders form through the textHolder."
     paneScanner
         blank: aRectangle.
     textHolder
         display: (self stringCoordinates: aRectangle)
         at: aRectangle origin
         on: paneScanner!
 displayChanges
         "Update the borders form as well as the
          display screen with all pending changes."
     | box origin corner height width |
     box := self changedAreaOnForm.
     height := box height.
     width := box width.
     ((height = 1 and: [width > 0])
      or: [(width @ height) = frame extent])
         ifTrue: [
             self display: box;
                  moveSelection.
             paneScanner display:
                 (box width: width + 1)]   "add selector"
         ifFalse:[
             height > 1 ifTrue: [
                 origin := box origin.
                 corner := box corner.
                 self
                     display: (origin corner: (frame width - 1) @ origin y);
                     display: (0 @ (origin y + 1) corner:
                         (frame width - 1) @ (corner y - 1));
                     display: (0 @ corner y corner: corner);
                     moveSelection.
                 paneScanner
                     display: (0 @ origin y corner:
                              (frame width - 1) @ corner y)]].
    self noChanges!
 displayWindow
         "Transfer all pending changes and the gap
          selector to the borders form."
     self display: (0@0 extent: frame extent).
     self isGapSelection
         ifFalse: [self moveSelection]!
 doIt
         "Compile and execute the selected text.
          If no error, log it on the change log
          and answer the result of the evaluation;
          else restart the Scheduler."
     | source result |
     self topPane flashLabel.
     source := (textHolder stringIn: selection), ' '.
     result := Compiler
         evaluate: source
         in: UndefinedObject
         to: nil
         notifying: self
         ifFail: [
             self topPane dispatcher
                 unflashLabel;
                 deactivateWindow.
             Scheduler runMethods].
     Methods logEvaluate: source.
     self topPane unflashLabel.
     self
         hideSelection;
         selectAfter: selection corner;
         displayChanges;
         showSelection.
     ^result!
 doIt: errBlock
         "Compile and execute the selected text.
          If no error, log it on the change log
          and answer the result of the evaluation;
          else perform the errBlock."
     | source result |
     self topPane flashLabel.
     source := (textHolder stringIn: selection), ' '.
     result := Compiler
         evaluate: source
         in: UndefinedObject
         to: nil
         notifying: self
         ifFail: errBlock.
     Methods logEvaluate: source.
     self topPane unflashLabel.
     self
         hideSelection;
         selectAfter: selection corner;
         displayChanges;
         showSelection.
     ^result!
 fileInFrom: aFileStream
         "Refresh the pane data with the current
          contents of aFileStream."
     aFileStream reset.
     textHolder fileInFrom: aFileStream.
     topCorner := nil.
     self
         topCorner: 1@1;
         selectAfter: 0 @ 1!
 fileOutOn: aFileStream
         "Write the pane data out on aFileStream"
     | directory pathName fileName lineDelimiter |
     directory := aFileStream file directory.
     fileName := aFileStream file name.
     pathName := aFileStream pathName.
     lineDelimiter := aFileStream lineDelimiter.
     aFileStream close.
     File remove: pathName.
     aFileStream become: (directory file: fileName).
     aFileStream lineDelimiter: lineDelimiter.
     textHolder fileOutOn: aFileStream.
     aFileStream flush!
 forceEndOntoDisplay
         "Force the end of the text to appear on
          the display screen."
     | corner |
     corner:= textHolder extent.
     (corner y - topCorner y) <= frame extent y
         ifFalse: [
             self topCorner: corner].
     self displayChanges!
 forceSelectionOntoDisplay
         "Force the origin of the selection to
          appear on the display screen."
     | box |
     box := (topCorner extent: frame extent).
     (box containsPoint: selection origin)
         ifFalse: [
             self topCorner: topCorner + selection origin
                 - box center].
     self displayChanges!
 formCoordinates: anObject
         "Convert coordinates relative to the whole text
          to coordinates relative to the pane frame.
          The argument anObject represents a Point or a
          Rectangle.  Answer a Point or a Rectangle
          according to anObject."
     (anObject class == Point)
         ifTrue: [^anObject - topCorner]
         ifFalse: [
             ^anObject translateBy: (0@0) - topCorner]!
 frame: aRectangle
         "Change the frame rectangle of the pane
          to aRectangle."
     paneScanner := StringBlt new
         initialize: aRectangle
         on: self topPane bordersForm
         color: self topPane color attribute.
     super frame: aRectangle.
     topCorner := 1 @ 1.
     self refreshAll!
 hideSelection
         "Hide the visual clue of the selection."
     | box |
     (self isGapSelection)
         ifTrue: [
             ^self update:
                 (selection origin corner: selection origin)].
     self update: selection.
     box := self areaOnFormOf: selection.
     paneScanner
         paint:
             (0 @ box origin y
                 corner: (frame width - 1) @ box corner y)!
 hideSelection: beginPoint to: endPoint
         "Hide selection from beginPoint to endPoint."
     selection
         origin: beginPoint corner: endPoint.
     self hideSelection!
 initialize
         "Initialize the instance variables of
          the receiver pane."
     super initialize.
     self
         name: #yourself;
         model: String new.
     topCorner := 1@1.
     self selectBefore: 1@1.
     textHolder := StringModel for: ''.
     textHolder textPane: self!
 isGapSelection
         "Answer true if the selection is a gap,
          else answer false."
     ^selection corner isBefore: selection origin!
 moveSelection
         "Transfer the visual clue of the selection
          onto the borders form."
     | box |
     self isGapSelection
         ifTrue: [
             dispatcher active ifFalse: [^self].
             box := self formCoordinates: selection.
             ((textHolder stringIn:
                 (selection origin corner: selection origin))
                 at: 1)
              = Space
                 ifTrue: [
                     paneScanner
                         setGap: GapAtBlank
                         at: box origin]
                 ifFalse:[
                     paneScanner
                         setGap: GapAtChar
                         at: box origin] ]
         ifFalse: [self reverse: selection]!
 noChanges
         "Set pending changes to nil."
     changedArea := nil!
 open
         "Initialize textHolder and display
          the begining part of it."
     textHolder isNil
         ifTrue: [
             textHolder := StringModel for: ''.
             textHolder textPane: self].
     self
         selectAfter: 0@1;
         cancel.
     super open!
 performMenu
         "If the model has a menu creation method
          defined, give it control, else ask the
          dispatcher class for the menu."
     | menu |
     (model isNil or: [paneMenuSelector isNil])
         ifTrue: [menu := dispatcher class menu]
         ifFalse: [menu := model perform: paneMenuSelector].
     self popUp: menu!
 refreshAll
         "Make the entire pane to be the pending change."
     changedArea := topCorner extent: frame extent!
 replaceWithChar: aCharacter
         "Replace the selected text with aCharaceter.
          Answer the position of the new character."
     ^selection origin corner:
         (textHolder replace: selection withChar: aCharacter).!
 replaceWithText: aString
         "Replace the selected text with aString.
          Answer the position of the last character
          in the new text."
     ^selection origin corner:
         (textHolder replace: selection withText: aString).!
 reverse: aRectangle
         "Reverse the display for the text described
          by aRectangle area on the borders form."
     | box origin corner |
     box := self areaOnFormOf: aRectangle.
     origin:= box origin.
     corner:= box corner.
     origin y = corner y ifTrue: [
         ^paneScanner
             reverse: box].
     origin y < corner y ifTrue: [
         ^paneScanner
             reverse:
                 (origin corner: (frame width - 1) @ origin y);
             reverse:
                 (0 @ (origin y + 1)
                     corner: (frame width - 1) @ (corner y - 1 ));
             reverse:
                 (0 @ corner y corner: corner)]!
 scrollHand: oldPoint to: newPoint
         "Move the text from oldPoint to newPoint
          in the receiver pane."
     self
         hideSelection;
         topCorner: topCorner
             - (newPoint - oldPoint);
         displayChanges;
         showSelection!
 scrollLeft: anInteger
         "Scroll the pane text anInteger number of
          characters to the left (if anInteger is
          positive) or to the right (if negative)."
     self
         hideSelection;
         topCorner: topCorner - (anInteger @ 0);
         displayChanges;
         showSelection!
 scrollUp: anInteger
         "Scroll the pane text anInteger number of
          lines up (if anInteger is positive) or
          down (if negative)."
     self
         hideSelection;
         topCorner: topCorner - (0 @ anInteger);
         displayChanges;
         showSelection!
 selectAfter: aPoint
         "Place the selection after aPoint."
     selection := aPoint + (1 @ 0) corner: aPoint!
 selectAll
         "Select all the text."
     self
         hideSelection;
         selectFrom: 1@1 to: textHolder extent;
         displayChanges;
         showSelection!
 selectAtCursor
         "Place the gap selection before
          the cursor position."
     (frame containsPoint: Cursor offset)
         ifTrue: [
             self
                 hideSelection;
                 selectBefore: Cursor offset -
                     frame origin + topCorner;
                 update: (selection origin corner:
                     selection origin);
                 displayChanges]!
 selectAtEnd
         "Place the gap selection at the end of the text."
     self selectAfter: textHolder extent!
 selectBefore: aPoint
         "Place the gap selection before aPoint."
     selection := aPoint corner: aPoint - (1 @ 0)!
 selectedString
         "Answer a String containing the text currently selected."
     ^textHolder stringIn: selection!
 selectFrom: beginPoint to: endPoint
         "Set selection to the rectangle described
          by origin beginPoint and corner endPoint."
     selection origin: beginPoint corner: endPoint!
 selection
         "Answer a Rectangle describing
          the current selection."
     ^selection!
 selectTo: aPoint
         "Extend the selection to aPoint either
          before or after the original one."
     | bPoint begin end |
     begin := selection origin.
     end := selection corner.
     self isGapSelection
          ifTrue: [
             self hideSelection.
             dragOrigin := begin].
     (aPoint isBefore: dragOrigin)
         ifTrue: [ "backward"
             (end isBefore: dragOrigin)
                 ifFalse: [ "get rid of tail"
                     self hideSelection: dragOrigin
                         to: end.
                     end := dragOrigin - (1@0)].
             (aPoint isBefore: begin)
                 ifTrue: [
                     self showSelection: aPoint
                         to: begin - (1@0)]
                 ifFalse: [
                     self hideSelection: begin
                         to: aPoint - (1@0)].
             begin := aPoint]
         ifFalse: [ "forward"
             (begin isBefore: dragOrigin)
                 ifTrue: [ "get rid of head"
                     self hideSelection: begin
                         to: dragOrigin - (1@0).
                     begin := dragOrigin].
             aPoint = end
                 ifFalse: [
                     (aPoint isBefore: end)
                         ifTrue: [
                             self hideSelection: aPoint + (1@0)
                                 to: end]
                         ifFalse: [
                             self showSelection: end + (1@0)
                                 to: aPoint]].
             end := aPoint].
     selection origin: begin corner: end!
 selectToCursor
         "Extend the selection to the cursor position."
     (frame containsPoint: Cursor offset)
         ifTrue: [
             self
                 selectTo: Cursor offset - frame origin
                           + topCorner;
                 update: selection;
                 displayChanges]!
 selectToShifted
         "Extend the selection to the cursor position
          for shifted mouse select button."
     | aPoint |
     aPoint := Cursor offset - frame origin
                           + topCorner.
     (frame containsPoint: Cursor offset)
         ifTrue: [
             (aPoint isBefore: selection origin)
                 ifTrue: [dragOrigin := selection corner + (1@0)]
                 ifFalse: [dragOrigin := selection origin].
             self
                 selectTo: aPoint;
                 update: selection;
                 displayChanges]!
 showPane
         "Do nothing.  Copying from the borders
          form to the display screen is done by
          displayChanges."!
 showSelection
         "Make selection visible on both the
          borders form and the display screen."
     | box |
     self moveSelection.
     box := self formCoordinates: selection.
     self isGapSelection
         ifTrue: [
             paneScanner
                 display: (box origin corner: box origin)]
         ifFalse: [
             paneScanner
                 display: (0 @ box origin y corner:
                           (frame width - 1) @ box corner y)]!
 showSelection: beginPoint to: endPoint
         "Set selection to the rectangle described
          by origin beginPoint and corner endPoint,
          and reverse it."
     selection
         origin: beginPoint corner: endPoint.
     self showSelection!
 stringCoordinates: anObject
         "Convert the form coordinates (relative to the pane frame)
          to string coordinates (relative to text).
          The argument anObject represents a Point or a Rectangle.
          Answer a Point or a Rectangle according to anObject."
     (anObject class == Point)
         ifTrue: [^anObject + topCorner]
         ifFalse: [^anObject translateBy: topCorner]!
 topCorner: aPoint
         "Change the top-left corner of the receiver
          pane to aPoint which causes the text
          located at the newCorner to be shown in
          the pane."
     | oldCorner |
     oldCorner := topCorner.
     topCorner := (1 max: aPoint x) @
         (1 max: (aPoint y min: textHolder extent y)).
     oldCorner = topCorner
         ifFalse: [self refreshAll]!
 update
         "Refresh the pane area on the borders form
          and on the display screen through the model."
     dispatcher
         initialize;
         cancel!
 update: anObject
         "The model has changed. If anObject
          is a rectangle, display it. Else
          pass it up to superclass."
     (anObject class == Rectangle)
         ifTrue: [ "update changedArea"
             changedArea == nil
                 ifTrue: [ "a copy"
                     changedArea := (anObject origin
                         corner: anObject corner)]
                 ifFalse:[
                     changedArea := changedArea
                         merge: anObject]]
         ifFalse: [super update: anObject]! !

! TopPane class methods !
 bottomLeft
         "Answer the border value of bottom left corner."
     ^16r3!
 bottomRight
         "Answer the border value of bottom right corner."
     ^16r9!
 horizontalLine
         "Answer the border value of horizontal line."
     ^16rA!
 initializeFor: screenMode
         "Initialize the class variable LineCharacters
          for a selected screen mode (#color or #monochrome)."
     LineCharacters := (Array new: 48)
             atAllPut: Space;
             at: 3 put: 16rC0 asCharacter;
             at: 5 put: 16rB3 asCharacter;
             at: 6 put: 16rDA asCharacter;
             at: 7 put: 16rC3 asCharacter;
             at: 9 put: 16rD9 asCharacter;
             at: 10 put: 16rC4 asCharacter;
             at: 11 put: 16rC1 asCharacter;
             at: 12 put: 16rBF asCharacter;
             at: 13 put: 16rB4 asCharacter;
             at: 14 put: 16rC2 asCharacter;
             at: 15 put: 16rC5 asCharacter;
             at: 21 put: 16rB3 asCharacter;
             at: 22 put: 16rDA asCharacter;
             at: 26 put: 16rC4 asCharacter;
             at: 28 put: 16rBF asCharacter;
             at: 35 put: 16rD4 asCharacter;
             at: 41 put: 16rBE asCharacter;
             at: 42 put: 16rCD asCharacter;
             yourself.
     screenMode == #color
         ifTrue: [
             LineCharacters
                 at: 23 put: 16rC3 asCharacter;
                 at: 29 put: 16rB4 asCharacter;
                 at: 30 put: 16rC2 asCharacter;
                 at: 43 put: 16rCF asCharacter]
         ifFalse: [
             LineCharacters
                 at: 23 put: 16rB3 asCharacter;
                 at: 29 put: 16rB3 asCharacter;
                 at: 30 put: 16rC4 asCharacter;
                 at: 43 put: 16rCD asCharacter]!
 lineFor: anAttribute
         "Convert a border value recorded as anAttribute
          into a graphical character and answer it."
     anAttribute = 0
         ifTrue: [^Space]
         ifFalse:[^LineCharacters at: anAttribute]!
 topLeft
         "Answer the border value of top left corner."
     ^16r6!
 topRight
         "Answer the border value of top right corner."
     ^16rC!
 verticalLine
         "Answer the border value of vertical line."
     ^16r5! !

! TopPane methods !
 activateWindow
         "Activate the top dispatcher, highlight
          the label, and invoke window activation
          methods of all subpanes."
     self highlightLabel.
     dispatcher activate.
     collapsed ifFalse: [super activateWindow]!
 background: aColorAttribute
         "Change the background color to
          aColorAttribute and recolor the
          window."
     | attribute |
     attribute := color attribute bitAnd: 7.
     color attribute: attribute +
         (aColorAttribute * 16).
     self recolor!
 border
         "OR in the receiver top pane border
          values on the borders form."
     | byteBlt |
     byteBlt := ByteBlt
         destForm: borders
         sourceForm: nil
         halftone: nil
         combinationRule: Form under
         destOrigin: 0 @ 0
         sourceOrigin: 0 @ 0
         extent: frame extent
         clipRect: ((0@0 extent: borders extent)).
     byteBlt
         mask: self class horizontalLine + 16;
         destOrigin: (1@0);
         width: frame width - 2;
         height: 1;
         copyBytes.
     byteBlt
         mask: self class horizontalLine + 32;
         destOrigin: (1 @ (frame height - 1));
         width: frame width - 2;
         height: 1;
         copyBytes.
     byteBlt
         mask: self class verticalLine + 16;
         destOrigin: (0@1);
         width: 1;
         height: frame height - 2;
         copyBytes.
     byteBlt
         mask: self class verticalLine + 16;
         destOrigin: (frame width - 1 @ 1);
         width: 1;
         height: frame height - 2;
         copyBytes.
     byteBlt
         mask: self class topLeft + 16;
         destOrigin: 0 @ 0;
         width: 1;
         height: 1;
         copyBytes.
     byteBlt
         mask: self class topRight + 16;
         destX: byteBlt destX + frame width - 1;
         copyBytes.
     byteBlt
         mask: self class bottomRight + 32;
         destY: byteBlt destY + frame height - 1;
         copyBytes.
     byteBlt
         mask: self class bottomLeft + 32;
         destX: byteBlt destX - frame width + 1;
         copyBytes!
 border: aRectangle
         "OR in the border values of a subpane
          aRectangle on the borders form."
     | byteBlt box |
     box := aRectangle expandBy: 1@1.
     byteBlt := ByteBlt
         destForm: borders
         sourceForm: nil
         halftone: nil
         combinationRule: Form under
         destOrigin: 0 @ 0
         sourceOrigin: 0 @ 0
         extent: frame extent
         clipRect: ((0@0 extent: borders extent)).
     byteBlt
         mask: self class horizontalLine;
         destOrigin: box origin - frame origin + (1@0);
         width: box width - 2;
         height: 1;
         copyBytes.
     byteBlt
         destOrigin: box origin - frame origin +
             (1 @ (box height - 1));
         copyBytes.
     byteBlt
         mask: self class verticalLine;
         destOrigin: box origin - frame origin + (0@1);
         width: 1;
         height: box height - 2;
         copyBytes.
     byteBlt
         destOrigin: box origin - frame origin +
             (box width - 1 @ 1);
         copyBytes.
     byteBlt
         mask: self class topLeft;
         destOrigin: box origin - frame origin;
         width: 1;
         height: 1;
         copyBytes.
     byteBlt
         mask: self class topRight;
         destX: byteBlt destX + box width - 1;
         copyBytes.
     byteBlt
         mask: self class bottomRight;
         destY: byteBlt destY + box height - 1;
         copyBytes.
     byteBlt
         mask: self class bottomLeft;
         destX: byteBlt destX - box width + 1;
         copyBytes!
 borderAttribute
         "Answer the color attribute of the border."
     | attribute |
     attribute := (color attribute bitAnd: 16r70)
         bitXor: BorderBackground.
     attribute = 16r70
         ifTrue: [^attribute]
         ifFalse: [^attribute bitOr: White]!
 bordersForm
         "Answer borders form."
     ^borders!
 collapse
         "Mark the window collapsed and move
          the cursor to the label."
     collapsed := true.
     Cursor offset: label offset!
 collapsed
         "Answer true if the window is collapsed,
          else answer false."
     ^collapsed!
 color
         "Answer an InfiniteForm of the receiver's
          window color."
     ^color!
 cyclePane: subPane
         "Move to the next subPane in a
          cyclic fashion."
     (subpanes after: subPane ifNone: [subpanes first])
         dispatcher homeCursor!
 deactivatePane
         "Do nothing."!
 deactivateWindow
         "Mark the window as deactive and
          turn off the highlight of the label."
     self normalLabel.
     collapsed
         ifTrue: [dispatcher deactivate]
         ifFalse: [super deactivateWindow]!
 defaultDispatcherClass
         "Answer TopDispatcher."
     ^TopDispatcher!
 displayWindow
         "Invoke subpanes to transfer their contents
          to the borders form and then copy
          the borders form and label form to the screen."
     collapsed
         ifFalse: [
             subpanes do: [ :subpane |
                 subpane displayWindow].
             borders display].
     label display.!
 flashLabel
         "Make the window label flash
          signaling work in process."
     label
         fill: (0@0 extent: label extent)
         rule: Form under
         mask: Form blink + Form bold.
     label display!
 foreground: aColorAttribute
         "Change the foreground color to
          aColorAttribute and recolor the
          window."
     | attribute |
     attribute := color attribute bitAnd: 16r70.
     color attribute: attribute + aColorAttribute.
     self recolor!
 formatBorders
         "On the borders form, turn the border
          values of the attribute part into
          real graphical characters in the
          character part and set the attribute
          part to the window background color."
     | a index attribute |
     index := borders attrMap size.
     attribute := self borderAttribute bitXor: BorderBackground.
     [index > 0]
         whileTrue: [
             (a := borders attrMap at: index) > 0
                 ifTrue: [
                     borders charMap
                         at: index
                         put: (self class lineFor: a).
                     borders attrMap
                         at: index
                         put: attribute]
                 ifFalse: [
                     borders attrMap
                         at: index
                         put: color attribute].
             index := index - 1].
     borders
         reverseMask: BorderBackground;
         reverse: ((0 @ 0 extent: borders extent) insetBy: 1 @ 1)
             with: BorderBackground!
 frame
         "Answer the framing rectangle."
     ^collapsed
         ifTrue: [label boundingBox]
         ifFalse: [frame]!
 frame: aRectangle
         "Change the framing rectangle to aRectangle
          and reset the offset of the label form."
     collapsed := false.
     super frame: aRectangle.
     label offset: aRectangle origin + (1 @ 0)!
 hasCursor
         "Answer true if the label or the receiver top
          pane contains the cursor, else answer false."
     ^super hasCursor
         or: [collapsed not
             and: [label boundingBox
                 containsPoint: Cursor offset]]!
 highlightLabel
         "Display the label in high intensity
          signaling the active window."
     label
         fill: (0@0 extent: label extent)
         mask: (((color attribute bitAnd: 16r70)
             bitXor: BorderBackground)
                 bitOr: White + Bold).
     label display!
 initialize
         "Initialize the window as collapsed with no label
          and a default window color."
     super initialize.
     collapsed := true.
     color := InfiniteForm new
         character: $ ;
         attribute: (PaneColors addLast: PaneColors removeFirst) * 16.
     self label: ' '.
     minimumSize := 3@1!
 label: aString
         "Construct the label form with aString
          as its contents."
     | displayString origin |
     (label isKindOf: Form)
         ifTrue: [origin := label offset].
     displayString := DisplayString for: aString.
     label := Form
         fromDisplay: displayString boundingBox.
     color displayOn: label.
     displayString displayOn: label.
     origin == nil
         ifFalse: [label offset: origin].
     (self frame corner > (0 @ 0) and: [self hasCursor])
         ifTrue: [self highlightLabel]!
 minimumSize
         "Answer a Point describing the
          minimum size of the receiver window."
     ^minimumSize!
 minimumSize: extentPoint
         "Set the minimum size of the window
          to extentPoint."
     ^minimumSize := extentPoint!
 move
         "Ask the user for a new origin point for
          the receiver window and move it to there."
     | box |
     box := collapsed
         ifTrue: [label boundingBox]
         ifFalse: [frame].
     box origin:
         (Display extent - box extent
             min: box origin + 1).
     Cursor offset: box origin.
     box origin:
         (PointDispatcher pointFromUserDisplaying: box).
     collapsed
         ifTrue: [
             label offset: box origin.
             frame := box]
         ifFalse: [self reframe: box]!
 normalLabel
         "Turn off both the highlight and
          flashing of the label."
     label
         fill: (0@0 extent: label extent)
         mask: color attribute.
     label display!
 performMenu
         "Get the menu from either the model
          or the dispatcher class and give it
          control."
     | menu |
     (paneMenuSelector isNil or: [model isNil])
         ifTrue: [menu := dispatcher class menu]
         ifFalse: [menu := model perform: paneMenuSelector].
     self
         popUp: menu
         at: Cursor offset!
 recolor
         "Paint the window with the attribute
          contained in the color form."
     label
         fill: (0@0 extent: label extent)
         mask: color attribute.
     collapsed
         ifTrue: [
             borders
                 fill: (0@0 extent: borders extent)
                 mask: color attribute]
         ifFalse: [
             self reframe: frame]!
 reframe
         "Reinitialize the borders form according
          to a rectangle given by the user,
          draw the borders of all panes, and move
          the cursor to the top-left corner of
          the first subpane."
     Cursor offset: frame origin.
     self reframe:
         (PointDispatcher rectangleFromUserOfSize: minimumSize)!
 reframe: aRectangle
         "Reinitialize the borders form according to
          aRectangle and draw the borders of all panes."
     borders := Form new
         width: aRectangle width height: aRectangle height;
         offset: aRectangle origin;
         fill: (0@0 extent: aRectangle extent)
             rule: Form over
             color: InfiniteForm blank;
         yourself.
     self frame: (framingBlock value: aRectangle).
     subpanes do: [ :subpane |
         subpane reframe: (frame insetBy: 1@1)].
     self formatBorders!
 searchForActivePane
         "Answer the lowest level subpane that
          wants control (has the cursor)."
     collapsed ifTrue: [^self].
     ^super searchForActivePane!
 unflashLabel
         "Stop the label flashing to
          signal work done."
     label
         fill: (0@0 extent: label extent)
         rule: Form erase
         mask: Form blink.
     label display!
 update: aSymbol
         "If aSymbol equals #label then update
          the window label, else do nothing."
     | newLabel |
     aSymbol == #label
         ifTrue: [
             (newLabel := model label) == nil
                 ifFalse: [dispatcher label: newLabel]]
         ifFalse:[super update: aSymbol]! !

! Point class methods ! !

! Point methods !
 * scale
         "Answer a new Point which is the product of
          the receiver and scale.  Scale can be a
          number or a Point.  If scale is a Point, the
          x-coordinates are multiplied and the
          y-coordinates are multiplied."
     scale class == Point
         ifTrue: [^ ( x * scale x) @ ( y * scale y)]
         ifFalse: [^ ( x * scale) @ ( y * scale)]!
 + delta
         "Answer a new Point which is the sum of the
          receiver and delta.  Delta can be a number or a
          Point.  If delta is a Point, the x-coordinates
          are added and the y-coordinates are added."
     delta class == Point
         ifTrue: [^ ( x + delta x) @ ( y + delta y)]
         ifFalse: [^ ( x + delta) @ ( y + delta)]!
 - delta
         "Answer a new Point which is the difference of the
          receiver and delta.  delta can be a number or a
          Point.  If delta is a Point, the x-coordinates are
          subtracted and the y-coordinates are subtracted."
     delta class == Point
         ifTrue: [^ ( x - delta x) @ ( y - delta y)]
         ifFalse: [^ ( x - delta) @ ( y - delta)]!
 // scale
         "Answer a new Point which is the receiver Point
          divided by scale.  Scale can be a number or a
          Point.  If scale is a Point, the x-coordinates
          are divided and the y-coordinates are divided."
     scale class == Point
         ifTrue: [^ ( x // scale x) @ ( y // scale y)]
         ifFalse: [^ ( x // scale) @ ( y // scale)]!
 < aPoint
         "Answer true if the x and y coordinates of the receiver
          are less than the x and y coordinates of aPoint,
          respectively, else answer false."
     ^(x < aPoint x) and: [y < aPoint y]!
 <= aPoint
         "Answer true if the x and y coordinates of the receiver
          are less than or equal to the x and y coordinates of aPoint,
          respectively, else answer false."
     ^(x <= aPoint x) and: [y <= aPoint y]!
 = aPoint
         "Answer true if the x and y coordinates of the receiver
          are equal to the x and y coordinates of aPoint,
          respectively, else answer false."
     ^aPoint class == Point
         and: [x = aPoint x
             and: [y = aPoint y]]!
 > aPoint
         "Answer true if the x and y coordinates of the receiver
          are greater than the x and y coordinates of aPoint,
          respectively, else answer false."
     ^(x > aPoint x) and: [self y > aPoint y]!
 >= aPoint
         "Answer true if the x and y coordinates of the receiver
          are greater than or equal to the x and y coordinates of
          aPoint, respectively, else answer false."
     ^(aPoint x <= x) and: [aPoint y <= y]!
 abs
         "Answer a Point with coordinates that are the absolute
          value of the x and y coordinates of the receiver."
     ^x abs @ y abs!
 between: firstPoint and: secondPoint
         "Answer true if the receiver is greater than or equal to
          firstPoint and less than or equal to secondPoint, else
          answer false."
     ^firstPoint <= self
         and: [self <= secondPoint]!
 corner: aPoint
         "Answer a Rectangle with origin equal to the receiver
          and corner equal to aPoint."
     ^Rectangle origin: self corner: aPoint!
 dist: aPoint
         "Answer a Float which is the distance between the
          receiver and aPoint."
     ^((x - aPoint x) squared + (y - aPoint y) squared) sqrt!
 dotProduct: aPoint
         "Answer a number which is the sum of the product
          of the x-coordinates and the product of the
          y-coordinates of the receiver and aPoint."
     ^(x * aPoint x) + (y * aPoint y)!
 extent: aPoint
         "Answer a Rectangle with origin equal to the receiver
          and extent equal to aPoint."
     ^Rectangle origin: self extent: aPoint!
 hash
         "Answer the integer hash value of the receiver."
     ^(x abs + y abs) truncated!
 isBefore: aPoint
         "Answer true if receiver is text-wise earlier
          than aPoint, else answer false."
     ^aPoint y > y
         or: [aPoint y = y
             and: [aPoint x > x]]!
 max: aPoint
         "Answer a Point with the maximum of the x-coordinates
          and the maximum of the y-coordinates of the receiver
          and aPoint."
     ^(x max: aPoint x) @ (y max: aPoint y)!
 min: aPoint
         "Answer a Point with the minimum of the x-coordinates
          and the minimum of the y-coordinates of the receiver
          and aPoint."
     ^(x min: aPoint x) @ (y min: aPoint y)!
 negated
         "Answer a Point with the x and y coordinates of
          the receiver negated."
     ^x negated @ y negated!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     x printOn: aStream.
     aStream nextPutAll: ' @ '.
     y printOn: aStream!
 rounded
         "Answer a Point which has the receiver coordinates
          rounded to integers."
     ^x rounded @ y rounded!
 transpose
         "Answer a Point with x-coordinate equal to the
          receiver's y-coordinate and y-coordinate equal
          to receiver's x-coordinate."
     ^y @ x!
 x
         "Answer the receiver's x-coordinate."
     ^x!
 x: aNumber
         "Answer the receiver.  Set the receiver's
          x-coordinate to aNumber."
     x := aNumber!
 y
         "Answer the receiver's y-coordinate."
     ^y!
 y: aNumber
         "Answer the receiver.  Set the receiver's
          y-coordinate to aNumber."
     y := aNumber! !

! Prompter class methods !
 prompt: questionString default: answerString
         "Open a new Prompter with questionString as its question
          and answerString as its default answer.  Answer the user
          response (a String) without evaluating it."
     ^self new
         evaluating: false;
         prompt: questionString default: answerString!
 prompt: questionString defaultExpression: answerString
         "Open a new Prompter with questionString as its question
          and answerString as its default answer.  Answer the
          resulting object after evaluating the user response."
     ^self new
         evaluating: true;
         prompt: questionString default: answerString! !

! Prompter methods !
 acceptReply: aString from: aDispatcher
         "Private - Evaluate the answer aString if the instance
          variable evaluating is true.  Pass the resulting object
          or aString (when evaluating is false) as the result."
     self reply:
         (evaluating
             ifTrue: [
                 Compiler
                     evaluate: aString
                     in: nil class
                     to: nil
                     notifying: aDispatcher
                     ifFail: [^false]]
             ifFalse: [aString trimBlanks])!
 cancelPrompter
         "Private - Cancel the Prompter and answer nil."
     self reply: nil!
 evaluating: aBoolean
         "Private - Set the instance variable
          evaluating to aBoolean."
     evaluating := aBoolean!
 menu
         "Private - Answer a Menu to be used by the
          receiver text pane."
     ^Menu
         labels: 'copy\cut\paste\accept\cancel' withCrs
         lines: #()
         selectors: #(copySelection cutSelection
             pasteSelection accept cancelPrompter)!
 prompt: question default: answer
         "Private - Use the strings question and answer
          to initialize instance variables prompt and
          reply. Set up exitBlock.  Create the Prompter
          window and give it control."
     | topPane promptBox tempOffset |
     prompt := question.
     reply := answer.
     exitBlock := [^reply].
     topPane := TopPane new
         label: question;
         minimumSize:
             (((prompt size max: reply size) max: 15) + 4
             min: 60) @ 3;
         yourself.
     topPane addSubpane:
         (replyPane := TextPane new
             model: self;
             menu: #menu;
             dispatcher: PromptEditor new;
             name: #reply;
             change: #acceptReply:from:;
             framingBlock: [:box|
                 box origin corner: box corner]).
     offset := Cursor offset.
     promptBox := Rectangle origin: offset
         extent: (topPane minimumSize max: 3 @ 3).
     tempOffset := (Display extent - promptBox extent)
         min: offset.
     promptBox origin: tempOffset.
     hiddenArea := Form fromDisplay: promptBox.
     hiddenArea offset: tempOffset.
     topPane dispatcher openIn: promptBox.
     replyPane
         selectAtEnd;
         homeCursor.
     topPane dispatcher activateWindow!
 reply
         "Private - Answer the user response (evaluated
          if so requested)."
     ^reply!
 reply: anObject
         "Private - Recover the screen image underneath
          the Prompter window.  Close the Prompter window.
          Reactivate the previous window.  Exit the Prompter
          by evaluating the exitBlock which answers anObject."
     reply := anObject.
     hiddenArea displayAt: 0 @ 0.
     replyPane dispatcher topDispatcher closeWindow.
     Scheduler topDispatcher activate.
     Cursor offset: offset.
     exitBlock value! !

! Rectangle class methods !
 left: originX right: cornerX top: originY bottom: cornerY
         "Answer a Rectangle whose left, right, top and bottom
          are described by the numbers originX, cornerX, originY
          and cornerY respectively."
     ^self new origin: originX @ originY corner: cornerX @ cornerY!
 origin: originPoint corner: cornerPoint
         "Answer a Rectangle with origin and corner points
          described by originPoint and cornerPoint."
     ^self new origin: originPoint corner: cornerPoint!
 origin: originPoint extent: extentPoint
         "Answer a Rectangle whose origin and extent (width and
          height) are described by originPoint and extentPoint."
     ^self new origin: originPoint extent: extentPoint! !

! Rectangle methods !
 amountToTranslateWithin: aRectangle
         "Answer a Point, delta, such that when the receiver is
          moved by delta it will lie within aRectangle."
     | delta |
     (aRectangle contains: self)
         ifTrue: [ ^0 @ 0].
     delta := aRectangle origin - origin.
     (aRectangle contains:
         (self class origin: origin+delta corner: corner+delta))
             ifFalse: [
                 ^self error: 'rectangle does not fit inside'].
     ^delta!
 area
         "Answer a number which is
          the area of the receiver."
     ^self width * self height!
 areasOutside: aRectangle
         "Answer a collection of Rectangles describing the
          areas in the receiver which are outside aRectangle."
     | collection newOrigin newCorner |
     (self intersects: aRectangle)
         ifFalse: [^OrderedCollection with: self].
     collection := OrderedCollection new: 4.
     newOrigin := origin.
     newCorner := self right @ aRectangle top
     newOrigin <= newCorner
         ifTrue: [
             collection add:
                 (newOrigin corner: newCorner)].
     newOrigin := self left @ (aRectangle top max: self top).
     newCorner := aRectangle left @
         (aRectangle bottom min: self bottom).
     newOrigin <= newCorner
         ifTrue: [
             collection add:
                 (newOrigin corner: newCorner)].
     newOrigin := aRectangle right @
         (aRectangle top max: self top).
     newCorner := self right @
         (aRectangle bottom min: self bottom).
     newOrigin <= newCorner
         ifTrue: [
             collection add:
                 (newOrigin corner: newCorner)].
     newOrigin := self left @
         (aRectangle bottom min: self bottom).
     newCorner := corner.
     newOrigin <= newCorner
         ifTrue: [
             collection add:
                 (newOrigin corner: newCorner)].
     ^collection!
 bottom
         "Answer the y-coordinate of the bottom of the receiver."
     ^corner y!
 bottomCenter
         "Answer the Point at the bottom center of the receiver."
     ^((corner x + origin x) // 2) @ corner y!
 bottomLeft
         "Answer the Point at the bottom left corner of the receiver."
     ^origin x @ corner y!
 bottomRight
         "Answer the Point at the bottom right corner of the receiver."
     ^corner!
 center
         "Answer the Point in the center of the receiver."
     ^(corner + origin) // 2!
 contains: aRectangle
         "Answer true if aRectangle is entirely contained within
          the receiver, else answer false."
     ^(self containsPoint: aRectangle origin)
         and: [self containsPoint: aRectangle corner]!
 containsPoint: aPoint
         "Answer true if aPoint is contained within the receiver,
          else answer false."
     ^(origin <= aPoint) and: [aPoint <= corner]!
 corner
         "Answer the Point at the bottom right corner of
          the receiver."
     ^corner!
 corner: aPoint
         "Answer the receiver. Change the receiver so
          that its bottom right corner is aPoint without
          changing its extent."
     self moveBy: aPoint - corner!
 draw
         "Draw a blinking rectangle representing
          the receiver on the Display."
     | byteBlt form |
     byteBlt := ByteBlt displayByteBlt.
     form := InfiniteForm new
         attribute: Form blink.
     byteBlt
         sourceForm: form;
         width: 1;
         height: 1;
         combinationRule: Form under.
     form character: 16rDA asCharacter.
     byteBlt
         destOrigin: origin;
         copyBytes.
     form character: 16rBF asCharacter.
     byteBlt
         destOrigin: self topRight;
         copyBytes.
     form character: 16rD9 asCharacter.
     byteBlt
         destOrigin: corner;
         copyBytes.
     form character: 16rC0 asCharacter.
     byteBlt
         destOrigin: self bottomLeft;
         copyBytes.
     form character: 16rB3 asCharacter.
     byteBlt
         destRect: (origin + (0 @ 1)
             extent: 1 @ (self height - 2));
         copyBytes;
         destX: self right;
         copyBytes.
     form character: 16rC4 asCharacter.
     byteBlt
         destRect: (origin + (1 @ 0)
             extent: self width - 2 @ 1);
         copyBytes;
         destY: self bottom;
         copyBytes!
 expandBy: delta
         "Answer a Rectangle which is the receiver outset
          by delta, where delta is a Rectangle, a Point or
          a Number."
     delta class == Rectangle
         ifTrue: [
             ^origin - delta origin
                 corner: corner + delta corner]
         ifFalse: [
             ^origin - delta
                 corner: corner + delta]!
 extent
         "Answer a Point representing the
          receiver width and height."
     ^self width @ self height!
 extent: aPoint
         "Answer the receiver.  Change the extent
          of receiver to aPoint."
     self width: aPoint x.
     self height: aPoint y!
 height
         "Answer a number representing the receiver height."
     ^corner y - origin y + 1!
 height: aNumber
         "Answer the receiver.  Set the
          receiver height to aNumber."
     corner y: origin y + aNumber - 1!
 insetBy: delta
         "Answer a Rectangle which is the receiver
          inset by delta, where delta is a Rectangle,
          a Point or a Number."
     delta class == Rectangle
         ifTrue: [
             ^origin + delta origin
                 corner: corner - delta corner]
         ifFalse: [
             ^origin + delta
                 corner: corner - delta]!
 insetOriginBy: firstPoint cornerBy: secondPoint
         "Answer a Rectangle which is the receiver
          inset by firstPoint at the origin
          and secondPoint at the corner."
     ^origin + firstPoint
         corner: corner - secondPoint!
 intersect: aRectangle
         "Answer a Rectangle representing the area in
          which the receiver and aRectangle overlap."
     ^(origin max: aRectangle origin)
         corner: (corner min: aRectangle corner)!
 intersects: aRectangle
         "Answer true if the receiver and aRectangle have
          any area in common, else answer false."
     ^origin <= aRectangle corner
         and: [aRectangle origin <= corner]!
 left
         "Answer the Number representing the x-coordinate of
          the receiver left vertical line."
     ^origin x!
 leftCenter
         "Answer the Point at the center of the receiver's
          left vertical line."
     ^origin x @ ((corner y + origin y) // 2)!
 merge: aRectangle
         "Answer the smallest Rectangle which contains the
          receiver and aRectangle."
     ^(origin min: aRectangle origin)
         corner: (corner max: aRectangle corner)!
 moveBy: aPoint
         "Answer the receiver.  Increment the receiver
          origin and corner by aPoint."
     origin := origin + aPoint.
     corner := corner + aPoint!
 origin
         "Answer a Point representing the
          top left corner of the receiver."
     ^origin!
 origin: aPoint
         "Answer the receiver.  Change the receiver
          so that its top left corner is aPoint,
          without changing its extent."
     self moveBy: aPoint - origin!
 origin: originPoint corner: cornerPoint
         "Answer the receiver.  Change its top left corner to
          originPoint and its bottom right corner to cornerPoint."
     origin := originPoint.
     corner := cornerPoint!
 origin: originPoint extent: extentPoint
         "Answer the receiver.  Change the receiver's top left
          corner to originPoint and its extent to extentPoint."
     self
         origin: originPoint
         corner: originPoint + extentPoint - (1@1)!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     origin printOn: aStream.
     aStream nextPutAll: ' corner: '.
     corner printOn: aStream!
 right
         "Answer the Number representing the x-coordinate of
          the receiver's right vertical line."
     ^corner x!
 rightCenter
         "Answer the Point at the center of the receiver's
          right vertical line."
     ^corner x @ ((corner y + origin y) // 2)!
 rounded
         "Answer a Rectangle with the receiver's origin and
          corner points rounded to integers."
     ^origin rounded corner: corner rounded!
 scaleBy: anInteger
         "Answer a Rectangle with the receiver's origin
          and corner points multiplied by anInteger."
     ^origin * anInteger corner: corner * anInteger!
 top
         "Answer the y-coordinate of the top of the receiver."
     ^origin y!
 topCenter
         "Answer the Point at the top center of the receiver."
     ^((corner x + origin x) // 2) @ origin y!
 topLeft
         "Answer the Point at the top left corner of the receiver."
     ^origin!
 topRight
         "Answer the Point at the top right corner of the receiver."
     ^corner x @ origin y!
 translateBy: delta
         "Answer a Rectangle which is the receiver with position
          incremented by delta, either a Number or a Point."
     ^origin + delta corner: corner + delta!
 width
         "Answer a number representing the receiver width."
     ^corner x - origin x + 1!
 width: anInteger
         "Answer the receiver.  Set the
          receiver width to anInteger."
     corner x: origin x + anInteger - 1! !

! Stream class methods !
 on: anIndexedCollection
         "Answer a new instance of the
          receiver on anIndexedCollection."
     ^(self new)
         setCollection: anIndexedCollection;
         setLimits!
 on: anIndexedCollection from: firstIndex to: lastIndex
         "Answer a new instance of the receiver on part
          of anIndexedCollection (those elements from
          index positions firstIndex through lastIndex)."
     ^self on:
         (anIndexedCollection
             copyFrom: firstIndex
             to: lastIndex)! !

! Stream methods !
 atEnd
         "Answer true if the receiver is positioned at the
          end (beyond the last object), else answer false."
     <primitive: 67>
     ^readLimit <= self position!
 close
         "Provided for compatibility with FileStreams.
          Default is do nothing."!
 contents
         "Answer the collection over which the receiver is
          streaming."
     ^self implementedBySubclass!
 copyFrom: firstIndex to: lastIndex
         "Answer the subcollection of the collection over
          which the receiver is streaming, from firstIndex
          to lastIndex."
     ^collection copyFrom: firstIndex to: lastIndex.!
 countBlanks
         "Skip over blank and tab characters.  Answer the
          number of character positions skipped, counting
          1 for blanks and 4 for tabs."
     | count char |
     count := 0.
     [self atEnd]
         whileFalse: [
             char := self next.
             char == $ 
                 ifTrue: [count := count + 1]
                 ifFalse: [
                     char == Tab
                         ifTrue: [count := count + 4]
                         ifFalse: [
                             self position: self position - 1.
                             ^count]]].
     ^count!
 do: aBlock
         "Evaluate aBlock once for each element in the
          receiver, from the current position to the end."
     [self atEnd]
         whileFalse: [aBlock value: self next]!
 fileIn
         "Read and execute the Smalltalk source code chunks
          from the receiver.  If a chunk starts with !! send
          it the message fileInFrom: self"
     | string toBeFiledIn |
     self reset.
     [self atEnd or: [self peek > $  ]]
         whileFalse: [self next].
     [self atEnd]
         whileFalse: [
             toBeFiledIn := self peekFor: $!!.
             string := self nextChunk.
             toBeFiledIn
                 ifTrue: [(Compiler evaluate: string) fileInFrom: self]
                 ifFalse:[Compiler evaluate: string]]!
 isEmpty
         "Answer true if the receiver stream contains no
          elements, else answer false."
     ^self size == 0!
 lineDelimiter
         "Answer the default line delimiter, line-feed."
     ^Lf!
 lineDelimiter: aCharacter
         "Change the line delimiter character to aCharacter.
          The Stream implementation is default, so the change
          request is ignored."!
 next: anInteger
         "Answer the next anInteger items from the receiver,
          returned in a collection of the same species as
          the collection being streamed over."
     |aStream|
     aStream := WriteStream on:
         (collection species new: anInteger).
     anInteger timesRepeat: [
         aStream nextPut: self next].
     ^aStream contents!
 next: anInteger put: anObject
         "Answer anObject.  Put anObject to the receiver stream
          anInteger number of times."
     anInteger timesRepeat: [
         self nextPut: anObject].
     ^anObject!
 nextChunk
         "Answer a String up to '!!', undoubling embedded !!'s.
          Trailing white space is skipped.  The methods in
          sources.sml and change.log are in chunk format."
     | answer |
     answer := self upTo: $!! .       "assumes !!'s are rare"
     [self atEnd or: [(self peekFor: $!!) not ]]
         whileFalse: [
             answer := answer,
                 (String with: $!!),
                 (self upTo: $!!)].
     [self atEnd
         or: [self peek asciiValue between: 33 and: 126]]
             whileFalse: [self next].
     ^answer!
 nextChunkPut: aString
         "Output aString terminated with '!!', doubling
          embedded !!'s and replacing groups of leading
          blanks with tabs.  Destination is receiver
          stream.  The methods in sources.sml and
          change.log are in chunk format."
     aString isEmpty
         ifTrue: [self space]
         ifFalse:[self cr].
     aString do: [ :character |
         self nextPut: character.
         character == $!!
             ifTrue: [self nextPut: $!!]].
     self nextPut: $!!.
     ^aString!
 nextLine
         "Answer a String consisting of the characters of
          the receiver up to the next line delimiter."
     ^self upTo: Lf!
 nextMatchFor: anObject
         "Access the next object in the receiver.  Answer
          true if it equals anObject, else answer false."
     ^(self next) = anObject!
 nextPiece
         "File sources.sml consists of compressed sequences
          of characters called pieces.  Answer a String containing
          the next piece of text to be compressed from the
          receiver stream."
     | first char |
     self atEnd
         ifTrue: [^nil].
      (char := self next) == Lf
         ifTrue: [^String with: Lf].
     char > 127 asCharacter
         ifTrue: [^String with: 128 asCharacter with: char].
     first := self position.
     char isLetter
         ifTrue: [
             [self atEnd
                 ifTrue: [^self copyFrom: first to: self position].
              ((char := self next) isLowerCase)]
                 whileTrue: []]    "skip over letters"
         ifFalse: [
             char isDigit
                 ifTrue: [
                     [self atEnd
                         ifTrue: [^self copyFrom: first to: self position].
                      (char := self next) isDigit]
                         whileTrue: []]   "skip digits"
                 ifFalse: [
                     [self atEnd
                         ifTrue: [^self copyFrom: first to: self position].
                      (char := self next) isAlphaNumeric or: [char == Lf
                         or: [char > 127 asCharacter]]]
                         whileFalse: []]].   "skip over whats between words"
     self position: self position - 1.
     ^self copyFrom: first to: self position!
 nextWord
         "Answer a String containing the next word in the
          receiver stream.  A word starts with a letter,
          followed by a sequence of letters and digits."
     | first |
     [self atEnd ifTrue: [^nil].
      self next isLetter]
         whileFalse: [].  "skip separators"
     first := self position.
     [self atEnd
         ifTrue: [^self copyFrom: first to: self position].
      self next isAlphaNumeric]
         whileTrue: [].
     ^self copyFrom: first to: self position - 1!
 peek
         "Answer the next object in the receiver stream
          without advancing the stream position.  If the
          stream is positioned at the end, answer nil."
     |anObject|
     self atEnd
         ifTrue: [^nil]
         ifFalse: [
             anObject := self next.
             self position: self position - 1.
             ^anObject]!
 peekFor: anObject
         "Answer true if the next object to be accessed in
          the receiver stream equals anObject, else answer
          false.  Only advance the stream position if the
          answer is true."
     self atEnd
         ifTrue: [^false]
         ifFalse: [
             anObject = self next
                 ifTrue: [^true]
                 ifFalse:[
                     self position: self position - 1.
                     ^false]].!
 position
         "Answer the current receiver stream position."
     ^position!
 position: anInteger
         "Set the receiver stream position to anInteger.
          Report an error if anInteger is outside the
          bounds of the receiver collection."
     (0 <= anInteger and: [anInteger <= readLimit])
         ifFalse: [^self error: 'position outside of stream'].
     position := anInteger!
 readLimit
         "Private - Answer the size of the receiver collection."
     ^readLimit!
 reset
         "Position the receiver stream to the beginning."
     self position: 0!
 reverseContents
         "Answer a collection of the same species as the
          receiver collection, with the contents in
          reverse order."
     |aStream savePosition|
     aStream := WriteStream on:
         (collection species new: self readLimit).
     savePosition := self position.
     self readLimit - 1 to: 0 by: -1 do: [ :i |
         self position: i.
         aStream nextPut: self next].
     self position: savePosition.
     ^aStream contents!
 setCollection: aCollection
         "Private - Set the receiver stream collection
          to aCollection."
     collection := aCollection.!
 setToEnd
         "Set the position of the receiver stream to
          the end."
     self position: self readLimit!
 show: aCollection
         "Equivalent to nextPutAll: for streams.  For text
          editor windows, causes immediate display on screen."
     ^self nextPutAll: aCollection!
 size
         "Answer the size of (number of objects in) the
          receiver stream."
     ^self readLimit!
 skip: anInteger
         "Increment the position of the receiver by anInteger."
     | newPosition |
     self position:
         ((self position + anInteger
             min: self readLimit) max: 0)!
 skipTo: anObject
         "Advance the receiver position to beyond the next
          occurence of anObject, or if none, to the end of
          stream.  Answer true if anObject occurred, else
          answer false."
     [self atEnd]
         whileFalse: [
             self next = anObject
                 ifTrue: [^true]].
     ^false!
 upTo: anObject
         "Answer the collection of objects from the receiver
          starting with the next accessible object and up to
          but not including anObject.  Set the position beyond
          anObject.  If anObject is not present, answer the
          remaining elements of the stream."
     <primitive: 82>
     ^self
         copyFrom: self position + 1
         to: ((self skipTo: anObject)
                 ifTrue: [self position - 1]
                 ifFalse: [self position])! !

! ReadStream class methods ! !

! ReadStream methods !
 contents
         "Answer the collection over which the receiver is
          streaming."
     ^collection copyFrom: 1 to: readLimit!
 next
         "Answer the next object accessible by the receiver
          and advance the stream position.  Report an error
          if the receiver stream is positioned at end."
     <primitive: 65>
     position < readLimit
         ifTrue: [
             position := position + 1.
             ^collection at: position]
         ifFalse: [
             ^self error: 'read beyond end of stream']!
 setLimits
         "Private - Initialize the stream size and position."
     position := 0.
     readLimit := collection size! !

! WriteStream class methods !
 with: aCollection
         "Answer an instance of the receiver streaming on
          aCollection and positioned to the end."
     ^(self on: aCollection) setToEnd!
 with: aCollection from: firstIndex to: lastIndex
         "Answer an instance of the receiver streaming on
          the subcollection of aCollection from firstIndex
          to lastIndex and positioned to the end."
     ^(self on: aCollection from: firstIndex to: lastIndex)
         setToEnd! !

! WriteStream methods !
 contents
         "Answer the collection over which the receiver is
          streaming."
     ^self copyFrom: 1 to: self position!
 cr
         "Write the line terminating character (line-feed)
          to the receiver stream."
     self nextPut: Lf!
 crTab
         "Write the line terminating character and a tab
          to the receiver stream."
     self
         cr;
         nextPut: Tab!
 crTab: anInteger
         "Write the line terminating character and anInteger
          number of tabs to the receiver stream."
     self
         cr;
         next: anInteger put: Tab!
 nextBytePut: aByte
         "Write the character whose ASCII value is aByte
          to the receiver stream.  Answer aByte."
     self nextPut: aByte asCharacter.
     ^aByte!
 nextPut: anObject
         "Write anObject to the receiver stream.
          Answer anObject."
     | index |
     <primitive: 66>
     index := position + 1.
     index > writeLimit
         ifTrue: [
             collection grow.
             writeLimit := collection size].
     position := index.
     collection at: index put: anObject.
     ^anObject!
 nextPutAll: aCollection
         "Write each of the objects in aCollection to the
          receiver stream.  Answer aCollection."
     | stopIndex |
     stopIndex := position + aCollection size.
     stopIndex <= writeLimit
         ifTrue: [
             collection
                 replaceFrom: position + 1
                 to: stopIndex
                 with: aCollection
                 startingAt: 1.
             position := stopIndex.
             ^aCollection].
     ^aCollection do: [ :element |
         self nextPut: element]!
 nextTwoBytesPut: anInteger
         "Write anInteger as the next two bytes of the
          receiver stream."
     self
         nextBytePut: (anInteger bitAnd: 255);
         nextBytePut: ((anInteger bitShift: -8) bitAnd: 255)!
 setLimits
         "Private - Initialize the receiver's size and position."
     readLimit := position := 0.
     writeLimit := collection size!
 space
         "Write a space character to the receiver stream."
     self nextPut: Space!
 tab
         "Write a tab character to the receiver stream."
     self nextPut: Tab! !

! ReadWriteStream class methods ! !

! ReadWriteStream methods !
 contents
         "Answer the collection over which the receiver is
          streaming."
     ^self copyFrom: 1 to: self readLimit!
 next
         "Answer the next object accessible by the receiver
          and advance the stream position.  Report an error
          if the receiver stream is positioned at end."
     | index |
     <primitive: 65>
     self atEnd
         ifTrue: [
             ^self error: 'read beyond end of stream']
         ifFalse: [
             index := self position + 1.
             self position: index.
             ^collection at: index]!
 nextPut: anObject
         "Write anObject to the receiver stream.
          Answer anObject."
     readLimit := self position + 1 max: readLimit.
     ^super nextPut: anObject!
 nextPutAll: aCollection
         "Write each of the objects in aCollection
          to the receiver stream.  Answer aCollection."
     super nextPutAll: aCollection.
     readLimit < position
         ifTrue: [readLimit := position].
     ^aCollection!
 setLimits
         "Private - Initialize the receiver's size and position."
     position := 0.
     readLimit := writeLimit := collection size!
 truncate
         "Set the size of the receiver stream to its
          current position."
     readLimit:=  writeLimit:= position! !

! FileStream class methods !
 on: aFile from: firstIndex to: lastIndex
         "Answer a kind of Stream on a copy of the
          portion of aFile.  Report an error since
          the operation is not supported for files."
     ^self invalidMessage! !

! FileStream methods !
 atEnd
         "Answer true if the receiver is positioned at the
          end (beyond the last object), else answer false."
     (position < readLimit or:
         [(pageStart + position) <= self updateLastByte])
             ifTrue: [^false]
             ifFalse:[^true]!
 close
         "Close the file associated with the receiver stream
          after writing all the data to the file."
     self readLimit.
     self writePage.
     file close!
 copyFrom: first to: last
         "Answer a String containing the characters of the
          receiver stream from positions first to last."
     | string savePosition index putIndex number |
     string := collection species new: last - first + 1.
     savePosition := self position.
     putIndex := 1.
     index := first.
     [index <= last]
         whileTrue: [
             self position: index - 1.
             number := (last min: pageStart + readLimit - 1)
                 - index + 1.
             string
                 replaceFrom: putIndex
                 to: putIndex + number - 1
                 with: collection
                 startingAt: position + 1.
             putIndex := putIndex + number.
             index := index + number].
     self position: savePosition.
     ^string!
 cr
         "Write the line terminating character
          (carriage-return line-feed pair or
          line-feed) to the receiver stream."
     self lineDelimiter == Cr
         ifTrue: [self nextPut: Cr].
     self nextPut: Lf!
 file
         "Answer the file over which the receiver is
          streaming."
     ^file!
 flush
         "Guarantee that any writes to the receiver stream
          are physically recorded on disk."
     self
         setToEnd;
         readLimit;
         writePage.
     file flush!
 lineDelimiter
         "Answer the line delimiter character for the
          receiver file stream, either carriage-return
          or line-feed."
     ^lineDelimiter!
 lineDelimiter: aCharacter
         "Change the line delimiter character to aCharacter."
     lineDelimiter := aCharacter!
 next
         "Answer the next character accessible by the receiver
          and advance the stream position.  Report an error
          if the receiver stream is positioned at end."
     <primitive: 65>
     self position: self position.
     self atEnd
         ifTrue: [
             ^self error: 'read beyond end of stream']
         ifFalse: [
             (position := position + 1) > readLimit
                 ifTrue: [self error: 'stream fell off end'].
             ^collection at: position]!
 nextLine
         "Answer a String consisting of the characters of
          the receiver up to the next line delimiter."
     | line |
     line := self upTo: lineDelimiter.
     lineDelimiter == Cr
         ifTrue: [self peekFor: Lf].
     ^line!
 nextPut: aCharacter
         "Write aCharacter to the receiver stream."
     writtenOn := true.
     ^self primitiveNextPut: aCharacter!
 nextPutAll: aCollection
         "Write each of the chararacters in
          aCollection to the receiver stream."
     | currentPosition stopIndex |
     stopIndex := position + aCollection size.
     stopIndex <= writeLimit
         ifTrue: [
             collection
                 replaceFrom: position + 1
                 to: stopIndex
                 with: aCollection
                 startingAt: 1.
             position := stopIndex.
             writtenOn := true.
             ^aCollection].
     ^aCollection do: [ :element |
         self nextPut: element]!
 pathName
         "Answer the complete pathname of the file
          over which the receiver is streaming."
 
     | path |
     path := file directory pathName.
     path = '\'
         ifTrue: [path := ''].
     ^(String with: file directory drive), ':',
         path, '\', file name!
 position
         "Answer the current receiver stream position."
     ^pageStart + position - 1.!
 position: anInteger
         "Set the receiver stream position to anInteger."
     self readLimit.
     ((anInteger + 1) < pageStart
         or: [(pageStart + File pageSize) <= (anInteger + 1)])
             ifTrue: [
                 self writePage.
                 pageStart := ((anInteger // File pageSize)
                     * File pageSize) + 1.
                 readLimit := file
                     readBuffer: collection
                     atPosition: pageStart].
     position := anInteger - pageStart + 1.
     self updateLastByte!
 primitiveNextPut: aCharacter
         "Private - Write aCharacter to the receiver stream.
          Answer aCharacter."
     <primitive: 66>
     self position: self position.
     position := position + 1.
     writtenOn := true.
     collection at: position put: aCharacter.
     ^aCharacter!
 readLimit
         "Private - Answer the size of the receiver file."
     readLimit := readLimit max: position.
     ^self updateLastByte!
 setLimits
         "Private - Initialize the stream size and position."
     file := collection.
     collection := String new: File pageSize.
     writeLimit := collection size.
     readLimit := file
         readBuffer: collection
         atPosition: 1.
     position := 0.
     pageStart := 1.
     writtenOn := false.
     lastByte := file size.
     lineDelimiter := Cr.
     2 to: readLimit do: [ :i |
         (collection at: i) == Lf
             ifTrue: [
                 (collection at: i - 1) == Cr
                     ifFalse: [lineDelimiter := Lf].
                 ^self]]!
 updateLastByte
         "Private - Answer the position of the last byte in
          the file, and update the instance variable."
     ^lastByte :=
         lastByte max: position + pageStart - 1!
 writePage
         "Private - Write the current page to the file,
          if it has changed."
     writtenOn
         ifTrue: [
             file
                 writeBuffer: collection
                 ofSize: readLimit
                 atPosition: pageStart.
             writtenOn := false]! !

! TerminalStream class methods ! !

! TerminalStream methods !
 beginMenu
         "Private - Answer PaneMenuRequest defined in the
          FunctionKeys dictionary and reset the state
          back to initialState if the right mouse button is quickly
          released.  If there is no movement before the release
          of the mouse button and the delay is greater than that
          defined by the method delay, answer ScrollDownFunction
          and reset the state to initialState.  If the cursor does
          move, answer SetLoc and change the state to beginScroll."
     | char |
     MouseEvent := true.
     char := self readPrimitive.
     char == SetLoc
         ifTrue: [
             state := #beginScroll.
             self setLoc.
             Cursor setOffset: mouseOffset.
             ^SetLoc].
     char == MouseButton
         ifTrue: [
             char := self readPrimitive.
             char = 2 "right button up"
                 ifTrue: [
                     state := #initialState.
                     (Time mouseClockValue - mouseTime) <= self delay
                         ifTrue: [^PaneMenuRequest]
                         ifFalse: [^ScrollDownFunction]]].
     self bell.
     ^EndSelectFunction!
 beginScroll
         "Private - Answer ScrollUpFunction defined in the
          FunctionKeys dictionary and change the state to
          startScrollUp."
     state := #startScrollUp.
     ^ScrollUpFunction!
 beginSelect
         "Private - Answer SetLoc for draw-through and change the
          state to extendSelect, else answer EndSelectFunction
          and restore the state to initialState if the left mouse
          button is released .  Draw-through is detected when
          there is cursor movement before releasing the left mouse
          button or if the button has been kept pressed for a delay
          greater than the delay defined by the method delay."
     | char |
     MouseEvent := true.
     [Cursor isThereInput]
         whileFalse: [
             (Time mouseClockValue - mouseTime) > self delay
                 ifTrue: [
                     state := #extendSelect.
                     ^SetLoc]].
     char := self readPrimitive.
     char == SetLoc
         ifTrue: [
             state := #extendSelect.
             ^self setLoc].
     char == MouseButton
         ifTrue: [
             char := self readPrimitive.
             char = 1 "left button up"
                 ifTrue: [
                     state := #initialState.
                     ^EndSelectFunction]]. "no op"
     self bell.
     ^EndSelectFunction!
 bell
         "Output the Bell character to the terminal."
     self write: Bell!
 continueScroll
         "Private - Answer SetLoc if the right button is
          still down, else answer scrollDownFunction
          and restore the state to initialState."
     | char |
     MouseEvent := true.
     char := self readPrimitive.
     char == SetLoc
         ifTrue: [^self setLoc].
     char == MouseButton
         ifTrue: [
             char := self readPrimitive.
             char = 2 "right button up"
                 ifTrue: [
                     state := #initialState.
                     ^ScrollDownFunction]]. "no op"
     self bell.
     ^EndSelectFunction!
 delay
         "Private - Answer the milliseconds defining the
          amount of time a mouse button has to stay pressed
          before it can change its function."
     ^30!
 extendSelect
         "Private - Answer SetLoc if draw-through is still
          in progress (mouse is in motion),  else answer
          EndSelectFunction and restore the state to initialState
          if the left button is released."
     | char |
     MouseEvent := true.
     char := self readPrimitive.
     (char == SetLoc)
         ifTrue: [^self setLoc].
     char == MouseButton
         ifTrue: [
             char := self readPrimitive.
             char = 1 "left button up"
                 ifTrue: [
                     state := #initialState.
                     ^EndSelectFunction]]. "no op"
     self bell.
     ^EndSelectFunction!
 initialize
         "Initialize the global variables FunctionKey
          and MouseEvent to false and the state of the
          input mechanism to initialState."
     FunctionKey := false.
     MouseEvent := false.
     state := #initialState!
 initialState
         "Private - Answer a character representing user
          input from keyboard or mouse.  This method
          represents the initial state for the user input
          finite state machine."
     | char button value |
     char := self readPrimitive.
     FunctionKey := false.
     MouseEvent := true.
     (char == SetLoc)
         ifTrue: [^self setLoc].
     char == MouseButton
         ifTrue: [
             char := self readPrimitive.
             button := char bitAnd: 16r103.
             button = 16r101 "left button down"
                 ifTrue: [^self leftButton: char].
             button = 16r102 "right button down"
                 ifTrue: [^self rightButton: char].
             button = 16r103 "middle button down"
                 ifTrue: [^self bell].
             ^SetLoc].
     MouseEvent := false.
     char == FunctionPrefix
         ifTrue: [
             FunctionKey := true.
             char := self readPrimitive.
                 "if shifted window menu request or pane menu
                  menu request, return unshifted form"
             char asciiValue = 138
                 ifTrue: [^82 asCharacter].
             char asciiValue = 136
                 ifTrue: [^83 asCharacter]].
     ^char!
 leftButton: char
         "Private - Answer SelectFunction when the left mouse
          button is pressed without the shift key down,
          else answer SelectToFunction.  This method changes
          the state to beginSelect and records the time when the
          left button is pressed (for the delay mechanism)."
     state := #beginSelect.
     char = 16r101 "left button down"
         ifTrue: [
             mouseTime := Time mouseClockValue.
             ^SelectFunction].
     "shift key must be down 16r1101"
     ^SelectToFunction!
 mouseOffset
         "Answer the cursor position where the
          right mouse button was pressed."
     ^mouseOffset!
 mouseSelectOn
         "Answer true if the finite state mechanism is in
          the selecting states (beginSelect or extendSelect),
          else answer false."
     ^state == #beginSelect
         or: [state == #extendSelect]!
 next
         "Answer the next character from
          the terminal (keyboard or mouse)."
     ^self read!
 nextPut: aChar
         "Answer the argument aChar.  Output
          aChar to the display screen."
     self write: aChar.
     aChar == Lf
         ifTrue: [self write: Cr].
     ^aChar!
 nextPutAll: aString
         "Answer the argument aString.  Output
          aString to the display screen."
     aString do: [ :character |
         self nextPut: character].
     ^aString!
 read
         "Peform the current state of the input mechanism."
     ^self perform: state!
 readPrimitive
         "Private - Answer the next character from
          the terminal keyboard or mouse."
     <primitive: 57>
     ^self primitiveFailed!
 rightButton: char
         "Private - Answer SetLoc when the right mouse button
          is pressed without the shift key down,  else
          answer PageUpFunction.  This method changes the state
          to beginMenu and records the time when the right
          button is pressed (for the delay mechanism)."
     state := #beginMenu.
     char = 16r102
         ifTrue: [
             mouseOffset := Cursor offset.
             mouseTime := Time mouseClockValue.
             ^SetLoc].
     "shift key must be down 16r1102"
     ^PageUpFunction!
 setLoc
         "Private - Answer pool variable SetLoc.  Update
          the global variable Cursor with the x and y
          coordinates from the read primitive."
     Cursor setOffset:
         self readPrimitive @
         self readPrimitive.
     ^SetLoc!
 startScrollUp
         "Private - Answer SetLoc and change the
          state to continueScroll."
     state := #continueScroll.
     Cursor setOffset: Cursor sense.
     ^SetLoc!
 write: aChar
         "Output aChar to the terminal."
     <primitive: 58>
     ^self primitiveFailed! !

! StringModel class methods !
 for: aString
         "Answer a new instance of class StringModel
          containing an OrderedCollection of strings
          created from aString by separating it at
          the line-feed characters."
     ^self new string: aString.! !

! StringModel methods !
 addLine: aString
         "Append the line aString to the end of the
          text and inform the text pane of the change."
     lines add: aString.
     extent := self extent.
     lastChild update: (0@lines size corner: extent)!
 adjustPoint: aPoint
         "Private - If the y-coordinate of aPoint is less
          than one, answer a Point describing the position
          of the first character.  If the x-coordinate is
          less than one, answer a Point describing the
          position of the last character in the line
          preceding the y-coordinate."
     | x y |
     aPoint > (0@0)
         ifTrue: [^aPoint].
     x := aPoint x.  y := aPoint y.
     x < 1 ifTrue: [y := y - 1].
     y < 1 ifTrue: [^1 @ 1].
     x < 1 ifTrue: [
         y <= lines size
             ifTrue: [x := (lines at: y) size + 1]
             ifFalse:[x := 1]].
     ^x @ y!
 appendChar: aCharacter
         "Append aCharacter to the end of the last
          line and inform the text pane to update."
     | origin |
     origin := (extent x + 1) @ extent y.
     aCharacter == Lf
         ifTrue: [lines add: String new]
         ifFalse:[
     aCharacter == Tab
         ifTrue: [lines last become: lines last, (self tabStringAt: origin x)]
     ifFalse: [
         lines last become: (lines last copyWith: aCharacter)]].
     extent := self extent.
     lastChild update: (origin corner: extent)!
 appendText: aString
         "Append aString to the end of the last line
          and inform the text pane to update."
     | origin newLine |
     origin := (extent x + 1) @ extent y.
     newLine := lines last.
     newLine become: newLine, aString.
     extent x: newLine size.
     lastChild update: (origin corner: extent)!
 backspacePoint: aPoint
         "Answer a Point describing the position
          of the character preceding aPoint."
     ^self adjustPoint: aPoint - (1 @ 0).!
 broadcastChangesIn: selection
     upTo: replacementEnd
     withExcess: excess
 
         "Private - Inform the text pane to update the changed
          area (as a Rectangle) whose corner is the maximum
          of the selection corner and the sum of replacementEnd
          and excess."
     | origin corner newExtent |
     origin := selection origin.
     corner := selection corner.
     corner = replacementEnd
         ifFalse: [
             (self is: replacementEnd before: corner)
                 ifTrue: [
                     corner := corner x + excess @ corner y]
                 ifFalse:[
                     corner := replacementEnd x + excess @
                         replacementEnd y]].
     (newExtent := self extent) = extent
         ifFalse: [
             (self is: newExtent before: extent)
                 ifTrue: [corner := extent]
                 ifFalse:[corner := newExtent].
             extent := newExtent].
     lastChild update: (origin corner: corner)!
 convertToString: aCollection
         "Private - Answer a String containing the
          concatenation of aCollection of lines."
     | tally index result line i |
     tally := 0.
     1 to: aCollection size do: [ :index |
         line := aCollection at: index.
         (line isEmpty or: [line last ~= $ ])
             ifFalse: [
                 i := line size - 1.
                 [i > 0 and: [(line at: i) == $ ]]
                     whileTrue: [i := i - 1].
                 (i > 0 and: [(line at: i) == $$])
                     ifTrue: [i := i + 1].
                 line := line copyFrom: 1 to: i.
                 aCollection at: index put: line].
         tally := tally + line size + 1].
     result := String new: tally.
     index := 1.
     aCollection do: [ :line |
         result
             replaceFrom: index
             to: index + line size - 1
             with: line.
         index := index + line size + 1.
         result at: index - 1 put: Lf].
     ^result!
 delete: selection
         "Delete the part of the text contained in
          the selection.  Answer a Point describing the
          character position before the deletion."
     | line point excess |
     point := selection origin.
     (point == selection corner
         and: [(lines at: point y) size >= point x])
             ifTrue: [^self deleteCharIn: selection].
     line := self rightPartAfter: selection corner.
     excess := line size.
     line := (self leftPartBefore: point), line.
     point := point - (1@0).
     self
         replaceLinesIn: selection with: line;
         broadcastChangesIn: selection
             upTo: point
             withExcess: excess.
     ^point!
 deleteCharIn: selection
         "Delete the first character in the selection.
          Answer a Point describing the character
          position before the deletion."
     | line point |
     point := selection origin.
     line := lines at: point y.
     lines at: point y put:
         (line
             copyReplaceFrom: point x
             to: point x
             with: '').
     point := point - (1@0).
     self
         broadcastChangesIn: selection
         upTo: point
         withExcess: line size - point x.
     ^point!
 display: aRectangle at: aPoint on: paneScanner
         "Transfer the text contained in aRectangle
          to aPoint on the TextPane by the
          paneScanner (a StringBlt)."
     | sourceY destY lastY |
     sourceY := aRectangle origin y.
     lastY := aRectangle corner y min: lines size.
     paneScanner sourceX: aRectangle origin x - 1.
     destY := aPoint y.
     sourceY to: lastY do: [ :i |
         paneScanner
             moveString: (lines at: i)
             toX: aPoint x
             andY: destY + i - sourceY ]!
 extendTo: aPoint
         "Private - If needed, extend lines
          to aPoint by adding empty strings."
     | lineIndex |
     lineIndex := aPoint y.
     [lineIndex > lines size]
         whileTrue: [lines add: (String new: 0)]!
 extent
         "Answer a Point describing the position
          of the last charcter in the text."
     lines size <= 0
         ifTrue: [^0 @ 1]
         ifFalse:[^lines last size @ (lines size)]!
 fileInFrom: aStream
         "Replace all the receiver lines
          with the contents of aStream."
     lines := OrderedCollection new.
     [aStream atEnd]
         whileFalse: [lines add: aStream nextLine].
     extent := self extent!
 fileOutOn: aStream
         "Write the receiver contents to aStream
          appending a line delimiter to each line."
     lines do: [ :line | aStream nextPutAll: line; cr]!
 is: firstPoint before: secondPoint
         "Private - Answer true if firstPoint is earlier
          (text wise) than secondPoint."
     ^firstPoint y < secondPoint y
         or: [ firstPoint y = secondPoint y
             and: [firstPoint x < secondPoint x]]!
 leftPartBefore: aPoint
         "Private - Answer the substring prior
          to aPoint on that point's line."
     | line position |
     position := aPoint x - 1.
     aPoint y > lines size
         ifTrue: [
             ^(String new: position) atAllPut: Space].
     line := lines at: aPoint y.
     position <= line size
         ifTrue: [
             ^line copyFrom: 1 to: (0 max: position)]
         ifFalse: [
             ^line,
                 ((String new: position - line size)
                     atAllPut: Space)]!
 linesIn: selection
         "Answer an OrderedCollection of
          the lines contained in selection."
     | someLines origin corner |
     origin := selection origin.
     corner := selection corner.
     someLines := OrderedCollection new.
     someLines add:
         (self rightPartAfter: origin - (1 @ 0)).
     (corner y - origin y) > 1
         ifTrue: [
             someLines addAll:
                 (lines
                     copyFrom: origin y + 1
                     to: corner y - 1)].
     someLines add:
         (self leftPartBefore: corner + (1 @ 0)).
     ^someLines!
 replace: selection withChar: aCharacter
         "Replace the text in selection with aCharacter.
          Answer a Point describing the position of the new
          character.  Inform the text pane of the change."
     | origin corner line excess |
     aCharacter == Lf
         ifTrue: [^self replaceWithLf: selection].
     aCharacter == Tab
         ifTrue: [^self replaceWithTab: selection].
     origin := selection origin.
     corner := selection corner.
     self extendTo: corner.
     (self is: corner before: origin)
         ifTrue: [
             excess := self
                 replaceGapBefore: origin
                 withChar: aCharacter]
         ifFalse: [
             line := self rightPartAfter: corner.
             excess := line size.
             line := (self leftPartBefore: origin)
                  , (String with: aCharacter)
                  , line.
             self replaceLinesIn: selection with: line].
     self
         broadcastChangesIn: selection
         upTo: origin
         withExcess: excess.
     ^origin!
 replace: selection withText: aString
         "Replace the text in selection with aString.
          Answer a Point describing the position of the last
          replacement character.  Inform the text pane
          of the change."
     | newLines line endOfReplacement stream noneYet excess |
     self extendTo: selection corner.
     (aString isNil or: [aString isEmpty])
         ifTrue: [^self delete: selection].
     newLines := OrderedCollection new.
     noneYet := true.
     stream := ReadStream on: aString.
     [stream atEnd]
         whileFalse: [
             noneYet
                 ifTrue: [
                     noneYet := false.
                     newLines add:
                         (self leftPartBefore: selection origin),
                             (stream upTo: Lf)]
                 ifFalse:[newLines add: (stream upTo: Lf)]].
     noneYet
         ifTrue: [
             newLines add:
                 (self leftPartBefore: selection origin)].
     endOfReplacement := (newLines last size) @
         (selection top + newLines size - 1).
     line := self rightPartAfter:
             selection origin + selection extent - (1@1).
     excess := line size.
     newLines last become: newLines last , line.
     newLines size = 1
         ifTrue: [
             self
                 replaceLinesIn: selection
                 with: newLines first ]
         ifFalse: [
             lines := lines
                 replaceFrom: selection top
                 to: selection top + selection height - 1
                 with: newLines].
     self
         broadcastChangesIn: selection
         upTo: endOfReplacement
         withExcess: excess.
     ^endOfReplacement!
 replaceGapBefore: aPoint withChar: aCharacter
         "Insert aCharacter before aPoint.
          Answer the number of characters
          to the right of aPoint on the insertion line."
     | line position |
     position := aPoint x - 1.
     line := lines at: aPoint y.
     position = line size
         ifTrue: [
             line become: (line, (String with: aCharacter))]
         ifFalse: [position < line size
             ifTrue: [
                 line become:
                     (line
                         copyReplaceFrom: position + 1
                         to: position
                         with: (String with: aCharacter))]
             ifFalse: [
                 line become:
                     (self leftPartBefore: aPoint + (1 @ 0)).
                 line at: line size put: aCharacter]].
     ^line size - aPoint x!
 replaceLinesIn: selection with: line
         "Replace all lines that have any
          portion selected with line."
     | top height |
     top := selection top.
     ((height := selection height) = 1)
         ifTrue: [lines at: top put: line]
         ifFalse: [
             lines := lines
                 replaceFrom: top
                 to: top + height - 1
                 with: (OrderedCollection with: line)]!
 replaceWithLf: selection
         "Replace the text in selection with the
          line-feed character.  Answer the position
          of the new line.  Inform the text pane of
          the change."
     | origin corner endOfReplacement excess |
     origin := selection origin.
     corner := selection corner.
     self extendTo: corner.
     lines := lines
         replaceFrom: origin y
         to: corner y
         with:
             (OrderedCollection
                 with: (self leftPartBefore: origin)
                 with: (self rightPartAfter: corner)).
     endOfReplacement := 0 @ (origin y + 1).
     self
         broadcastChangesIn: selection
         upTo: endOfReplacement
         withExcess: (lines at: origin y + 1) size.
     ^endOfReplacement!
 replaceWithTab: selection
         "Replace the text in selection with Tab.
          Answer the position of the Tab.  Inform
          the text pane of the change."
     ^self
         replace: selection
         withText: (self tabStringAt: selection origin x)!
 rightPartAfter: aPoint
         "Private - Answer aString containing the
          characters to the right of aPoint."
     | line |
     line := lines at: aPoint y.
     line size <= aPoint x
         ifTrue: [^String new: 0]
         ifFalse: [
             ^line
                 copyFrom: aPoint x + 1
                 to: line size]!
 string
         "Answer a String containing the receiver contents."
     ^self convertToString: lines!
 string: aString
         "Change the receiver contents
          to aString (lines are separated
          by line-feeds)."
     extent := 0@0.
     lines := OrderedCollection new.
     self
         replace: (1@1 corner: 0@1)
         withText: aString!
 stringIn: selection
         "Answer a String which concatenates all
          the lines contained in the selection."
     |origin corner |
     origin := selection origin.
     corner := selection corner.
     self extendTo: corner.
     (self is: corner before: origin)
         ifTrue: [^String new: 0]
         ifFalse:[
             origin y = corner y
                 ifTrue: [
                     ^(self leftPartBefore: corner + (1@0))
                         copyFrom: origin x
                         to: corner x]
                 ifFalse: [
                     ^self convertToString:
                         (self linesIn: selection)]]!
 tabStringAt: anInteger
         "Private - Answer a String of Spaces which spans
          from position anInteger to the next tab stop."
     ^(String new: 4 - ((anInteger - 1) \\ 4) )
         atAllPut: Space!
 textPane: aTextPane
         "Associates aTextPane to the receiver by
          setting the lastChild to it."
     lastChild := aTextPane! !

! UndefinedObject class methods !
 new     "Create a new instance of the receiver.  Disallowed
          for this class because there is only a single
          instance, nil."
     ^self invalidMessage!
 new: anInteger
         "Create a new instance of the receiver.  Disallowed
          for this class because there is only a single
          instance, nil."
     ^self invalidMessage! !

! UndefinedObject methods !
 deepCopy
         "Answer a copy of the receiver with shallow
          copies of each instance variable.  Because
          there is only one nil, answer the receiver."
     ^self!
 isNil
         "Answer true because the receiver is nil."
     ^true!
 notNil
         "Answer false because the receiver is nil."
     ^false!
 printOn: aStream
         "Append the ASCII representation of
          the receiver to aStream."
     aStream nextPutAll: 'nil'!
 shallowCopy
         "Answer a copy of the receiver which shares
          the receiver instance variables.  Because
          there is only one nil, answer the receiver."
     ^self!
 storeOn: aStream
         "Append the ASCII representation of the
          receiver to aStream from which the
          receiver can be reconstructed."
     self printOn: aStream!
 subclass: classSymbol
     instanceVariableNames: instanceVariables
     classVariableNames: classVariables
     poolDictionaries: poolDictNames
 
         "Create or modify the class named by
          classSymbol to be a subclass of receiver
          with the specifed instance variables,
          class variables, and pools.  Used only
          to define class Object, because its
          superclass is nil."
     | meta variableBoolean |
     meta := MetaClass subclassOf: Class.
     ^meta
         name: classSymbol
         environment: Methods
         subclassOf: self
         instanceVariableNames: instanceVariables
         variable: false
         words: true
         pointers: true
         classVariableNames: classVariables
         poolDictionaries: poolDictNames
         comment: String new
         changed: nil! !Copyright 1984 Digitalk Inc.  All rights reserved
